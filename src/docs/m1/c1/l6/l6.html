<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Functions in JavaScript - Advanced</title><link rel="stylesheet" href="../../../../../styles.css"></head><body><article id="364975ce-3acf-424c-a4b0-a251b7df6b66" class="page sans"><header><h1 class="page-title"><span style="white-space:pre">Functions in JavaScript - Advanced</span></h1><p class="page-description"></p></header><div class="page-body"><ul id="2d4e04f5-4993-48a7-9169-6cdfb69b69ca" class="toggle"><li><details close=""><summary><strong><span style="white-space:pre">Session Flow (5 minutes read)</span></strong></summary><ul id="bde1eba6-fbe0-4ff8-b9e7-2acfde089383" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Learning Objective (5 minutes read)</span></strong><ul id="6a82d598-f303-411b-a9dd-4d3479a893e6" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Introduction</span></li></ul><ul id="f20f825c-9de8-4fc5-be4a-e6dfa52e943c" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Theme</span></li></ul><ul id="c516c4b9-6d8a-4558-86a8-2408be8961cb" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Primary Goals</span></li></ul></li></ul><ul id="800f252c-7514-48aa-a46e-3d1369494671" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Functions in JavaScript - II (120 minutes read)</span></strong><ul id="d4122cbe-0f2f-415b-b931-400c88607fed" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Helper Functions</span></li></ul><ul id="d5293696-3907-47c8-a33b-0c922fb030dc" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Benefits of using a Function</span></li></ul><ul id="5c0a0cf8-0078-4465-ab00-66d436a7faf5" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Function Expressions</span></li></ul><ul id="febc911e-870e-4c5e-80d0-54fdc0fc4788" class="bulleted-list"><li style="list-style-type:circle"><strong><span style="white-space:pre">Do it yourself</span></strong></li></ul><ul id="3e07b57d-a24f-4553-8219-44e66d760931" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Types of Functions in JavaScript</span><ul id="88ce8663-ba3d-4bb6-bcd2-3188fb27aed7" class="bulleted-list"><li style="list-style-type:square"><span style="white-space:pre">Arrow Function</span></li></ul><ul id="3187f929-31a8-4497-9d92-8a48b3b3b276" class="bulleted-list"><li style="list-style-type:square"><span style="white-space:pre">Concise Body Arrow Function</span></li></ul><ul id="ac7bed9b-f68f-45f7-a399-5bb265d364a4" class="bulleted-list"><li style="list-style-type:square"><span style="white-space:pre">Anonymous Function</span></li></ul></li></ul><ul id="e9eda14b-46ee-40d6-8568-1224c0ea7bc0" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Function Execution</span></li></ul><ul id="645857ba-3fd6-4df4-a11e-c8c2a190c3a8" class="bulleted-list"><li style="list-style-type:circle"><strong><span style="white-space:pre">Activity 1</span></strong></li></ul><ul id="a6705253-2d45-431d-8938-0ac932b24f22" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">JavaScript Hoisting </span><ul id="cee7cc79-63a1-403e-999b-de7240ec83b5" class="bulleted-list"><li style="list-style-type:square"><span style="white-space:pre">Variable Hoisting</span></li></ul><ul id="b89d812e-fdad-4e61-802a-f54b38a50fd4" class="bulleted-list"><li style="list-style-type:square"><span style="white-space:pre">Function Hoisting</span></li></ul></li></ul><ul id="859ebdf2-5abd-4184-b389-a716064a1828" class="bulleted-list"><li style="list-style-type:circle"><strong><span style="white-space:pre">Activity 2</span></strong></li></ul><ul id="a2b8f881-dacf-49b3-9b83-5cf99a26dda2" class="bulleted-list"><li style="list-style-type:circle"><strong><span style="white-space:pre">Explore Further</span></strong></li></ul></li></ul><ul id="2a979225-8064-4704-9a32-0f6d456e6de0" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Summary (10 minutes read)</span></strong><ul id="79b2d7fe-4dbf-40af-833f-4f2908f4c960" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">What did we learn?</span></li></ul><ul id="f8367558-2273-4e7d-912f-31bee7af05d9" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Shortcomings &amp; Challenges</span></li></ul><ul id="63d738dd-f6d2-4465-911e-2b54db08b20e" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Best Practices</span></li></ul><ul id="7bce0be4-f8a4-4ac5-a7fb-342883f91ae2" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Enhance Your Knowledge</span></li></ul></li></ul></details></li></ul><p id="9f3d73ae-43e7-42d9-a3f8-66565316a8d1" class="">
</p><h1 id="83243e44-dc4a-4050-b4af-d5d23881f377" class=""><mark class="highlight-brown"><span style="white-space:pre">Learning Objective</span></mark></h1><h2 id="4bf9245c-2697-48a2-b17e-aa9da209d742" class="block-color-default"><mark class="highlight-red"><strong><span style="white-space:pre">Introduction</span></strong></mark></h2><p id="1b040076-e30a-409b-a60f-2c9879a34f14" class=""><span style="white-space:pre">Advanced JavaScript functions provide a more powerful and flexible way to write code by utilizing features such as helper functions, function expressions, function execution, and JavaScript hoisting. They allow developers to create modular and reusable code and handle complex scenarios such as asynchronous execution and function composition.</span></p><p id="1a0ab45e-1657-43e7-83aa-a4efd4a43d44" class=""><em><strong><span style="white-space:pre">Duration</span></strong></em><span style="white-space:pre">:</span><strong><span style="white-space:pre"> 2</span></strong><span style="white-space:pre"> Hours</span></p><p id="96697230-c390-48c1-8814-3475f42ee6b6" class=""><em><strong><span style="white-space:pre">Focus</span></strong></em><span style="white-space:pre">: Helper Functions, Function Expressions, Types of Functions in JavaScript, Function execution, and JavaScript Hoisting</span></p><p id="51e75c02-4295-4f21-a791-2ceeac4e9d0b" class=""><em><strong><span style="white-space:pre">Prerequisites</span></strong></em><span style="white-space:pre">: Basics of JavaScript Functions</span></p><h2 id="67f08559-04d3-4682-a142-258caa687609" class="block-color-default"><mark class="highlight-red"><strong><span style="white-space:pre">Theme</span></strong></mark></h2><p id="330f86a1-7e6a-4637-b22a-6809ff4087dc" class=""><span style="white-space:pre">Let&#x27;s consider a fictional e-commerce company called &quot;Shopify&quot; that needs a shopping cart functionality for its website. We can use advanced JavaScript function concepts like helper functions, function expressions, and hoisting to implement this functionality.</span></p><p id="e1e056c5-99a7-42c4-aedf-de35eef80cf0" class=""><span style="white-space:pre">We might use helper functions to perform common tasks like adding or removing items from the cart, calculating the total cost, and validating the items added to the cart. These functions can be called by a main function called </span><code><span style="white-space:pre">updateCart</span></code><span style="white-space:pre">.</span></p><p id="6df5cd4d-93be-4df9-bb05-272e12670a86" class=""><span style="white-space:pre">We can use function expressions to define the helper functions since they only need to be defined within the scope of the </span><code><span style="white-space:pre">updateCart</span></code><span style="white-space:pre"> function. This also allows us to use function execution to call the appropriate helper function based on the action parameter passed into the </span><code><span style="white-space:pre">updateCart</span></code><span style="white-space:pre"> function.</span></p><p id="6d375a1c-31ee-4089-bcea-9abf034961f5" class=""><span style="white-space:pre">JavaScript hoisting comes into play when we use function declarations or variable declarations. When a function or variable is declared with the var keyword, it is hoisted to the top of the function or global scope. This allows us to use the function or variable before it is declared in the code. However, this only applies to declarations, not function expressions or let/const variable declarations.</span></p><h2 id="55e06022-61e4-4586-b0b4-4860a6d50391" class="block-color-default"><mark class="highlight-red"><strong><span style="white-space:pre">Primary Goals</span></strong></mark></h2><ul id="da56bc79-0c46-420c-b7ef-13b2d8ae04cb" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Learn how to create reusable functions that perform specific tasks and can be called from other functions to simplify code.</span></li></ul><ul id="f4e634ea-e125-4a9b-9fb0-c9ab0f804553" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Understand how functions are executed in JavaScript and how to pass arguments to functions.</span></li></ul><ul id="cbc0cd78-22a0-4a0a-89ab-285b38c056ce" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Learn how JavaScript hoists variable and function declarations to the top of their respective scopes.</span></li></ul><ul id="617092ae-842e-4831-ac05-4bc866d90d50" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Understand the difference between function declarations and function expressions and how to use function expressions to create anonymous functions and closures.</span></li></ul><p id="d7563380-25c4-43ac-afa8-23ffbd238553" class="">
</p><h1 id="4bc51ab2-74e5-4ed1-9cd0-e3566262d4a5" class=""><mark class="highlight-brown"><span style="white-space:pre">Functions in JavaScript - II</span></mark></h1><p id="c999e39e-7a5f-407b-acbe-00035a99d756" class=""><span style="white-space:pre">Karen had been working as a web developer for several years, and she had become quite proficient in JavaScript. She had built many applications and websites over the years but always looked for ways to improve her skills.</span></p><p id="e70db1c7-a374-454d-aafd-e965c15f1731" class=""><span style="white-space:pre">One day, she came across helper functions in JavaScript. She had heard of helper functions before but had never explored the concept in depth. Intrigued, she decided to dive in and learn more.</span></p><p id="51afa5c0-c080-44a2-a5d6-f66d8ac9795d" class=""><span style="white-space:pre">She created a simple helper function to take a string and capitalize the first letter. She used this function throughout her application, saving her a lot of time and effort.</span></p><p id="fa86fabe-8c11-4049-b1c7-07e7f1327961" class=""><span style="white-space:pre">As she continued to work with helper functions, she discovered that there were many different types of functions in JavaScript. She learned about anonymous, arrow, and higher-order functions, among others.</span></p><h2 id="f5c57fe9-d96d-4f33-ab20-94f733cdbe01" class="block-color-default"><mark class="highlight-red"><strong><span style="white-space:pre">Helper Functions</span></strong></mark></h2><p id="95967616-93ba-431e-b8e6-410d95f5ab0b" class=""><span style="white-space:pre">Helper functions in JavaScript are tools for dissecting big issues into smaller, easier-to-manage chunks. They can be called from other functions or portions of code and are created to carry out particular activities that are frequently utilized in software. Helper functions enable more modular, readable, and reusable code by decomposing complex problems into smaller jobs.</span></p><p id="9ca95bf7-4f89-404a-8003-fce375c9fa6a" class="">
</p><p id="a268bf93-f812-49bf-bb14-ecb2dfdab7c2" class=""><span style="white-space:pre">Here is an illustration of a helper function that verifies the format of a phone number:</span></p><pre id="12aefdd1-5750-4580-b4cc-294e4443acc5" class="code"><code>function validatePhoneNumber(phoneNumber) {
  var phonePattern = /^\d{3}-\d{3}-\d{4}$/;
  return phonePattern.test(phoneNumber);
}</code></pre><p id="1556418e-237a-47f2-b66c-68490492e21c" class=""><span style="white-space:pre">In this case, the phoneNumber parameter is passed to the </span><code><span style="white-space:pre">validatePhoneNumber()</span></code><span style="white-space:pre"> function, which returns true if the phone number matches a predefined pattern and false otherwise. The function specifies the pattern that the phone number must match using a regular expression. A string beginning with three numbers, followed by a dash, another three digits, another dash, and then four more digits is what the regular expression looks for.</span></p><p id="88e16949-574c-4c7a-9cbf-25bca7b53cd7" class="">
</p><p id="3e397f35-6c3f-4ebc-bf8f-c9d013dc7da5" class=""><span style="white-space:pre">Other sections of the application that call for phone number validation can subsequently use this helper function. This function, for instance, might be used in a sign-up form to verify a user&#x27;s phone number entry before the form is submitted.</span></p><p id="d1739c6e-561e-4cfb-84ba-86e586e80388" class=""><span style="white-space:pre">Developers can make their code more modular and simpler to maintain by adding auxiliary functions. By the reuse of helper functions, code duplication is minimized and program modifications are made simpler. Also, before being utilized in the main program, helper functions can be unit tested independently to make sure they function properly.</span></p><h2 id="ed6ff8f2-88b2-40d1-96ba-80668d90d783" class="block-color-red"><strong><span style="white-space:pre">Benefits of Using a Function</span></strong></h2><ul id="9a0b20bd-0505-46cb-b414-aa8ac0705947" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Reusability</span></strong><span style="white-space:pre">: Functions in JavaScript can be defined once and used multiple times, making code more efficient and easier to maintain.</span><p id="71456e31-770d-4299-8209-fde736e76e7b" class=""><span style="white-space:pre">Let&#x27;s say you have a function called </span><code><span style="white-space:pre">calculateArea</span></code><span style="white-space:pre"> that calculates the area of a rectangle. You can call this function multiple times with different parameters to calculate the area of different rectangles:</span></p><pre id="43a25c2e-faef-48cc-86d7-cb5f44391450" class="code code-wrap"><code>function calculateArea(length, width) {
  return length * width;
}

let area1 = calculateArea(5, 10); // returns 50
let area2 = calculateArea(3, 7); // returns 21</code></pre></li></ul><ul id="c8407944-31f9-4a04-a3e2-d118cb93f964" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Modularity</span></strong><span style="white-space:pre">: Functions allow you to break down complex tasks into smaller, more manageable pieces. This can make your code easier to understand and debug.</span><p id="aa5b62e1-bcbc-4571-8db4-f4e28e2f4b60" class=""><span style="white-space:pre">Let&#x27;s say you have a complex task that involves multiple steps, such as uploading a file, parsing its contents, and saving the results to a database. You can break down this task into smaller functions and call them sequentially:</span></p><pre id="502b31df-d1a7-4502-9191-a841b0498f15" class="code code-wrap"><code>function uploadFile() {
  // code to upload file
}

function parseFile() {
  // code to parse file contents
}

function saveToDatabase(data) {
  // code to save data to database
}

uploadFile();
let data = parseFile();
saveToDatabase(data);</code></pre></li></ul><ul id="e4ea4e99-a7ec-445e-becf-497cf62d4aba" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Encapsulation</span></strong><span style="white-space:pre">: Functions can encapsulate data and logic, making it easier to control and manipulate.</span><p id="03fd2587-8b61-4f3c-9ad6-c622e529adfa" class=""><span style="white-space:pre">Let&#x27;s say you have a function called </span><code><span style="white-space:pre">toggleButton</span></code><span style="white-space:pre"> that toggles the state of a button between </span><code><span style="white-space:pre">on</span></code><span style="white-space:pre"> and </span><code><span style="white-space:pre">off</span></code><span style="white-space:pre">. Instead of manipulating the button directly in your code, you can encapsulate this behavior in a function and call it whenever you need to toggle the button:</span></p><pre id="d34fe849-6d87-4d6a-af29-e5fe1625b0d2" class="code code-wrap"><code>function toggleButton(button) {
  if (button.getAttribute(&#x27;data-state&#x27;) === &#x27;on&#x27;) {
    button.setAttribute(&#x27;data-state&#x27;, &#x27;off&#x27;);
    button.textContent = &#x27;Off&#x27;;
  } else {
    button.setAttribute(&#x27;data-state&#x27;, &#x27;on&#x27;);
    button.textContent = &#x27;On&#x27;;
  }
}

let myButton = document.querySelector(&#x27;#my-button&#x27;);
toggleButton(myButton); // toggles button state</code></pre></li></ul><ul id="6e827290-a1f3-4f06-ad62-94d8bd1b699d" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Scope</span></strong><span style="white-space:pre">: Functions have their own scope, which means they can access and modify variables within their scope, but not outside of it. This can help prevent naming collisions and make your code more secure.</span><p id="3eb263e8-8f29-49a3-bcf3-a0b3e5655a0c" class=""><span style="white-space:pre">Let&#x27;s say you have a function called </span><code><span style="white-space:pre">calculateTotal</span></code><span style="white-space:pre"> that calculates the total cost of an order. Within this function, you define a variable called </span><code><span style="white-space:pre">subtotal</span></code><span style="white-space:pre">. This variable is only accessible within the scope of the function, and cannot be accessed or modified from outside of it:</span></p><pre id="b3fd1d6c-4fe1-48f9-bbcd-892f818c3157" class="code code-wrap"><code>function calculateTotal(items) {
  let subtotal = 0;
  for (let item of items) {
    subtotal += item.price;
  }
  let tax = subtotal * 0.1;
  let total = subtotal + tax;
  return total;
}

let myItems = [
  { name: &#x27;Widget&#x27;, price: 9.99 },
  { name: &#x27;Gadget&#x27;, price: 14.99 },
  { name: &#x27;Doohickey&#x27;, price: 4.99 }
];

let myTotal = calculateTotal(myItems); // returns 31.47</code></pre></li></ul><h2 id="113e21c7-4c93-4217-b363-7236f4faa6f3" class="block-color-default"><mark class="highlight-red"><strong><span style="white-space:pre">Function Expressions</span></strong></mark></h2><p id="adecf323-b062-4948-b637-3a352761c062" class=""><span style="white-space:pre">Using a &quot;function expression&quot; is another technique to define a function. The keyword &quot;function&quot; can be used to define a function inside of an expression. Often, the function name is left out of a function expression. An anonymous function is one that lacks a name. In order to use a function expression, it is frequently kept in a variable.</span></p><p id="00ac1728-c7b5-481a-8e66-61304b870d8e" class=""><span style="white-space:pre">Take into account the following function statement:</span></p><figure id="94c26ef9-07cd-4f37-ae0b-5ca012ab0e56" class="image"><img style="width:2432px" src="Functions%20in%20JavaScript%20-%20Advanced%20364975ce3acf424ca4b0a251b7df6b66/Screenshot_2023-05-03_at_8.41.31_PM.png"/></figure><p id="df132250-06f2-4107-838a-03bc9873b3f4" class=""><span style="white-space:pre">Making a function expression declaration</span></p><ol type="1" id="c5d1970a-2180-4eab-80d3-140e2522f48d" class="numbered-list" start="1"><li><span style="white-space:pre">Put an anonymous function you constructed by using the &#x27;function&#x27; keyword and a set of parentheses with potential parameters as that variable&#x27;s value. The function body is then contained by a set of curly braces.</span></li></ol><ol type="1" id="c1040707-0819-4696-8ac4-d0ec54297822" class="numbered-list" start="2"><li><span style="white-space:pre">Write the name of the variable in which the function is stored, followed by parentheses enclosing any arguments being supplied into the function, to launch a function expression.</span></li></ol><pre id="06c97b11-ff15-4f90-94de-1923e7092842" class="code code-wrap"><code>variableName(argument1, argument2)</code></pre><p id="ad6340e1-9cb5-4be0-a4c9-c0b823161acb" class=""><span style="white-space:pre">Function expressions cannot be called before they are defined since they are not hoisted, unlike function declarations.</span></p><p id="69e0cab2-d997-4209-8f71-ed42a4446b56" class="">
</p><h2 id="d40dcc36-e096-47ac-a9df-9b50024758a7" class="block-color-default"><mark class="highlight-blue"><span style="white-space:pre">Do it yourself</span></mark></h2><p id="d7691898-a948-4b8d-b1ea-bb141c8857d0" class=""><strong><span style="white-space:pre">True or False:</span></strong></p><ol type="1" id="965a8bd9-3e09-478a-b73e-e19278d3f885" class="numbered-list" start="1"><li><span style="white-space:pre">Helper functions are used to break down complex problems into smaller tasks.</span></li></ol><ol type="1" id="707b715c-1a2e-4ee9-a70f-28cdc69b66d6" class="numbered-list" start="2"><li><span style="white-space:pre">Helper functions can only be called from within the main function. </span></li></ol><ol type="1" id="77b04c5f-3d59-4529-99cd-1453e49cd916" class="numbered-list" start="3"><li><span style="white-space:pre">Helper functions enable more modular, readable, and reusable code. </span></li></ol><ol type="1" id="ff457efd-6a27-4050-a33c-db3b9327b130" class="numbered-list" start="4"><li><span style="white-space:pre">Function expressions are hoisted in JavaScript. </span></li></ol><ul id="33fa4d3b-695b-45df-8dea-30cc2477e2d8" class="toggle"><li><details close=""><summary><strong><span style="white-space:pre">Answers</span></strong></summary><ol type="1" id="8d572e7a-e07a-42de-acee-1d328285d5d9" class="numbered-list" start="1"><li><span style="white-space:pre">True</span></li></ol><ol type="1" id="3e787bb5-cd44-4c5f-9da8-d8ca9c87faae" class="numbered-list" start="2"><li><span style="white-space:pre">False</span></li></ol><ol type="1" id="b70fb182-7996-44b5-a9c8-af00d88293fe" class="numbered-list" start="3"><li><span style="white-space:pre">True</span></li></ol><ol type="1" id="e669c6df-c0ce-4e9f-9d71-1235bbe6a234" class="numbered-list" start="4"><li><span style="white-space:pre">False</span></li></ol></details></li></ul><p id="b94b6d55-a345-4063-9ab4-52ec66f4f43c" class="">
</p><h2 id="382fe160-5616-4095-bcd1-71d2f4e941fa" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">Types of Functions in JavaScript </span></mark></h2><h3 id="80edf05c-ede1-4561-b26d-2723e5f558f1" class="block-color-default"><span style="white-space:pre">Arrow Function</span></h3><p id="ab5c195e-d348-4e3c-961d-8c73b71289d0" class=""><span style="white-space:pre">With the help of the unique </span><strong><span style="white-space:pre">fat arrow</span></strong><span style="white-space:pre"> </span><code><span style="white-space:pre">() =&gt;</span></code><span style="white-space:pre"> notation, ES6 provides </span><strong><span style="white-space:pre">arrow function syntax</span></strong><span style="white-space:pre">, a more concise way to define functions.</span></p><p id="e6336e46-bb3a-460e-bb06-a570945037ce" class=""><span style="white-space:pre">Arrow functions eliminate the need to repeatedly type the word &quot;function&quot; while creating a function. Instead, you first include the parameters inside the &quot;()&quot; and then add a &quot;=&gt;&quot; arrow that points to the body of the function and is encircled by &quot; &quot; like in the following example:</span></p><pre id="6c97f998-769d-4b86-b7eb-25bdfe4340c8" class="code code-wrap"><code>const rectangleArea = (width, height) =&gt; {
  let area = width * height;
  return area;
};</code></pre><p id="56e45f35-558b-42d2-8b29-6b5d98df7b6e" class=""><span style="white-space:pre">Because you will encounter each of these when reading other JavaScript code, it is crucial to be familiar with the various ways of constructing functions.</span></p><p id="c98c6306-1a87-4d4e-9e9e-56c136c52efc" class=""><strong><span style="white-space:pre">Concise Body Arrow Functions</span></strong></p><p id="4d38cf04-51ff-4d71-9d4f-1375327396fa" class=""><span style="white-space:pre">There are numerous other ways to alter the syntax of arrow functions in JavaScript. Concise body refers to the function in its most reduced form. Below, we&#x27;ll look at a number of these strategies:</span></p><ol type="1" id="1c0b7587-8736-4c2d-9b5c-fa2b8b68a3b1" class="numbered-list" start="1"><li><span style="white-space:pre">Parentheses are not required around a parameter in a function that only accepts one. But, parentheses are necessary if a function has zero or more parameters.</span><pre id="4a67a6a5-3723-41ef-b6f8-5e86677e37c6" class="code"><code>// Zero Parameters
const functionName = () =&gt; {};

// One Parameters
const functionName = paramOne =&gt; {};

// Two or more Parameters
const functionName = (paramOne, paramTwo) =&gt; {};</code></pre></li></ol><ol type="1" id="d71886c0-04f2-4db3-b1c0-0cc9e67fed55" class="numbered-list" start="2"><li><span style="white-space:pre">Curly braces are not necessary for a function body made out of a single-line block. Whatever that line evaluates will be automatically returned if the curly braces are missing. The </span><code><span style="white-space:pre">return</span></code><span style="white-space:pre"> keyword can be deleted, and the block&#x27;s content should immediately follow the arrow </span><code><span style="white-space:pre">=&gt;</span></code><span style="white-space:pre">. Implicit return describes this situation.</span><pre id="09fd6cf9-25c3-4ce5-bda9-f69b4ca0e491" class="code"><code>// Single-line block
const sum = number =&gt; number + number;

// Multi-line block
const sum = number =&gt; {
	const sum = number + number;
	return sum;             // Return statement
}</code></pre><p id="daf13bcd-d90a-43e6-ab3b-fa3b7e9979fd" class="">
</p></li></ol><p id="01d0d4fc-91cf-49e6-a729-ecd7de8d9e3c" class=""><strong><span style="white-space:pre">So if we have a function:</span></strong></p><pre id="e9e67cac-6c49-4aad-9096-df1345c2469d" class="code code-wrap"><code>const squareNum = (num) =&gt; {
  return num * num;
};</code></pre><p id="3dd466f3-e28d-4c1b-9e39-1ab791d9600a" class=""><strong><span style="white-space:pre">We can refactor the function to:</span></strong></p><pre id="b10503d9-486a-4bf8-9c79-4ae02dfb6843" class="code code-wrap"><code>const squareNum = num =&gt; num * num;</code></pre><h3 id="19bf3117-6dff-4227-9223-8806cb8bb06f" class="block-color-default"><span style="white-space:pre">Anonymous function</span></h3><p id="3dbb9f26-86b6-4ce1-a830-c3d923f69c7c" class=""><span style="white-space:pre">The functions in JavaScript known as </span><strong><span style="white-space:pre">anonymous</span></strong><span style="white-space:pre"> have no name or identification. Similar to how everyone refers to or calls you by your given name. The anonymous functions, however, lack a name, making it impossible to refer to them as regular JavaScript functions.</span></p><pre id="d07bd271-66af-40e4-8d03-75f9e34459de" class="code code-wrap"><code>let variableName = function () {
    //your code here
}

variableName();     // Can call the anonymous function through this</code></pre><p id="8dcee16c-55bb-41d3-9f55-77492e9ebedb" class=""><span style="white-space:pre">In JavaScript, anonymous functions are formed by writing </span><code><span style="white-space:pre">function()</span></code><span style="white-space:pre"> then code inside curly braces </span><code><span style="white-space:pre">{}</span></code><span style="white-space:pre">. In order to use it later, the function is subsequently assigned to a variable. When calling an anonymous function, the variable name must always be specified. When functions must be handled as values, they are helpful since they can be stored in variables.</span></p><p id="9a9fa87b-3ee3-40d5-8b86-9c95f1d7ed2f" class="">
</p><p id="819137d5-151a-4ad3-92a7-f140a7abec22" class=""><strong><span style="white-space:pre">Key Takeaways:</span></strong></p><ul id="2a2bf559-0fea-47bd-8282-3f37f23b11cc" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Anonymous functions are nameless.</span></li></ul><ul id="2ec4d44c-e09e-49f2-8a00-7d849c0feb3b" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">The function keyword, followed by parentheses, can be used to create an anonymous function().
Inside the curly parenthesis, we can write the &quot;function statements&quot; just like we would for any other JavaScript function.</span></li></ul><ul id="4e9d9ca5-3a63-4ea1-9c31-2e0a9fac0e8e" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">The output of an anonymous function is stored in </span><strong><span style="white-space:pre">variables</span></strong><span style="white-space:pre">.</span></li></ul><h2 id="8f7439bb-22a4-473d-9ca4-668384d2e335" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">Function execution</span></mark></h2><ul id="991d18ae-fdd8-45c8-9c74-fa198758632f" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Because JavaScript is an interpreted language, the code is run line-by-line in the JavaScript runtime environment.</span></li></ul><ul id="45685e94-2d38-42c4-ac85-855ac40cd9e2" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">JavaScript behaves the same on the server as in the browser.
Synchronous code execution, including the processing of functions, variables, conditional statements, and loops, all takes place at the call-stack level.</span></li></ul><ul id="6b92bd0f-828a-40f4-b24d-a547253e4d8d" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Synchronous code is executed inside the call-stack.</span></li></ul><ul id="838d43a7-cc97-492c-b484-da83f0e981be" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Line by line, the JavaScript execution environment pushes the code into the call stack and executes it one at a time.</span></li></ul><figure id="9c4705ba-6e05-4966-9a7c-348d1e573d85" class="image"><img style="width:2410px" src="Functions%20in%20JavaScript%20-%20Advanced%20364975ce3acf424ca4b0a251b7df6b66/Screenshot_2023-05-03_at_8.49.50_PM.png"/></figure><h3 id="7c5049b5-c307-45be-873f-23c9db8fc909" class=""><span style="white-space:pre">Call Stack</span></h3><ul id="4db8ce85-cd68-41c7-8628-448c02327b8d" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Internally, Call-stack makes use of the stack data structure. The data structure is a Last-In-First-Out (LIFO) one.</span></li></ul><ul id="cda8aa72-4ab6-4663-a977-5e12f71402c8" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Beginning with the first line, the JavaScript execution environment reads the code line by line before beginning to put it onto the call stack. One thing to observe in this case is that none of the asynchronous code gets pushed into the call-stack. We&#x27;ll talk about it in more detail in the next slides regarding how JavaScript handles it.</span></li></ul><ul id="e3c87ece-b491-4424-b2df-e461ea1806ad" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">When a function is pushed into the call stack, it won&#x27;t be removed until we return or leave the function; only then will it be deleted.</span></li></ul><ul id="856a2ec6-0047-419a-bb03-404750b3af3f" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Call-stack offers the same PUSH, POP, PEEK, and TOP operations as stack data-structure.</span></li></ul><h2 id="773a7a62-2f48-47d2-b603-035a59a69442" class="block-color-default"><mark class="highlight-blue"><span style="white-space:pre">Activity 1</span></mark></h2><p id="08edfc3c-ae7e-4dad-9a13-00c5fbe4bf6d" class=""><strong><span style="white-space:pre">Match the following: </span></strong></p><div id="d4b79a81-7c3f-49bf-ae91-173679d3e3f6" class="column-list"><div id="4d3d6e78-fb58-46f4-8557-8da5335c2a60" style="width:100%" class="column"><p id="903d3f63-3b71-4c9d-9409-4564bcc7e514" class=""><strong><span style="white-space:pre">Option A:</span></strong></p><ol type="1" id="c103dd23-ccf4-4070-8336-69d728171a09" class="numbered-list" start="1"><li><span style="white-space:pre">Arrow Function</span></li></ol><ol type="1" id="3ae9ab02-d13c-4573-9b06-d457d4ce7010" class="numbered-list" start="2"><li><span style="white-space:pre">Concise Body Arrow Functions</span></li></ol><ol type="1" id="81559c6a-f238-45b1-831f-6d258336138f" class="numbered-list" start="3"><li><span style="white-space:pre">Anonymous function</span></li></ol><ol type="1" id="66a1c0f7-5c75-418c-bedd-021ac352fa8b" class="numbered-list" start="4"><li><span style="white-space:pre">Function execution</span><p id="3d283c40-9e16-4145-ab9c-e7686eb486d3" class="">
</p></li></ol><ol type="1" id="48747f5a-48c4-4be6-b7f2-3bc94717b924" class="numbered-list" start="5"><li><span style="white-space:pre">Call Stack</span></li></ol><p id="106d2391-2e6d-41a8-9965-c563286813b7" class="">
</p></div><div id="b3681c4d-0822-4153-9684-c67e77267223" style="width:100%" class="column"><p id="6b77facd-07fc-47ec-90f3-a23f532f41e6" class=""><strong><span style="white-space:pre">Option B:</span></strong></p><p id="26ec931b-ad92-413e-a91a-3159710276c7" class=""><span style="white-space:pre">a. Refers to the function in its most reduced form</span></p><p id="2d4599bf-a9bc-446c-ad47-39fd6cbdedae" class=""><span style="white-space:pre">b. Uses unique &quot;fat arrow&quot; &#x27;() =&gt;&#x27; notation to define functions
c. JavaScript code is run line-by-line in the JavaScript runtime environment
d. Data structure used internally by the JavaScript execution environment to process functions</span></p><p id="dd46dd55-35a0-4f3b-a670-6fb5a6505214" class="">
</p><p id="b04f702e-f3f3-49e5-823e-b6dc4a0895ce" class=""><span style="white-space:pre">e. Functions that have no name or identification</span></p></div></div><ul id="2d47c5bc-4ce1-4bb1-8cb5-57ab80979bf7" class="toggle"><li><details close=""><summary><strong><span style="white-space:pre">Solution</span></strong></summary><p id="11c1a5d7-48f7-4dd9-90c1-ee3c46743be1" class=""><span style="white-space:pre">1-b</span></p><p id="eb1b148d-16f1-49cf-b1f8-5e16dd9e0828" class=""><span style="white-space:pre">2-a</span></p><p id="4524b27a-a678-4725-b27a-d3f99a9b33ce" class=""><span style="white-space:pre">3-e</span></p><p id="38e6a726-e6ce-48ac-b262-28f73b465d0f" class=""><span style="white-space:pre">4-c</span></p><p id="60e06083-cb32-4c42-8d2f-b418c7f969fe" class=""><span style="white-space:pre">5-d</span></p></details></li></ul><p id="e1b52f90-1676-4411-8c8e-c6c3b6547fde" class="">
</p><h2 id="2c7c9112-897d-47e8-acdd-c3d561144451" class="block-color-default"><mark class="highlight-red"><strong><span style="white-space:pre">JavaScript Hoisting</span></strong></mark></h2><p id="f50a4ccd-32b2-4900-9040-ea44ac05dc07" class=""><span style="white-space:pre">In JavaScript, hoisting is the practice of using a function or variable before declaring it. For instance,</span></p><pre id="f8dc80e5-89c3-4fc1-8578-d3ef5dc9f856" class="code code-wrap"><code>// by using test before declaring
console.log(test);   // undefined
var test;</code></pre><p id="350a50a0-b069-406d-82d8-1f601364676f" class="">
</p><p id="7cdb1b18-1082-423b-8852-35896ac2b96b" class=""><span style="white-space:pre">The program above runs and produces an output of undefined, indicating that it behaves in the following way:</span></p><pre id="3457992a-1f27-43de-bced-06e25b7632dc" class="code code-wrap"><code>// by using test before declaring
var test;
console.log(test); // undefined</code></pre><p id="628c1e31-d336-4370-95a1-f3491bb5f84d" class=""><span style="white-space:pre">As the variable </span><strong><code><span style="white-space:pre">test</span></code></strong><span style="white-space:pre"> is only declared and not assigned a value, it is given the undefined value.</span></p><h3 id="dd651278-6c43-494f-95a3-33ba32e12bbf" class="block-color-default"><strong><span style="white-space:pre">Variable Hoisting</span></strong></h3><p id="0cfb060d-3351-4182-a0ce-ad6ede52a328" class=""><span style="white-space:pre">The keywords &quot;var&quot; and &quot;let&quot; do not allow hoisting when it comes to variables and constants.</span></p><p id="4f69034a-060f-4411-81ed-88ea92811ad8" class=""><span style="white-space:pre">For instance,</span></p><pre id="5c1498b4-2516-4e94-a04d-c52832a704a2" class="code code-wrap"><code>// program to display value
a = 5;
console.log(a);
var a; // 5</code></pre><p id="2f8aa060-fb3b-42a1-9979-af22b6dbff64" class="">
</p><p id="6bbfbc53-94ac-48c0-aad9-4abb09acda18" class=""><span style="white-space:pre">In the example provided, the variable a is utilized before its declaration, yet the program still runs and produces the output of 5. The program behaves in the following way:</span></p><pre id="ca1f847b-9eb5-40bd-a26b-1c26827718e4" class="code code-wrap"><code>// program to display value
var a;
a = 5;
console.log(a); // 5</code></pre><p id="299066da-5b35-4214-91b6-170d7137107d" class="">
</p><p id="cc60cd82-05ff-4a15-8c31-09bd5fd86682" class=""><strong><span style="white-space:pre">However in JavaScript, initializations are not hoisted. For example,</span></strong></p><pre id="27f061aa-61cb-45b7-bc08-a247d31752d7" class="code code-wrap"><code>// program to display value
console.log(a);
var a = 5;</code></pre><p id="84e433f6-9375-4792-a758-a02c4c7d2cab" class="">
</p><p id="f665b476-ce21-4c05-84b2-da4d82b62971" class=""><strong><span style="white-space:pre">Output</span></strong></p><pre id="b50464d0-8848-4e48-afdb-adc7fbb0f24a" class="code code-wrap"><code>undefined</code></pre><p id="1322d11d-2ee3-4966-8056-ddc80dac0129" class="">
</p><p id="114f1e87-3cf9-437d-9f85-dab2f8c62260" class=""><strong><span style="white-space:pre">The above program behaves as:</span></strong></p><pre id="afe25e55-2939-4c41-8e14-b0e8f818aa22" class="code code-wrap"><code>var a;
console.log(a);
a = 5;</code></pre><p id="220070ae-ba2d-4c68-b621-9d86d85e1e32" class=""><span style="white-space:pre">In the build stage, only the declaration is copied to memory. Because an is printed without being initialised, its value is hence &quot;undefined&quot;.</span></p><p id="6b194943-41b6-4623-a70c-d667c35be250" class="">
</p><p id="e91c99d5-5d95-4022-ac97-1870a4b72ec1" class=""><strong><span style="white-space:pre">Also, the variable is only raised to the top of the function when it is used inside of it. For instance,</span></strong></p><pre id="52b87e38-d4e8-41b4-b559-c222ed1a22aa" class="code code-wrap"><code>// program to display value
var a = 4;

function greet() {
    b = &#x27;hello&#x27;;
    console.log(b); // hello
    var b;
}

greet(); // hello
console.log(b);</code></pre><p id="28dbf85d-0bbd-47bd-9587-49e7c944534c" class="">
</p><p id="f2df689c-72c2-4f5a-a8c9-123b2058293f" class=""><strong><span style="white-space:pre">Output</span></strong></p><pre id="4d81ac32-eb20-4738-84fc-3bd041658c08" class="code code-wrap"><code>hello
Uncaught ReferenceError: b is not defined</code></pre><p id="25dcd2ed-0369-4774-971b-4e9a516e3c91" class=""><span style="white-space:pre">Variable b is raised to the top of the function greet in the example above and is now a local variable. B is therefore only reachable within the function. There is no global variable created for b.</span></p><blockquote id="5c51baf9-b308-4e9a-a97f-9ea0ae0f063b" class=""><strong><span style="white-space:pre">Note</span></strong><span style="white-space:pre">: When it comes to hoisting, variable declarations are only available to the current scope.</span></blockquote><p id="91eb664c-1da1-41ba-ac08-2f1168f07aab" class="">
</p><p id="8153894b-9e0f-4995-8653-dcf07c008c9c" class=""><span style="white-space:pre">Using the </span><strong><code><span style="white-space:pre">let</span></code></strong><span style="white-space:pre"> keyword with a variable prevents it from being hoisted. </span></p><p id="f921d51b-1647-4526-b7d4-11322559bade" class=""><strong><span style="white-space:pre">For example,</span></strong></p><pre id="b5975aee-da34-45dc-8509-9cdb1e07dced" class="code code-wrap"><code>// program to display value
a = 5;
console.log(a);
let a; // error</code></pre><p id="b048e117-ff65-4778-8573-13116a7dbda8" class="">
</p><p id="d22cf63f-9ed7-4a7f-8b9f-7908ed460fb1" class=""><strong><span style="white-space:pre">Output:</span></strong></p><pre id="e8e383d9-e1a7-4f88-850f-5fe3c1c808a3" class="code code-wrap"><code>Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</code></pre><p id="2fcb9f1e-d7d7-414b-84c0-e96e0bfd6a4d" class=""><span style="white-space:pre">When using </span><strong><code><span style="white-space:pre">let</span></code></strong><span style="white-space:pre">, it is necessary to declare the variable first.</span></p><h3 id="b7f4ee7f-3b6e-4b5a-b253-5a8aa129858c" class="block-color-default"><span style="white-space:pre">Function Hoisting</span></h3><p id="5ceec91d-e228-4278-9829-10184a99c3bc" class=""><span style="white-space:pre">Functions are elevated to the top of the scope in which they are defined in JavaScript&#x27;s function hoisting feature, which occurs before any code is performed. It follows that calling functions before they are defined won&#x27;t result in an error.</span></p><p id="0001410c-f4c9-4e63-8e39-cea1fed03340" class=""><span style="white-space:pre">To put it another way, the JavaScript engine looks for function and variable declarations in the code before moving them to the top of the file when a JavaScript file is loaded into the browser. Functions can be called from anywhere inside the same scope using a technique known as hoisting, even if the definition of the function comes later in the code.</span></p><p id="198529f6-62f2-41c0-9dc9-140d105b6ac5" class=""><span style="white-space:pre">For example -</span></p><pre id="09ef1c08-5e90-414a-b1cc-dc6ecca1328d" class="code code-wrap"><code>// program to print the text
greet();

function greet() {
    console.log(&#x27;Hi, there.&#x27;);
}</code></pre><p id="b53d814d-1cd5-4511-86ce-c2b16e4837f8" class="">
</p><p id="11797ee2-4ae2-439e-96d9-c466dc938a17" class=""><strong><span style="white-space:pre">Output :</span></strong></p><pre id="a7ccc51a-a464-406d-bc52-df0280ea7c9a" class="code code-wrap"><code>Hi, there</code></pre><p id="a51fa18b-a6ee-4360-af6a-392f51b994f7" class=""><span style="white-space:pre">The function &quot;greet&quot; is called in the aforementioned program before it is declared, and the output is displayed. This is a result of lifting.</span></p><p id="fdee4a55-4704-4b04-8fd7-7b5401b1225b" class=""><span style="white-space:pre">Only declarations are hoisted; therefore, when a function is used as an </span><strong><span style="white-space:pre">expression</span></strong><span style="white-space:pre">, an error happens. For instance;</span></p><pre id="f2a79b21-b7f9-41b3-a655-99359f01dc97" class="code code-wrap"><code>// program to print the text
greet();

let greet = function() {
    console.log(&#x27;Hi, there.&#x27;);
}</code></pre><p id="f77f14a1-b365-48ca-8024-20d84e57b441" class="">
</p><p id="2bd08dd0-0a8d-400b-96ca-f27525c3e4f6" class=""><strong><span style="white-space:pre">Output :</span></strong></p><pre id="a443af63-7080-440f-bf09-412a7823dde4" class="code code-wrap"><code>Uncaught ReferenceError: greet is not defined</code></pre><p id="7787a43f-6b64-45e5-92d7-7f284b37f799" class="">
</p><p id="7c08eed5-f30d-4fe9-9a96-107a6faba17c" class=""><span style="white-space:pre">IfÂ </span><code><span style="white-space:pre">var</span></code><span style="white-space:pre"> were used in the above program, the error would be:</span></p><pre id="801066f9-e174-4d5b-aed5-650c2b675504" class="code code-wrap"><code>Uncaught TypeError: greet is not a function</code></pre><p id="1b29d207-acb1-4d44-a13f-8b3ee453fca4" class="">
</p><blockquote id="c97d5bb2-0bdb-46f5-be00-497bb965f597" class=""><strong><span style="white-space:pre">Note</span></strong><span style="white-space:pre">: Generally, programming in other languages like Python, C, C++, and Java does not involve hoisting. Hoisting may result in negative effects on your program. Also, it&#x27;s recommended to avoid hoisting and declaring variables and functions before using them. When dealing with variables, let is preferable to var.</span></blockquote><p id="f347b419-cdd2-405d-8fef-0aec0ff2c549" class="">
</p><h2 id="4d64b911-6412-4120-8085-1827b0e77fd2" class="block-color-default"><mark class="highlight-blue"><span style="white-space:pre">Activity 2</span></mark></h2><p id="15df16b7-1da2-4578-a575-8f60f5d57ec9" class=""><strong><span style="white-space:pre">Complete the crossword</span></strong><span style="white-space:pre">: </span></p><figure id="2dbb1b06-5f51-43aa-b2ae-52333c053fb7" class="image"><img style="width:2464px" src="Functions%20in%20JavaScript%20-%20Advanced%20364975ce3acf424ca4b0a251b7df6b66/Screenshot_2023-05-03_at_8.50.24_PM.png"/></figure><p id="9f7021ec-8e00-40c0-b363-ada151c1ea52" class="block-color-default"><strong><span style="white-space:pre">ACROSS</span></strong></p><p id="342cc230-e764-4cf8-b2e8-c36f5198de0b" class="block-color-default"><span style="white-space:pre">3. In JavaScript, function hoisting occurs before any _________ is performed</span></p><p id="02c49e25-2064-4878-ab8d-572c1618a7f5" class="block-color-default"><span style="white-space:pre">5. In JavaScript, variable declarations are only available to the current __________.</span></p><p id="fc3843ba-d33c-447c-811d-1e9d8a5fa143" class="block-color-default"><span style="white-space:pre">6. When a function is used as an expression, an error happens because only __________ are hoisted.</span></p><p id="3a15bbd2-8734-431f-aefc-b9761d1a4432" class="">
</p><p id="6fdd1530-72b0-4d2e-ac51-3593feeddde1" class="block-color-default"><strong><span style="white-space:pre">DOWN</span></strong></p><p id="21a7d3ee-f983-4b0c-9050-6d2f0289204c" class="block-color-default"><span style="white-space:pre">1. In JavaScript, initializations are not ___________.</span></p><p id="7ac76051-a499-4afb-a49a-e3e80ed7cfbc" class="block-color-default"><span style="white-space:pre">2. A feature in JavaScript where a function or variable can be used before declaring it.</span></p><p id="3dfdb654-f0ab-48e8-97fd-26509cb9c31e" class="block-color-default"><span style="white-space:pre">4. The variable in JavaScript that is only declared and not assigned a value.</span></p><p id="53378732-c094-4853-855b-636b5998f130" class="block-color-default"><span style="white-space:pre">7. When using _________ keyword with a variable in JavaScript, it prevents it from being hoisted.</span></p><ul id="acba335e-36cb-4a72-bab7-8c5b8d0182a3" class="toggle"><li><details close=""><summary><strong><span style="white-space:pre">Answers</span></strong></summary><div id="2fd4887e-b063-4e7c-9c52-105159f60434" class="column-list"><div id="8f2a8e60-1b69-49e3-a1f2-8ef922a58c87" style="width:100%" class="column"><p id="9f7a66cb-58c4-4569-b436-7db20502704c" class=""><strong><span style="white-space:pre">ACROSS :</span></strong></p><p id="72aff537-9a68-442d-8882-f784a0d68197" class=""><span style="white-space:pre">3- CODE</span></p><p id="9f3a0e5a-c620-4bf8-8672-974ada58880f" class=""><span style="white-space:pre">5- SCOPE</span></p><p id="81da5b3b-fdec-4962-9f6f-01eba49748e2" class=""><span style="white-space:pre">6- DECLARATIONS</span></p></div><div id="1a546087-53d2-492d-a926-1a82ef1b938c" style="width:100%" class="column"><p id="10c67f49-3f09-4787-a07a-4e80885d680b" class=""><strong><span style="white-space:pre">DOWN : </span></strong></p><p id="357af460-9a71-4f06-b44a-21a060facb81" class=""><span style="white-space:pre">1- HOISTED</span></p><p id="104989ab-9ec2-40f6-801d-adbf32080ad0" class=""><span style="white-space:pre">2- HOISTING</span></p><p id="9d840c61-b937-491c-bb7b-11a883701111" class=""><span style="white-space:pre">4- UNDEFINED</span></p><p id="c4eccc8c-31a2-4957-86d4-1921689f9570" class=""><span style="white-space:pre">7- LET</span></p></div></div><p id="055994ba-84f5-4f2b-9f1e-41b5cd4afa99" class="">
</p><p id="772ae796-ab05-44e2-9e01-ebab1ae53703" class="">
</p></details></li></ul><p id="e83d5ce8-d3ec-4d42-b54d-7c3f5d88c914" class="">
</p><h2 id="11f8da18-c745-4f5e-a68f-9fda9a094788" class=""><mark class="highlight-blue"><strong><span style="white-space:pre">Explore Further</span></strong></mark></h2><p id="75eeb2d6-f029-4e26-9c89-c79852644263" class=""><mark class="highlight-orange"><strong><span style="white-space:pre">Uncover and unlock new insights as you dive into the captivating content found in the provided link.</span></strong></mark></p><p id="033bcecf-a1b4-4538-8d2c-0ab5c47174b4" class=""><strong><span style="white-space:pre">Closures in JavaScript: </span></strong><a href="https://blog.hubspot.com/website/javascript-closure"><span style="white-space:pre">https://blog.hubspot.com/website/javascript-closure</span></a></p><p id="c89cec6a-441d-42da-8092-34e8d3254dd9" class="">
</p><p id="bb426470-b6f3-4d4f-8f70-9b125961bbf7" class=""><mark class="highlight-orange"><strong><span style="white-space:pre">Tackle these questions head-on!</span></strong></mark></p><p id="ac6a78b1-fcc0-40a1-9546-d6e42b30f6a1" class=""><strong><span style="white-space:pre">Create a Counter using Closure:</span></strong></p><ol type="1" id="bcf87e41-add0-43a1-ab5d-cb2463725d56" class="numbered-list" start="1"><li><span style="white-space:pre">Create a function called </span><code><strong><span style="white-space:pre">createCounter</span></strong></code><span style="white-space:pre"> that returns another function.</span></li></ol><ol type="1" id="e3a71f69-7e8f-48fb-97c1-42c1223ee52b" class="numbered-list" start="2"><li><span style="white-space:pre">Inside the </span><code><strong><span style="white-space:pre">createCounter</span></strong></code><span style="white-space:pre"> function, declare a variable called </span><code><strong><span style="white-space:pre">count</span></strong></code><span style="white-space:pre"> and set its initial value to 0.</span></li></ol><ol type="1" id="473e8a86-5eda-4b6a-b56c-91f58dce4c36" class="numbered-list" start="3"><li><span style="white-space:pre">Inside the returned function, increment the </span><code><strong><span style="white-space:pre">count</span></strong></code><span style="white-space:pre"> variable by 1 each time the function is called.</span></li></ol><ol type="1" id="74e3abde-1456-48d1-8257-255b63a2ad2d" class="numbered-list" start="4"><li><span style="white-space:pre">Return the current value of </span><code><strong><span style="white-space:pre">count</span></strong></code><span style="white-space:pre"> from the returned function.</span></li></ol><ol type="1" id="4e84eab3-9c0c-48a2-9e65-c2b2e02ee883" class="numbered-list" start="5"><li><span style="white-space:pre">Store the returned function in a variable called </span><code><strong><span style="white-space:pre">counter</span></strong></code><span style="white-space:pre">.</span></li></ol><ol type="1" id="0d12200e-204a-4416-a670-9a786d14748e" class="numbered-list" start="6"><li><span style="white-space:pre">Test the counter by calling it multiple times and observing the output.</span></li></ol><ul id="a7358021-9d13-4bab-8877-abce3865eb37" class="toggle"><li><details close=""><summary><strong><span style="white-space:pre">Solution</span></strong></summary><pre id="ea458a09-0a17-44bb-a96e-a4797b85615f" class="code"><code>function createCounter() {
  let count = 0;

  return function() {
    count++;
    return count;
  };
}

const counter = createCounter();

console.log(counter()); // Output: 1
console.log(counter()); // Output: 2
console.log(counter()); // Output: 3</code></pre><ul id="a6b2b811-d136-4b39-bcb2-bb81481545ca" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">The </span><code><strong><span style="white-space:pre">count</span></strong></code><span style="white-space:pre"> variable is defined inside the </span><code><strong><span style="white-space:pre">createCounter</span></strong></code><span style="white-space:pre"> function and is accessible within the returned function due to closure.</span></li></ul><ul id="d286c729-e10d-454e-b7f5-040fa600698f" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Every time the returned function is called, it increments the </span><code><strong><span style="white-space:pre">count</span></strong></code><span style="white-space:pre"> variable by 1 and returns the updated value.</span></li></ul><ul id="81c399d5-a7f9-4fb2-8957-465edffa874f" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">The </span><code><strong><span style="white-space:pre">counter</span></strong></code><span style="white-space:pre"> variable holds the returned function, which retains access to the </span><code><strong><span style="white-space:pre">count</span></strong></code><span style="white-space:pre"> variable.</span></li></ul><ul id="045e13e3-a224-4364-a527-c8d74e8ff157" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">When we call </span><code><strong><span style="white-space:pre">counter()</span></strong></code><span style="white-space:pre"> multiple times, we observe that the value of </span><code><strong><span style="white-space:pre">count</span></strong></code><span style="white-space:pre"> is incremented with each call, demonstrating the concept of closures.</span></li></ul></details></li></ul><p id="f912a0a9-5108-40d8-b4a8-510f59ac81f8" class="">
</p><p id="b9cd1b4a-626e-45e6-bdce-f5b771d659c1" class="">
</p><blockquote id="22461bdb-1495-43cb-8b82-f9bf30e38dbc" class="block-color-default"><strong><span style="white-space:pre">A function&#x27;s speed and efficiency can significantly influence a program&#x27;s performance.</span></strong></blockquote><p id="c3c79b20-c560-46a6-81b0-4cdb89527017" class="">
</p><p id="96a23ad1-9c52-443a-8b14-4ea7a02cd743" class="">
</p><h1 id="6ddc377d-521f-4fc3-b791-fb17f1d92e85" class=""><mark class="highlight-brown"><span style="white-space:pre">Summary</span></mark><mark class="highlight-red"><span style="white-space:pre"> </span></mark></h1><h2 id="4a5a1b23-6164-47ef-bbf4-7e0ac2383050" class="block-color-default"><mark class="highlight-red"><strong><span style="white-space:pre">What did we learn?</span></strong></mark></h2><ul id="e4500e09-0361-4b44-85e9-480ffd4516a3" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">JavaScript is a high-level, interpreted, and dynamic programming language. It is widely used to create interactive and dynamic web pages and applications.</span></li></ul><ul id="7fc44519-d38e-4789-a940-687a3916ff78" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">A helper function is a reusable function that performs a specific task and can be called from other functions to simplify code. Helper functions can be used to perform common tasks such as adding or removing items from an array, validating user input, formatting data, and more.</span></li></ul><ul id="e775b458-44a0-44bb-b583-af099d1759a9" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">In JavaScript, a variable is a container that holds a value and can be referenced by a name. Variables declaration can be done using the </span><code><span style="white-space:pre">var</span></code><span style="white-space:pre">, </span><code><span style="white-space:pre">let</span></code><span style="white-space:pre">, or </span><code><span style="white-space:pre">const</span></code><span style="white-space:pre"> keywords and can store different data types, such as numbers, strings, and objects.</span></li></ul><ul id="b558d413-76a3-4578-8a61-03e2c2b4d0ad" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Function execution in JavaScript refers to calling and running a function. When a function is executed, it executes the code inside it from top to bottom. </span></li></ul><ul id="4a2acebb-b90b-489c-9117-65ea06adacb3" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">The execution of a function can be triggered in several ways, such as by calling the function by its name, by invoking it as a method of an object, or by using the </span><code><strong><span style="white-space:pre">apply</span></strong></code><span style="white-space:pre"> or </span><code><strong><span style="white-space:pre">call</span></strong></code><span style="white-space:pre"> methods.</span></li></ul><ul id="1cc8c761-fbd1-4ce6-addd-01aff9370315" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Function expressions are used to create functions as values and can be used as arguments or assigned to variables. </span></li></ul><ul id="461af34c-1899-4f57-ad7a-cb6cc9462fa5" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Function declarations are used to create named functions and are hoisted to the top of their scope. </span></li></ul><ul id="a66d5771-0243-4271-aa21-0246f9a75668" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Functions in JavaScript can also take parameters, which are values passed into the function and can return a value using the return statement.</span></li></ul><ul id="90291ae3-edf5-49a0-bb2e-a9de0e56d60a" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">JavaScript functions can be of two types: named functions and anonymous functions. Named functions have a name and can be called using that name.</span></li></ul><h2 id="53c28393-42ca-4360-855c-80109ed0db8f" class="block-color-default"><mark class="highlight-red"><strong><span style="white-space:pre">Shortcomings</span></strong></mark></h2><ul id="38b93128-e105-4275-931f-6491d6b80dde" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Helper functions can add complexity to code if not used appropriately.</span></li></ul><ul id="f3837c33-51a0-4877-8002-11d7291d3f44" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">The scope and context of a function can impact function execution.</span></li></ul><ul id="9dfd28a1-502d-4686-b2dd-48517583e7c7" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">JavaScript hoisting can lead to unexpected behavior if not understood and managed properly.</span></li></ul><ul id="b10e5fea-6f8e-4799-90c0-147568a75817" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Anonymous functions can be difficult to debug if they don&#x27;t have a name.</span></li></ul><ul id="ff58664a-0657-45df-bc8c-6f13917c95db" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Care must be taken when using function expressions with the &quot;this&quot; keyword, as it can refer to different objects depending on how the function is called.</span></li></ul><ul id="d0cf76ef-5e8c-4ae5-a8de-79cbbcbbec42" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Overuse of functions can result in decreased performance, especially in complex applications.</span></li></ul><ul id="062dcbe1-a093-45e1-9621-06bc4895773e" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Functions should be kept concise and well-organized to maintain code readability and maintainability.</span></li></ul><h2 id="ae10a65b-0682-4347-bba2-c05ce6bf2fe5" class="block-color-default"><mark class="highlight-red"><strong><span style="white-space:pre">Best Practices</span></strong></mark></h2><ul id="d9987834-1120-4baa-b5ed-e107b62d70d6" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Use descriptive function names that accurately reflect the function&#x27;s purpose and behavior</span></li></ul><ul id="cc1d7d84-bc70-4452-8404-ff7e5d76b49b" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Break down complex functions into smaller, reusable helper functions</span></li></ul><ul id="2baaca3b-89e2-4604-9d22-416abef6ef09" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Avoid using global variables inside functions to prevent unintended consequences and make the function more portable</span></li></ul><ul id="981ee47c-662f-4dc9-aab0-b186dd6fefc2" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Always declare variables with the let or const keywords to prevent potential issues with variable hoisting</span></li></ul><ul id="5e77da25-4d81-40a6-b315-71998600e253" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Use function expressions instead of function declarations for helper functions that don&#x27;t need to be hoisted</span></li></ul><ul id="79fa9ec9-0abb-4c72-8764-df955d857098" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Consider using arrow functions for simple functions that have concise, single-line bodies</span></li></ul><ul id="7a887142-d153-4497-8891-7f3dfea7d5a7" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Aim for functions to have a single responsibility and to be as modular and reusable as possible</span></li></ul><h2 id="932daba3-21a7-4bf0-b55b-5d8e9573cb3c" class="block-color-default"><mark class="highlight-red"><strong><span style="white-space:pre">Enhance Your Knowledge</span></strong></mark></h2><ul id="fb4896e8-f554-47d2-b3e0-e223d441fd3b" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.javascript.com/"><span style="white-space:pre">More on JavaScript</span></a></li></ul><ul id="3ca3a330-d76b-47f7-ac35-fc3dd77deacd" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.joshwcomeau.com/javascript/statements-vs-expressions/"><span style="white-space:pre">https://www.joshwcomeau.com/javascript/statements-vs-expressions/</span></a></li></ul><p id="cfda8964-134d-433c-a99d-d6124c2794be" class="">
</p></div></article></body></html>