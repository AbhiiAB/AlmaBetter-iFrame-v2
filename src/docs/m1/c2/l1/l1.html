<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Functional Programming</title><link rel="stylesheet" href="../../../../../styles.css"></head><body><article id="edc4e332-0d64-41d1-b26b-8cc8dc376335" class="page sans"><header><h1 class="page-title"><span style="white-space:pre">Functional Programming</span></h1><p class="page-description"></p></header><div class="page-body"><ul id="704efadf-5e29-418e-9517-f9b0f5f64d99" class="toggle"><li><details close=""><summary><strong><span style="white-space:pre">Session Flow ( 5 minutes read)</span></strong></summary><ul id="26b6ca2b-c2c6-483a-9ee3-05538202b706" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Learning Objective (5 minutes read)</span></strong><ul id="9e2d15b4-783e-4cf7-b02c-62664f067eaa" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Introduction</span></li></ul><ul id="15e0b728-50f3-4f60-a187-f2dc98424a88" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Theme</span></li></ul><ul id="308b3bcb-470c-4223-898c-d135b04f131e" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Primary Goals</span></li></ul></li></ul><ul id="f1068b49-5984-4f35-9255-a35634657e5b" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Functional Programming (120 minutes read)</span></strong><ul id="83882502-e0dc-42d2-a6b6-01e09dd5b5a0" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">What is Functional Programming?</span></li></ul><ul id="159f746e-67ed-42f7-be75-31189c9db436" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Pure Functions</span></li></ul><ul id="b5168f1a-97ae-47c5-9d4d-569bd5178360" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">First-Class Objects</span><ul id="6cd246e7-ad22-4c1c-9830-b64c8fc941fc" class="bulleted-list"><li style="list-style-type:square"><span style="white-space:pre">Uses of a First-Class Function</span></li></ul></li></ul><ul id="312844e5-bcdf-45c1-9224-9ffe780cbe4a" class="bulleted-list"><li style="list-style-type:circle"><strong><span style="white-space:pre">Try it yourself</span></strong></li></ul><ul id="270cc859-b096-4d08-b074-208da324c56c" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Higher Order Function</span></li></ul><ul id="ff612d86-e332-42a6-88d3-8300cdc50e8f" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Function Composition</span></li></ul><ul id="28a0bf2d-e38c-4bc6-bfc8-3e79750b9878" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Traditional Approach</span><ul id="9ed8eb65-f7dc-4858-88c9-20ccc795af14" class="bulleted-list"><li style="list-style-type:square"><span style="white-space:pre">Alternate Approach: </span><strong><code><span style="white-space:pre">compose</span></code></strong><strong><span style="white-space:pre"> </span></strong><span style="white-space:pre">function and </span><strong><code><span style="white-space:pre">pipe</span></code></strong><strong><span style="white-space:pre"> </span></strong><span style="white-space:pre">function</span></li></ul></li></ul><ul id="490115ef-99a4-4489-9abb-5dbe0bd5b517" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Immutability in JavaScript</span></li></ul><ul id="d21e858f-4942-4dd6-90e9-41ff2e200e52" class="bulleted-list"><li style="list-style-type:circle"><strong><span style="white-space:pre">Explore Further</span></strong></li></ul><ul id="ca5063d4-be45-4cee-97bd-56864a37dce1" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Declarative and Imperative Code</span></li></ul><ul id="06f7c24c-2025-4bd1-8764-e1989ffbb3b0" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Benefits of Functional Programming</span></li></ul><ul id="6f4bd78f-ad91-40aa-92a8-ed0dbd194ea0" class="bulleted-list"><li style="list-style-type:circle"><strong><span style="white-space:pre">Activity</span></strong></li></ul></li></ul><ul id="85944f9f-9c79-40ff-84d9-694ce5c78e0b" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Summary (10 minutes read)</span></strong><ul id="7eb39210-c72e-4b3d-914f-9417ab6abff7" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">What did we learn?</span></li></ul><ul id="08c5c7bb-5c50-4910-bb27-04260a0a0c97" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Shortcomings &amp; Challenges</span></li></ul><ul id="b32f5537-4ef7-498f-bfef-f8b49f39d50d" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Best Practices</span></li></ul><ul id="1539c293-7ede-416e-ae8c-4a6dc61f15ef" class="bulleted-list"><li style="list-style-type:circle"><span style="white-space:pre">Enhance Your Knowledge</span></li></ul></li></ul></details></li></ul><p id="05c72f43-86ce-4798-9759-6e694e60749d" class="">
</p><h1 id="ff3a1c8f-0f25-46cf-a45d-6fd29fc53834" class="block-color-default"><mark class="highlight-brown"><span style="white-space:pre">Learning Objective</span></mark></h1><h2 id="da23f4e3-d37e-4ff7-a118-03e1fe05b174" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">Introduction</span></mark></h2><p id="83f58de3-a569-4b58-a810-05c8d6141ce7" class=""><span style="white-space:pre">Ahoy there! JavaScript is a versatile language that has come a long way since its inception. In this chapter, we&#x27;ll dive into Functional Programming, a paradigm that can help us write cleaner, more elegant code, and some of the modern concepts that make JavaScript such a powerful tool for web development, like the new features introduced in ES5 and ES6, and learn how they can help us write more efficient and maintainable code and last but not least the fascinating world of Regular Expressions and debugging techniques, two essential skills for any JavaScript developer and  </span></p><p id="b893ebf5-a53e-441b-bba1-77dd1c743c69" class=""><strong><span style="white-space:pre">Duration</span></strong><span style="white-space:pre">: 2 hours</span></p><p id="6771599b-4d0a-4b79-b0c1-a7d813a40ea7" class=""><strong><span style="white-space:pre">Focus</span></strong><span style="white-space:pre">:  Functional Programming, RegEx &amp; Debugging in JavaScript and ES5 and ES6 concepts</span></p><p id="4ded8e39-18d6-481a-89f3-db3430fdef02" class=""><strong><span style="white-space:pre">Prerequisites</span></strong><span style="white-space:pre">: NA</span></p><h2 id="14b3d3d4-d115-4e2a-954c-3590193ab9d7" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">Theme</span></mark></h2><p id="ecec6db0-5be8-4c89-a43f-a08908bcf9e2" class="block-color-default"><span style="white-space:pre">Picture this: You&#x27;re a budding web developer, fresh out of college, and you&#x27;ve landed your dream job at a tech startup. You&#x27;re eager to make a name for yourself and show your skills, but you quickly realize that the company&#x27;s web app is riddled with bugs, slow performance, and a confusing user interface. You start digging into the codebase, and you discover that most of the code is written in an outdated version of JavaScript. You know you have to act fast to bring the app up to speed, but where do you even begin?</span></p><p id="89d3b784-609c-478b-994c-4e0124a51104" class="block-color-default"><span style="white-space:pre">Look no further than the Modern JavaScript Concepts chapter. Here, we&#x27;ll explore the latest features of ES5 and ES6, like arrow functions and template literals, that can make your code more readable and efficient. But that&#x27;s not all! We&#x27;ll also dive into debugging techniques and Regular Expressions, which are essential for keeping your code bug-free and matching patterns in strings. And don&#x27;t forget about Functional Programming, a paradigm that emphasizes clean, maintainable code. Get ready to take your JavaScript skills to the next level!</span></p><h2 id="cadb7ef4-8478-4ff7-af2a-98cf87f7ff16" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">Primary Goals</span></mark></h2><ul id="36be6143-723b-4bcf-9a46-f396128a4fce" class="block-color-default bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Understand ES5 and ES6 Concepts, learning new features and enhancements to write efficient code.</span></li></ul><ul id="2bc6af60-a0a1-413d-8fab-a37b85096df9" class="block-color-default bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Master Regular Expressions and Debugging Techniques effectively.</span></li></ul><ul id="262535f2-777a-4551-9cbf-b7e8c187f53b" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Understand pure functions, immutability, higher-order functions, and functional programming libraries.</span></li></ul><p id="278d5273-f7cb-4ebc-8075-3d15265a2b17" class="">
</p><h1 id="6fdbac6d-beda-4bff-a340-21e9dc7052ef" class="block-color-default"><mark class="highlight-brown"><span style="white-space:pre">Functional Programming</span></mark></h1><p id="da2aefae-4a31-42d7-bd0e-95b0e5789a87" class="block-color-default"><span style="white-space:pre">Sophie was a software developer who had been working with JavaScript for several years. She was always looking for new and innovative ways to improve her code, and one day she stumbled upon the concept of Functional Programming.</span></p><p id="223e3c05-1f1c-4ac6-8d81-fd260037783b" class="block-color-default"><span style="white-space:pre">The programming paradigm known as Functional Programming highlights the utilization of pure functions, immutability, and higher-order functions. It was a new way of thinking about programming for Sophie, who had worked primarily with Object-Oriented Programming (OOP) until then.</span></p><p id="76788200-136d-4d39-95eb-490992bbedee" class="block-color-default"><span style="white-space:pre">Sophie quickly realized the benefits of functional programming in JavaScript. Her code became more concise, easier to test, and easier to understand. She also found it easier to reason about her code, which helped her catch bugs and solve problems more quickly.</span></p><h2 id="82811861-2711-4a04-b747-99aa10c64590" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">What is Functional Programming?</span></mark></h2><p id="7039d87c-8cd7-4b07-973f-527efb8a54e6" class="block-color-default"><span style="white-space:pre">The programming paradigm of Functional Programming emphasizes utilizing functions as building blocks to develop programs. It is </span><strong><span style="white-space:pre">based on the mathematical concept</span></strong><span style="white-space:pre"> of a function, where a function takes input values and produces output values without side effects.</span></p><p id="8ff9f4ae-0540-49a8-8f6a-7a7af45e1e3c" class="block-color-default"><span style="white-space:pre">In functional programming, functions are first-class citizens, meaning they can be </span><strong><span style="white-space:pre">passed around as arguments to other functions</span></strong><span style="white-space:pre">, returned as values from functions, and stored in data structures. Functional programming typically avoids mutable state and relies instead on immutable data structures and pure functions that don&#x27;t modify the state of the program.</span></p><figure id="81f1efcb-4916-491c-84f0-07d275a5bec8" class="image"><img style="width:2480px" src="Functional%20Programming%20edc4e3320d6441d1b26b8cc8dc376335/Screenshot_2023-04-27_at_7.49.22_PM.png"/></a></figure><p id="15638ebb-dbb7-44b3-a189-1e6e8e5bbea2" class=""><span style="white-space:pre">Here are some characteristics of the functional programming paradigm:</span></p><ul id="ca05d23e-7671-4588-a4f9-eac69026deac" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Immutable</span></strong><span style="white-space:pre"> data refers to the state where values assigned to a variable cannot be altered after the assignment.</span></li></ul><ul id="9c929bdd-d9e3-45cf-a6e1-5df762b09763" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Usage of pure functions</span></strong><span style="white-space:pre">: Pure functions always return the same result given the same input and have no side effects.</span></li></ul><ul id="af8faf93-8cff-4d81-ac72-c5df5ce6eddb" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Functions of a higher order can take arguments and return values.</span></li></ul><ul id="6c605547-c2be-4031-86d9-d977057b9db0" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Recursion</span></strong><span style="white-space:pre">: Functions can call one another, enabling strong and beautiful solutions to some issues.</span></li></ul><ul id="991a03c5-4ed5-4a35-80db-23165f7382b8" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Expression-oriented</span></strong><span style="white-space:pre">: Rather than using statements to construct programs, expressions are frequently used.</span></li></ul><ul id="5325a711-81bf-4e95-a5f7-9769849f3f8e" class="bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Lazy evaluation:</span></strong><span style="white-space:pre"> Only compute values when necessary to better use resources.</span></li></ul><ul id="2a616132-0da7-4c5e-a0bb-971a82876e87" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Several functional programming languages use </span><strong><span style="white-space:pre">type inference</span></strong><span style="white-space:pre"> to automatically infer types, eliminating the requirement for explicit type annotations.</span></li></ul><h2 id="18064683-8d0f-4fdc-b54e-59ee2c924a22" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">Pure Functions</span></mark></h2><p id="75759281-0ffc-4964-a951-d53f784ecc4a" class=""><span style="white-space:pre">Pure functions in JavaScript always </span><strong><span style="white-space:pre">produce the same result given the same input</span></strong><span style="white-space:pre"> and have </span><strong><span style="white-space:pre">no side effects</span></strong><span style="white-space:pre">. Because they make it simpler to analyze code and avoid errors, they are crucial to functional programming.</span></p><p id="af5da45a-2b0f-4479-80d7-d41392104388" class=""><span style="white-space:pre">A pure function </span><strong><span style="white-space:pre">accepts one or more input values</span></strong><span style="white-space:pre">, computes purely using those values, and then outputs a brand-new result. The function alters no external state, such as global variables or objects passed by reference. The function also doesn&#x27;t have any unintended consequences, like writing to a file or sending queries over the network.</span></p><p id="da6eda1a-e994-426d-9913-1a1d1fbc1384" class=""><span style="white-space:pre">Here&#x27;s an example of a pure function in JavaScript:</span></p><pre id="33ae414d-6eee-4bdd-98bf-4e5d573752d2" class="code"><code>function add(a, b) {
  return a + b;
}</code></pre><p id="c67aca45-5a44-4f2d-9eab-5d9657c4fb97" class=""><span style="white-space:pre">The add function returns the total of two input values, a and b. There are no adverse effects, and it doesn&#x27;t alter any external conditions. Because it consistently produces the same result given the same input, it is a pure function.</span></p><p id="bf039018-2d3d-4c6e-9040-d1351c98c995" class=""><span style="white-space:pre">Here is an illustration of a JavaScript impure function, in contrast:</span></p><pre id="5df34966-3f8d-4212-9f5f-13ed999253db" class="code"><code>let counter = 0;

function increment() {
  counter++;
  return counter;
}</code></pre><p id="75af178e-c42d-4ca9-860d-9be27e0b3f69" class=""><span style="white-space:pre">The increment function changes the external counter variable every time it is called. Because it modifies the external state as a side effect, it is not a pure function.</span></p><p id="e384d495-1e36-42e3-a5c9-4729f0eef89b" class="">
</p><p id="92cfb1cd-8ee4-4cce-9d10-01fc6e26d309" class=""><span style="white-space:pre">Since they make testing and reasoning about code simpler, pure functions are crucial. Pure functions are predictable and can be used confidently in other portions of the code since they always produce the same result when given the same input. It is also simpler to build test cases for pure functions with known input and anticipated output because their behaviour is fully governed by the values of their inputs.</span></p><h2 id="209e85b3-14b5-40e3-8deb-752310158b1f" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">First-Class Objects</span></mark></h2><p id="0b8c8bec-d8ef-45a5-9578-f5ed97d5d92f" class=""><span style="white-space:pre">Functions can be treated like any other value because they are first-class objects in JavaScript. More specifically, functions can be used as values returned from functions, supplied as arguments to other functions, and set to variables.</span></p><p id="05e2787a-fca2-45bd-ba1e-bf2b3dee0a6d" class=""><span style="white-space:pre">Here is an illustration of how to give a variable a function:</span></p><pre id="72ca1262-b142-455d-8c65-e6ab2c8ee9f0" class="code"><code>const add = function(a, b) {
  return a + b;
};</code></pre><p id="d2c4c79b-4379-43b2-9c10-b4e75bae4752" class=""><span style="white-space:pre">A function is defined and given control over the add variable in this code. Thus, using the variable add, the function can be called as follows: add (2, 3).</span></p><p id="893a4255-2e74-4523-bade-78dc15ee1e1b" class=""><span style="white-space:pre">An illustration of providing a function as an argument to another function is given below:</span></p><pre id="be52144c-57f1-4b01-8154-3712979b0b1d" class="code"><code>function operateOnNumbers(a, b, operation) {
  return operation(a, b);
}

const result = operateOnNumbers(2, 3, add);</code></pre><p id="fc61bd2a-a7e8-430a-a8b2-b83e002ad598" class=""><span style="white-space:pre">The operateOnNumbers function in this code accepts two numbers and a function as parameters. The numbers are processed by the function, which then returns the outcome. operateOnNumbers receives an argument from the add function as the operation parameter. This makes it possible to utilise the function for more than just addition.</span></p><p id="be83cd6e-7ade-4c19-8b8b-b0eb76085b33" class=""><span style="white-space:pre">This is an example of returning a function from another function, to wrap things up:</span></p><pre id="ab829ff1-955b-48db-9ac7-1e95fde253bd" class="code"><code>function createAdder(x) {
  return function(y) {
    return x + y;
  }
}

const add5 = createAdder(5);
const result = add5(3); // returns 8</code></pre><p id="c4d02d5e-9434-410d-ab26-55133369bf07" class=""><span style="white-space:pre">The createAdder method in this code returns a second function that accepts a single parameter and returns the product of the argument and the value supplied to createAdder. The createAdder method&#x27;s returning function, which multiplies its input by 5, is assigned to the add5 variable. The outcome of using add5 with the parameter of 3, which returns 8, is then put into the result variable.</span></p><p id="e2cc8a0e-a628-4826-a764-bb638d614d17" class=""><span style="white-space:pre">Since they enable effective functional programming techniques like closures and higher-order functions, first-class functions are crucial in JavaScript. JavaScript enables developers to construct more adaptable and reusable code by treating functions as values.</span></p><h3 id="000165f8-ebe4-4ecb-aab8-fde1ab65076b" class=""><span style="white-space:pre">Uses of a First-Class Function</span></h3><p id="a554e958-e1d6-4071-8087-fe84d154d5cd" class=""><span style="white-space:pre">So, we know that functions in JavaScript are first-class citizens. Now, what do we do with that knowledge? First-class functions give us a wide variety of flexible and powerful design patterns. These patterns let us write more readable, dynamic, and concise code. Let’s take a look at a few.</span></p><p id="9dd68f51-12b0-4298-93a9-289b859720c3" class="">
</p><h2 id="b1be17d7-bf39-418c-aef6-c749f29de673" class="block-color-default"><mark class="highlight-blue"><span style="white-space:pre">Try it yourself</span></mark></h2><figure id="cc806314-7b50-461a-9cec-7c6129f17c57" class="image"><img style="width:2474px" src="Functional%20Programming%20edc4e3320d6441d1b26b8cc8dc376335/Screenshot_2023-04-27_at_7.48.49_PM.png"/></a></figure><p id="f95bc6a1-b2d1-4b79-ba17-a8017742f9ab" class="block-color-default"><strong><span style="white-space:pre">ACROSS </span></strong></p><p id="1768e1d1-c263-439d-9391-4b08153d3704" class="block-color-default"><span style="white-space:pre">4. This concept is based on the mathematical concept of a function, where a function takes input values and produces output values without side effects. -  __________ transparency</span></p><p id="a79b90c5-c68a-4d9c-b494-3dae891de2a5" class="block-color-default"><span style="white-space:pre">8. Rather than using statements to construct programs, this ________ -oriented approach is frequently used in functional programming.</span></p><p id="d84ad24b-07be-4e5f-ab4e-d1440e8e159c" class="block-color-blue">
</p><p id="262d08f7-85d2-4d4b-8f1f-f89b83ed1fe7" class="block-color-default"><strong><span style="white-space:pre">DOWN </span></strong></p><p id="d91949dc-1d86-4ad8-984b-f9d470b8bc8d" class="block-color-default"><span style="white-space:pre">1. Pure functions in JavaScript always produce the same result given the same input and have no ____ effects.</span></p><p id="320f071f-eaec-459a-985f-4d4ad74f3356" class="block-color-default"><span style="white-space:pre">2. Functional programming typically avoids mutable state and relies instead on immutable data structures and ____ functions.</span></p><p id="f44f810e-1bac-411d-a2aa-02bb47b4b0e8" class="block-color-default"><span style="white-space:pre">3. JavaScript enables developers to construct more adaptable and reusable code by treating functions as _____ order.</span></p><p id="9ea39ce2-94e1-404a-98ef-7fb99d41fd60" class="block-color-default"><span style="white-space:pre">5. This programming paradigm emphasizes using functions as building blocks to develop programs. - _______ programming</span></p><p id="7c605bf9-cb19-4d8d-b953-13b439c1d96c" class="block-color-default"><span style="white-space:pre">6. Functions can be treated like any other value because they are ____-class objects in JavaScript.</span></p><p id="8f29aa57-ed10-487d-8a19-7571edd7d075" class="block-color-default"><span style="white-space:pre">7. Functions are ____-class citizens in functional programming.</span></p><ul id="17504420-ca17-4cb6-949b-8fbc45f90507" class="block-color-default toggle"><li><details close=""><summary><strong><span style="white-space:pre">Solution</span></strong></summary><p id="dfdbc7b9-e16e-4860-8a65-f59668ef7fb1" class="block-color-teal"><strong><span style="white-space:pre">ACROSS :</span></strong></p><ol type="1" id="93d99fcf-a24b-40c5-943d-b18331bb13d6" class="numbered-list" start="4"><li><strong><span style="white-space:pre">Referential</span></strong></li></ol><ol type="1" id="abc004df-0dc9-486b-b45c-10ce61774a1a" class="numbered-list" start="5"><li><strong><span style="white-space:pre">Expression</span></strong></li></ol><p id="a450db16-75c7-4e26-9922-c9b88851a926" class="">
</p><p id="431b6ab3-9f6a-4c19-81a1-831908907b68" class="block-color-pink"><strong><span style="white-space:pre">DOWN : </span></strong></p><ol type="1" id="a23e1e00-ea74-466c-874a-64fa9af0d0ed" class="numbered-list" start="1"><li><strong><span style="white-space:pre">Side</span></strong></li></ol><ol type="1" id="61652f10-6f75-4fac-83cf-1aa3940cb97b" class="numbered-list" start="2"><li><strong><span style="white-space:pre">Pure</span></strong></li></ol><ol type="1" id="4acaca11-0423-48bd-8063-547ae7ba9519" class="numbered-list" start="3"><li><strong><span style="white-space:pre">Higher</span></strong></li></ol><p id="8413a8c1-313a-4849-b500-1ad52e734b1b" class=""><span style="white-space:pre"> 5.  </span><strong><span style="white-space:pre">Functional</span></strong></p><ol type="1" id="1f144797-898e-48b6-80b0-79e2cb572adb" class="numbered-list" start="6"><li><strong><span style="white-space:pre">First</span></strong></li></ol><ol type="1" id="ebe2ff93-631f-48b0-acc5-92372a8afaf6" class="numbered-list" start="7"><li><strong><span style="white-space:pre">First</span></strong></li></ol></details></li></ul><p id="f002f819-411f-44cc-b3f6-519c8293e81d" class="">
</p><h2 id="369dbea1-d726-4be0-8c5a-d065475edaa2" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">Higher Order Function</span></mark></h2><p id="1fef36c1-42dd-4e0c-aae9-e4b55c47bcf5" class=""><span style="white-space:pre">In JavaScript, a higher-order function is characterized by its ability to take one or more functions as arguments and/or return another function as its output. Higher-order functions are crucial to functional programming since they allow for strong abstractions and code composition.</span></p><figure id="5bed03e4-09dd-430e-b5fc-36d57733abc0" class="image"><img style="width:2436px" src="Functional%20Programming%20edc4e3320d6441d1b26b8cc8dc376335/Screenshot_2023-04-27_at_7.50.53_PM.png"/></a></figure><p id="83bc9507-9eee-491c-a720-bc8537be5b9e" class=""><span style="white-space:pre">An illustration of a higher-order function that accepts a function as an argument is shown here:</span></p><pre id="b8f01a89-fbff-4da1-b0a3-b5947e4c7742" class="code"><code>function double(numbers) {
  return numbers.map(function(n) {
    return n * 2;
  });
}</code></pre><p id="755a9673-67f2-410e-b596-a2a62159303b" class=""><span style="white-space:pre">The double function in this code accepts a list of numbers as its argument and outputs a new list with each number twice. Each element in the array is transformed by the higher-order function called map, which accepts a function as an input.</span></p><p id="65ddc85d-f919-4708-858a-d8b238fbb77f" class=""><span style="white-space:pre">An illustration of a higher-order function that does so is as follows:</span></p><pre id="39a93bc2-e3a5-4a99-be60-aaa5a447738f" class="code"><code>function add(x) {
  return function(y) {
    return x + y;
  };
}</code></pre><p id="da76d666-f27f-4db1-ac87-6a4b1df59511" class=""><span style="white-space:pre">The add function in this code accepts a single parameter, x, and produces a new function, which accepts a single input, y, and produces the result of x plus y. This process, known as &quot;currying,&quot; enables the creation of customized functions based on a typical pattern.</span></p><p id="25841228-755c-43f4-b871-cf41305d65e2" class=""><span style="white-space:pre">Higher-order functions can be used to build reusable code that can be modified to have certain behaviour. For instance, a comparison function may be accepted as an argument by a sorting function, enabling sorting in ascending or descending order according to various criteria. Similar to the predicate function, a filtering function may accept a predicate function as an argument to enable filtering based on various criteria.</span></p><h2 id="e4b4084d-aca5-4bad-a361-6101445ce36d" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">Function composition</span></mark></h2><p id="d38d3793-2cfc-4b32-86f1-ffe193f4e1f8" class=""><span style="white-space:pre">Function composition is a method in which the output of one function is passed on to the next, which is passed to another, and so on until the last function is executed to provide the desired outcome. Any number of functions may be included in function compositions.</span></p><figure id="adf6b782-0c1a-4149-88d9-207cc86dd46f" class="image"><img style="width:2450px" src="Functional%20Programming%20edc4e3320d6441d1b26b8cc8dc376335/Screenshot_2023-04-27_at_7.53.00_PM.png"/></a></figure><h3 id="3e362a0a-1262-417e-a262-37e526f7c67b" class=""><span style="white-space:pre">Traditional approach:</span></h3><p id="8aee8a90-541e-41a5-bfe9-dc2135d648c3" class=""><span style="white-space:pre">Traditionally, function composition follows this format:</span></p><pre id="44aacba6-db94-4758-a1aa-bc0681c31a70" class="code"><code>const double = x =&gt; x * 2
const square = x =&gt; x * x
// Tradition approach
var output1 = double(2);
var output2 = square(output1);
console.log(output2);
// variant two
var output_final = square(double(2));
console.log(output_final);</code></pre><p id="fc6ba712-dcf8-45b3-83bb-fa147f5fb000" class=""><span style="white-space:pre">We can see from the code above that in order to square a doubled term, we must first call the double function, then the square function. Either by individually assigning the values to variables and calling functions upon them, or by taking a more direct route.</span></p><h3 id="815f99c9-ada3-4572-842d-7f36d4070966" class=""><span style="white-space:pre">Alternate approach:</span></h3><p id="3764bd7a-36b7-4158-96e4-9c8f52e19e73" class=""><span style="white-space:pre">Another approach is to use the </span><code><span style="white-space:pre">compose</span></code><span style="white-space:pre"> and </span><code><span style="white-space:pre">pipe</span></code><span style="white-space:pre"> functions.</span></p><h3 id="cd9b85cb-d1b3-4f2d-a350-f8acead3211f" class=""><code><span style="white-space:pre">compose</span></code><span style="white-space:pre"> function</span></h3><p id="3d8dab87-02f0-4fd0-9206-4d673d19a084" class=""><code><span style="white-space:pre">compose</span></code><span style="white-space:pre"> function takes any number of functions and invokes them all one after the other:</span></p><pre id="1ed228c8-6ff4-4f54-ba72-ee81ecb579ad" class="code"><code>const compose = (...fns) =&gt; x =&gt; fns.reduceRight((y, f) =&gt; f(y), x); 
const double = x =&gt; x * 2
const square = x =&gt; x * x

// function composition
var output_final = compose(square, double)(2);
console.log(output_final);</code></pre><p id="5c3a3f99-ace7-408b-a8e8-45bce4c4d891" class=""><span style="white-space:pre">The compose function is created using a broad approach in the code above, allowing it to now accept any number of functions. Even when utilising this implementation, the result stays the same.</span></p><h3 id="82094572-3c75-423c-8509-7a6016e536fb" class=""><code><span style="white-space:pre">pipe</span></code><span style="white-space:pre"> function</span></h3><p id="d6942027-a1e3-45af-ae3f-5ec9c27ade3a" class=""><span style="white-space:pre">On the other hand, we can reverse the order of the function invocation by using the </span><code><span style="white-space:pre">pipe</span></code><span style="white-space:pre"> function:</span></p><pre id="2145727d-e480-40b9-934f-94bd06cb98e8" class="code"><code>// function composition using pipe of any number of functions
const pipe = (...fns) =&gt; x =&gt; fns.reduce((y, f) =&gt; f(y), x); 
const double = x =&gt; x * 2
const square = x =&gt; x * x

// function pipe
var output_final = pipe(square, double)(2);
console.log(output_final);</code></pre><p id="33d825eb-84af-49cc-a6c6-b851508fb23e" class=""><span style="white-space:pre">The pipe function is constructed using a general method in the code above, allowing it to now accept any number of functions. This is similar to the previous compose function, except instead of using the reduceRight technique, it uses reduce. The square function is called before the double function in this case, although it was called in the opposite sequence in our compose function, which results in a different output.</span></p><h2 id="56aeafe4-397c-4fef-9b67-5ab8cd62ae85" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">I</span></mark><mark class="highlight-red"><strong><strong><span style="white-space:pre">mmutability in JavaScript</span></strong></strong></mark></h2><p id="540daa04-1f6d-4ae1-91c3-71de715062c2" class=""><span style="white-space:pre">Programmers use the term &quot;immutability&quot; to describe an object&#x27;s unchangeable state after it has been created. Immutability in JavaScript is crucial for creating reliable, predictable, and maintainable programming.</span></p><p id="e813b840-7e1a-4426-8a74-525d6c4c9039" class=""><span style="white-space:pre">Primitive values like texts, integers, and booleans are immutable by default in JavaScript. Once a value is set to them, it cannot be modified. For instance, the code that comes after attempts to modify a string after it has been assigned to a variable:</span></p><pre id="44b70610-a0ed-42f7-a426-b83b0ab24ad4" class="code"><code>let str = &#x27;hello&#x27;;
str[0] = &#x27;H&#x27;; // This has no effect on the string
console.log(str); // Output: &#x27;hello&#x27;</code></pre><p id="f0f8edda-1493-460e-9b3c-7d3280cddd56" class=""><span style="white-space:pre">The str variable in this code remains unchanged, therefore any effort to modify the string&#x27;s first character has no impact.</span></p><p id="7233deeb-17b1-461e-9dea-83bf050d1d58" class=""><span style="white-space:pre">However, JavaScript objects and arrays are by default mutable, allowing their values to be modified after they have been created. As an illustration, the code below creates an object and then changes one of its properties:</span></p><pre id="1760f70f-8b8b-47f5-a67c-2c61a4b7ddb8" class="code"><code>const person = {
  name: &#x27;John&#x27;,
  age: 30
};
person.age = 31; // This changes the value of the age property</code></pre><p id="4553d3a1-6aa5-48cd-bf6d-14d3948f006c" class=""><span style="white-space:pre">The age property of the person object is created in this code with a default value, but that value is later modified.</span></p><p id="9b7c2dc4-9e42-473b-904c-927c33c8b30e" class=""><span style="white-space:pre">An approach that is frequently used in JavaScript to achieve immutability for objects and arrays is to generate new objects or arrays rather than altering the ones that already exist. Instead of changing the original object, the code that follows generates a new object with the updated property:</span></p><pre id="ebaf037d-6ab6-4ec2-95c2-54b79163983f" class="code"><code>const person = {
  name: &#x27;John&#x27;,
  age: 30
};
const updatedPerson = {
  ...person,
  age: 31
};</code></pre><p id="92279511-4df2-458c-96e4-ad8b4a2823f8" class=""><span style="white-space:pre">The age property is set to a new value in this code, yet a new object is created that has all the properties of the person object. The original person object is left alone, and the new object is then assigned to the updatedPerson variable.</span></p><p id="b8e86e37-3334-4567-87c0-e8954c10b4cc" class=""><span style="white-space:pre">This function can also be applied to arrays, but instead of changing the existing arrays, it creates new ones using methods like concat, slice, and map.</span></p><p id="7aa7b8df-a755-447b-8cac-f211fb2a8c12" class=""><span style="white-space:pre">Immutability is a fundamental idea in JavaScript that helps programmers create reliable, maintainable code. Developers can prevent unanticipated side effects and create more logically sound code by treating objects and arrays as immutable data.</span></p><p id="ca8396f8-de0c-4aed-aa9c-1afcc2e39afc" class="">
</p><h2 id="59357b38-e000-417a-a98b-d2ee83098e28" class=""><mark class="highlight-blue"><span style="white-space:pre">Explore Further</span></mark></h2><p id="126e18c5-0b6b-4794-8ab4-26f7467c2c74" class=""><mark class="highlight-orange"><strong><span style="white-space:pre">Uncover and unlock new insights as you dive into the captivating content found in the provided link.</span></strong></mark></p><p id="bcbe915d-9429-4955-b69e-2c5a59423e4e" class=""><strong><strong><span style="white-space:pre">Recursion Function : </span></strong></strong><a href="https://medium.com/sessionstack-blog/how-javascript-works-recursion-in-javascript-what-it-is-and-how-it-is-used-eef3d734f20d"><span style="white-space:pre">https://medium.com/sessionstack-blog/how-javascript-works-recursion-in-javascript-what-it-is-and-how-it-is-used-eef3d734f20d</span></a></p><p id="5711f874-7b34-4293-8352-f7caa97381fe" class=""><mark class="highlight-orange"><strong><span style="white-space:pre">Tackle these questions head-on!</span></strong></mark></p><p id="f6336abd-e8f0-4c89-af08-658cb9ce7707" class=""><span style="white-space:pre">Q1: What is recursion in JavaScript?</span></p><ul id="96db8ae9-64b9-489e-90e1-a6396cafdf2b" class="toggle"><li><details close=""><summary><strong><span style="white-space:pre">Solution</span></strong></summary><p id="357428d1-c134-4163-8d27-a0bf9e952031" class=""><span style="white-space:pre">Recursion is a programming technique where a function calls itself to solve a problem by breaking it down into smaller, simpler instances of the same problem.</span></p></details></li></ul><p id="b75db2fb-5bd4-4169-b1ef-779f91c02f2f" class=""><span style="white-space:pre">Q2: What are the two essential parts of a recursive function?</span></p><ul id="a893c797-a2bc-4687-92dd-3397c80e7974" class="toggle"><li><details close=""><summary><strong><span style="white-space:pre">Solution</span></strong></summary><p id="17c90332-21c3-478a-89c9-5ae9fd55a08c" class=""><span style="white-space:pre">The base case and the recursive case. The base case specifies when the recursion should stop, and the recursive case defines the process of breaking down the problem and making subsequent recursive calls.</span></p></details></li></ul><p id="0442f938-88db-405a-a8b7-1c0ad5c7240f" class=""><span style="white-space:pre">Q3: How is recursion different from iteration?</span></p><ul id="2a99c2e4-8b1a-40ec-a606-e12d40c1bb89" class="toggle"><li><details close=""><summary><strong><span style="white-space:pre">Solution</span></strong></summary><p id="c96084d9-787a-4369-b7cc-8095361116eb" class=""><span style="white-space:pre">Recursion involves solving a problem by breaking it down into smaller instances and calling the function itself, while iteration involves using loops to repeatedly execute a block of code until a certain condition is met.</span></p></details></li></ul><p id="2fd7d2d7-e599-4b89-be3c-9dcdc5e458fe" class=""><span style="white-space:pre">Q4: What is the importance of a base case in a recursive function?</span></p><ul id="8db56e69-7d8a-4042-88aa-22ce57066166" class="toggle"><li><details close=""><summary><strong><span style="white-space:pre">Solution</span></strong></summary><p id="c46cf4d6-0a6e-49bc-8e16-da5d7d4f4530" class=""><span style="white-space:pre">The base case serves as the termination condition for the recursion. It ensures that the function eventually reaches a stopping point and avoids infinite recursion.</span></p></details></li></ul><p id="3d080d61-ef24-45ff-84f4-491f55ac7cbd" class=""><span style="white-space:pre">Q5: What is the call stack in the context of recursion?</span></p><ul id="2a3f8bab-41db-4e85-8cb8-0c9dafdec719" class="toggle"><li><details close=""><summary><strong><span style="white-space:pre">Solution</span></strong></summary><p id="be31bc6c-3acb-4f10-b53c-b80f51b2690f" class=""><span style="white-space:pre">The call stack is a data structure used to manage function calls. In recursion, each recursive function call is added to the call stack, and when the base case is reached, the function calls are resolved and removed from the stack.</span></p></details></li></ul><p id="3f55f1e5-6d73-4afa-a3ec-f391b1c2f65d" class="">
</p><h2 id="65379ab0-3783-4b43-a1ed-568be869ee8b" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">Declarative and Imperative code</span></mark></h2><p id="f7a935d4-8239-43fe-ae63-2c1d03237457" class=""><strong><span style="white-space:pre">Functional programming</span></strong><span style="white-space:pre"> can make use of the </span><strong><span style="white-space:pre">declarative and imperative programming paradigms. </span></strong><span style="white-space:pre">An explanation of each is provided below:</span></p><p id="1ee82d06-8f8c-4eed-a46d-328b97c1a253" class=""><strong><span style="white-space:pre">Declarative programming</span></strong><span style="white-space:pre"> is a paradigm for writing computer program in which the desired outcome is described in the code without the control structure or algorithm used to get there being stated explicitly. To put it another way, you tell the computer what you want, and it finds a way to make it happen. Declarative code is frequently more terse and expressive, as well as being potentially simpler to comprehend and maintain.</span></p><p id="c3c7b51b-b3a4-4b49-95d8-4f8384e670e6" class=""><span style="white-space:pre">Declarative code in functional programming sometimes involves manipulating data without the need of explicit loops or conditionals by employing higher-order functions like map, reduce, and filter. Here is an illustration of a declarative function that doubles the values of an array using map:</span></p><pre id="98f99b4b-e7c8-494a-a382-2a9887e393cd" class="code"><code>function double(numbers) {
  return numbers.map(n =&gt; n * 2);
}</code></pre><p id="0cb70331-1f45-4b55-bb00-d0c73a4c6c03" class=""><span style="white-space:pre">Without utilizing a loop or a conditional statement, the map function is used in this code to change each element of the numbers array into a new value.</span></p><p id="5b26b6d8-6b4a-4447-8c9d-6034b7fbc672" class="">
</p><p id="585cd7a3-2c49-4d4f-8eaa-1d1c7f01467d" class=""><span style="white-space:pre">Contrarily, in an </span><strong><span style="white-space:pre">imperative programming paradigm</span></strong><span style="white-space:pre">, loops, conditionals, and mutable state are frequently used in the code to specify the precise procedures to achieve a goal. In other words, you instruct the computer step-by-step on how to carry out a task. Imperative code can frequently be more verbose, less expressive, harder to understand, and require more upkeep.</span></p><p id="33750f50-e8b5-454f-9258-1ddad09077ee" class=""><span style="white-space:pre">Imperative code in functional programming frequently uses mutable variables or phrases like for and while loops. An imperative function that doubles the values in an array is shown here as an example:</span></p><pre id="11c5044d-7336-4bfe-9aaa-bfaabc7fb0a3" class="code"><code>function double(numbers) {
  const result = [];
  for (let i = 0; i &lt; numbers.length; i++) {
    result.push(numbers[i] * 2);
  }
  return result;
}</code></pre><p id="a271f764-55c6-4ba8-8785-739b227190e8" class=""><span style="white-space:pre">In this code, a new array result is formed, and a for loop is used to put a new value onto the result array while iterating over each element of the numbers array.</span></p><p id="27a3963e-e88a-4d68-b5c3-7db460d35125" class=""><span style="white-space:pre">Ultimately, both declarative and imperative programming have advantages and disadvantages and are useful in various contexts. Declarative code is frequently preferred in functional programming because it can result in more expressive and maintainable code. Imperative code may, nevertheless, be more appropriate in some circumstances, such as when working with performance-sensitive code or with changeable data structures.</span></p><h2 id="fa127376-f8f6-40c3-b377-ef37e773ae7a" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">Benefits of Functional Programming</span></mark></h2><p id="cb96b693-718f-409b-821b-3d0b39ff0d43" class=""><span style="white-space:pre">Pure functions, immutable data structures, and declarative programming are all emphasized in the functional programming paradigm. The following are a few advantages of functional programming:</span></p><ol type="1" id="e1a6f1d3-8287-46a1-9429-19bcbd9a17a5" class="numbered-list" start="1"><li><strong><span style="white-space:pre">Less side effects:</span></strong><span style="white-space:pre"> Functions simply operate on their inputs and do not affect external state in functional programming, which minimizes side effects. This lowers the likelihood of bugs and makes it simpler to reason about the code.</span></li></ol><ol type="1" id="043473b1-9651-40cd-b8ce-082ea337e17b" class="numbered-list" start="2"><li><strong><span style="white-space:pre">Modularity:</span></strong><span style="white-space:pre"> Functional programming promotes the use of compact, small-scale functions that can be quickly joined to produce more intricate functionality. Because of this, writing reusable and maintainable code is made simpler.</span></li></ol><ol type="1" id="338d35ff-adf4-4b1f-8c9c-034d0bbc93e5" class="numbered-list" start="3"><li><strong><span style="white-space:pre">Expressiveness:</span></strong><span style="white-space:pre"> Declarative programming is emphasized in functional programming, which makes the code simpler to read and comprehend. Complex logic can be written concisely and accessible by using higher-order functions and other functional programming ideas.</span></li></ol><ol type="1" id="b6369061-5c62-4bb0-bc1e-6c88e798b966" class="numbered-list" start="4"><li><strong><span style="white-space:pre">Testing:</span></strong><span style="white-space:pre"> Pure functions, which depend solely on their inputs and have no side effects, are encouraged by functional programming because they are simpler to test. As a result, it is simpler to check code accuracy and construct unit tests.</span></li></ol><ol type="1" id="974e5fb9-effb-43df-bacc-e5e603319734" class="numbered-list" start="5"><li><strong><span style="white-space:pre">Scalability:</span></strong><span style="white-space:pre"> Because functional programming prioritizes the usage of stateless functions and immutable data structures, it can grow effectively. Deadlocks and race situations, which are frequent issues in distributed systems, can be avoided in this way.</span></li></ol><p id="90006fb3-9c71-458d-ab29-f18b398f6dbc" class="">
</p><p id="c020bf8d-73b1-4062-b554-0f9523d15245" class=""><span style="white-space:pre">Generally, functional programming offers a number of advantages that can make it simpler to create reliable, upgradable software. In contrast to traditional imperative programming, it also necessitates a different approach to thinking about programming, so there can be a learning curve for those who are unfamiliar with the paradigm.</span></p><p id="946efe43-6637-4ba7-9e65-08247c794522" class="">
</p><h2 id="8783031a-b839-4006-a736-e0c95f58712d" class="block-color-default"><mark class="highlight-blue"><span style="white-space:pre">Activity</span></mark></h2><p id="a232adfc-20b2-456f-a823-7b6a082bf256" class=""><strong><span style="white-space:pre">Fill in the blanks:</span></strong></p><ol type="1" id="a20e4462-7436-4d5d-9be5-6000a1fb9d23" class="numbered-list" start="1"><li><span style="white-space:pre">Functional programming can make use of __________ and imperative programming paradigms.</span></li></ol><ol type="1" id="e7d675c6-64c4-4c49-99d2-411ca9ef5b02" class="numbered-list" start="2"><li><span style="white-space:pre">In declarative programming, you tell the computer what you want, and it finds a way to make it happen without the control structure or algorithm used to get there being stated __________.</span></li></ol><ol type="1" id="4c9cfffb-8546-49b6-b5cc-a313d375d850" class="numbered-list" start="3"><li><span style="white-space:pre">Declarative code in functional programming sometimes involves manipulating data without the need of explicit loops or conditionals by employing higher-order functions like __________, reduce, and filter.</span></li></ol><ol type="1" id="0ee0470e-b438-447e-9e1b-90bd1a4ec36e" class="numbered-list" start="4"><li><span style="white-space:pre">__________ programming is emphasized in functional programming, which makes the code simpler to read and comprehend.</span></li></ol><ul id="fd59ce9c-20d2-4c5e-a43e-f9e69950369e" class="block-color-default toggle"><li><details close=""><summary><strong><span style="white-space:pre">Solution</span></strong></summary><ol type="1" id="0ee8deba-7c16-47dc-97c6-36c2853e0e31" class="numbered-list" start="1"><li><span style="white-space:pre">declarative</span></li></ol><ol type="1" id="1365a405-fe33-4d5d-b03a-e4d7b8eb9bae" class="numbered-list" start="2"><li><span style="white-space:pre">explicitly</span></li></ol><ol type="1" id="f3829155-e615-4b11-b3f7-0b01d63542da" class="numbered-list" start="3"><li><span style="white-space:pre">map</span></li></ol><ol type="1" id="0d001f9b-23a0-4829-809e-844515dcb699" class="numbered-list" start="4"><li><span style="white-space:pre">Modularity</span></li></ol></details></li></ul><p id="df6b21bb-1af6-44ca-9d1e-a468a5febaf7" class="">
</p><blockquote id="29663d6a-98e9-40ee-9722-48f63024b14b" class="block-color-default"><span style="white-space:pre">John McCarthy developed the Lisp programming language in the late 1950s, which was one of the first programming languages to incorporate functional programming concepts.</span></blockquote><p id="d6eccb37-596b-4978-bf6e-ec6ff4de1344" class="">
</p><h1 id="294e35b9-b803-44ba-ba7b-ea0d7a5e3361" class="block-color-default"><mark class="highlight-brown"><span style="white-space:pre">Summary</span></mark></h1><h2 id="28d00606-3b3d-479f-b477-2c607aa2ebf0" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">What did we learn?</span></mark></h2><ul id="42169c65-0b95-4988-a5cd-6ee64d3006d1" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Functional programming emphasizes writing pure and compound functions and avoiding mutable data, shared state, and side effects.</span></li></ul><ul id="d77f4006-083b-4bc6-9ba7-c36457232871" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Pure functions are predictable, reusable, and easier to test and debug.</span></li></ul><ul id="5d55b525-8594-4ac1-8918-d7200effe8da" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Functions in JavaScript are first-class objects, which means they can be treated as variables and stored, passed, and returned like any other object.</span></li></ul><ul id="58638c11-2195-451e-a7d2-7e1f58ca4133" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Higher-order functions take or return functions as arguments, and function composition is the process of chaining functions together to produce a final result.</span></li></ul><ul id="b237d404-5759-4ed1-88f0-e717c596a2a9" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">The </span><code><span style="white-space:pre">const</span></code><span style="white-space:pre"> keyword declares a constant value that cannot be reassigned, but the contents of a </span><code><span style="white-space:pre">const</span></code><span style="white-space:pre"> variable can still be modified unless you use </span><code><span style="white-space:pre">Object.freeze()</span></code><span style="white-space:pre"> or a library like </span><code><span style="white-space:pre">Immutable.js</span></code><span style="white-space:pre">.</span></li></ul><ul id="a8638283-60f0-43a2-a0c3-ec69ad038895" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">The spread syntax can also be used to create a new copy of an object or array and maintain immutability.</span></li></ul><ul id="cd7e4aa8-e161-4624-80b7-f26f9349ecdd" class="bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Functional programming is a declarative programming paradigm that focuses on what the program does, while imperative programming focuses on how it does it. Declarative programming is a layer of abstraction on top of imperative programming, which ultimately compiles instructions for the CPU.</span></li></ul><h2 id="947b287c-0a4e-49a5-9709-fcdc9c6fdc93" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">Shortcomings</span></mark></h2><ul id="51eb3403-6d68-4fda-bf6e-2065c061237d" class="block-color-default bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Difficulty in understanding concepts like currying, higher-order functions, and function composition, which are key concepts in functional programming.</span></li></ul><ul id="ec4892f8-8819-425a-9d48-96d66e86cc84" class="block-color-default bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">A lack of familiarity with the functional programming libraries and tools available in JavaScript, which can make it difficult to apply functional programming concepts in real-world projects.</span></li></ul><ul id="166496d6-e939-4615-8484-041d84561e47" class="block-color-default bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">Difficulty in transitioning from imperative programming to declarative programming, as it requires a different way of thinking about program design.</span></li></ul><ul id="3550b11f-19f6-494f-988d-830f50fabf90" class="block-color-default bulleted-list"><li style="list-style-type:disc"><span style="white-space:pre">A lack of support for some of the functional programming features in older versions of JavaScript, which can limit the language&#x27;s capabilities.</span></li></ul><h2 id="a4427430-0325-4cf7-891a-7645dbd11d4b" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">Best Practices</span></mark></h2><ul id="0364ae4e-e18d-49fe-9686-065901a0ffa6" class="block-color-default bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Start with the basics:</span></strong><span style="white-space:pre"> Begin by learning the fundamentals of functional programming, such as pure functions, immutability, and higher-order functions.</span></li></ul><ul id="41bf013a-9cb5-49e9-bf64-e84ad82021e1" class="block-color-default bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Practice writing functions:</span></strong><span style="white-space:pre"> Get plenty of practice writing functions and applying functional programming concepts to simple problems.</span></li></ul><ul id="dd1be694-5566-44c9-9b8d-0cecdaa4a1b6" class="block-color-default bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Read functional programming code:</span></strong><span style="white-space:pre"> Read through code written by experienced functional programmers to gain an understanding of how to apply functional programming concepts to real-world problems.</span></li></ul><ul id="4b631c87-4294-4b32-bced-3957da072d3a" class="block-color-default bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Use functional programming libraries: </span></strong><span style="white-space:pre">Utilize functional programming libraries and tools like Ramda, Lodash, or Immutable.js to gain experience with functional programming patterns and techniques.</span></li></ul><ul id="f47fee28-d444-4e4d-b8d2-3c019ff66ae4" class="block-color-default bulleted-list"><li style="list-style-type:disc"><strong><span style="white-space:pre">Refactor existing code: </span></strong><span style="white-space:pre">Practice refactoring existing code to make it more functional. This can help you gain experience with functional programming concepts while also improving the code&#x27;s maintainability and readability.</span></li></ul><h2 id="3158853e-9f9b-4d19-9572-303c27fef7c9" class="block-color-default"><mark class="highlight-red"><span style="white-space:pre">Enhance Your Knowledge</span></mark></h2><ul id="d8495575-36c1-45e0-bf7d-829a97f52e5c" class="block-color-default bulleted-list"><li style="list-style-type:disc"><a href="https://www.freecodecamp.org/news/functional-programming-in-javascript/"><span style="white-space:pre">What is Functional Programming?</span></a></li></ul><ul id="c32c34c6-4525-4cb7-8af0-3d9a7c666cc3" class="bulleted-list"><li style="list-style-type:disc"><a href="https://opensource.com/article/17/6/functional-javascript"><span style="white-space:pre">Functional programming in JavaScript</span></a></li></ul></div></article></body></html>