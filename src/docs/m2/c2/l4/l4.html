<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Advanced Searching Algorithms </title><link rel="stylesheet" href="../../../../../styles.css"></head><body><article id="907271bb-7c83-4a39-9dd9-0c719b2c1f10" class="page sans"><header><h1 class="page-title">Advanced Searching Algorithms </h1><p class="page-description"></p></header><div class="page-body"><ul id="85982b3e-8f7a-4fe0-bfe7-4593cd631dd3" class="toggle"><li><details class=""><summary><strong>Session Flow (5 minutes read)</strong></summary><ul id="b6a238e8-72a8-4905-a0f0-5008c6aea815" class="bulleted-list"><li style="list-style-type:disc"><strong>Learning Objective (5 minutes read)</strong><ul id="cde9168b-0238-445f-9d67-e489315301b6" class="bulleted-list"><li style="list-style-type:circle">Introduction</li></ul><ul id="59df50b0-a910-42f0-a777-003fdd6bb3d5" class="bulleted-list"><li style="list-style-type:circle">Theme</li></ul><ul id="771a0be4-2964-4b13-a97f-8e15755c5870" class="bulleted-list"><li style="list-style-type:circle">Primary Goals</li></ul></li></ul><ul id="81a2d475-2e76-4924-9e4a-af4eb22f4875" class="bulleted-list"><li style="list-style-type:disc"><strong>Advanced Searching Algorithms (120 minutes read)</strong><ul id="7d61195e-b229-4411-aed5-582cbfcc68a6" class="bulleted-list"><li style="list-style-type:circle">Introduction to Ternary Search<ul id="9dc8c3ca-7e89-4599-92c7-197930a63c68" class="bulleted-list"><li style="list-style-type:square">Working of Ternary Search</li></ul><ul id="9574ad27-df81-45ad-84df-0bb296ef9330" class="bulleted-list"><li style="list-style-type:square">Implementation of Ternary Search</li></ul><ul id="a4812964-627a-416d-b1c8-e99b2c4af94d" class="bulleted-list"><li style="list-style-type:square">Time complexity of Ternary Search</li></ul><ul id="54029f0b-2703-4bd4-87d7-bd5671bffd06" class="bulleted-list"><li style="list-style-type:square">Space Complexity of Ternary Search</li></ul></li></ul><ul id="0c713f88-d4b9-4fe6-b98e-5fb07dfabd57" class="bulleted-list"><li style="list-style-type:circle"><strong>Do it yourself</strong></li></ul><ul id="c25438f7-c82a-43d0-895f-62067b5a79fb" class="bulleted-list"><li style="list-style-type:circle">Introduction to Jump Search<ul id="701a14ca-ead0-4dea-91c6-6d85ff330058" class="bulleted-list"><li style="list-style-type:square">Working of Jump Search</li></ul><ul id="330b127d-f13f-4fbe-bd9f-558545e77615" class="bulleted-list"><li style="list-style-type:square">Implementation of Jump Search</li></ul><ul id="7ab81eaf-3971-4992-aec0-4cc6ba4b01a9" class="bulleted-list"><li style="list-style-type:square">Time complexity of Jump Search</li></ul><ul id="b8e65154-37bc-47e3-9d98-15d88f47c68d" class="bulleted-list"><li style="list-style-type:square">Space Complexity of Jump Search</li></ul></li></ul><ul id="98f98b54-9e0d-4f14-81c3-9d7988df18d7" class="bulleted-list"><li style="list-style-type:circle"><strong>Activity 1</strong></li></ul><ul id="cfc31895-e8fe-4634-8268-9aa867cd7e4d" class="bulleted-list"><li style="list-style-type:circle">Introduction to Exponential Search<ul id="896002e6-bc66-40b3-9c79-c7b4be7e1c62" class="bulleted-list"><li style="list-style-type:square">Working of Exponential Search</li></ul><ul id="21604b8e-15bc-4966-8768-8c7dd8e1291d" class="bulleted-list"><li style="list-style-type:square">Implementation of Exponential Search</li></ul><ul id="b7710ff5-5557-4d2f-bec9-181c6b1c6948" class="bulleted-list"><li style="list-style-type:square">Time complexity of Exponential Search</li></ul><ul id="ed080263-4aeb-44b7-9ec7-961441cfd279" class="bulleted-list"><li style="list-style-type:square">Space Complexity of Exponential Search</li></ul></li></ul><ul id="e9aac451-e0b6-4169-be51-00b17d2312a0" class="bulleted-list"><li style="list-style-type:circle"><strong>Explore Further</strong></li></ul></li></ul><ul id="a04879d6-be59-4dca-a96c-422c776b7afe" class="bulleted-list"><li style="list-style-type:disc"><strong>Summary (10 minutes read)</strong><ul id="09e09dad-325e-4261-a296-c417310f5df5" class="bulleted-list"><li style="list-style-type:circle">What did we learn?</li></ul><ul id="16261c0e-71cc-4a14-bd6c-d3a205571e89" class="bulleted-list"><li style="list-style-type:circle">Shortcomings &amp; Challenges</li></ul><ul id="3525d7f6-c292-47a9-8f70-2151d0c11105" class="bulleted-list"><li style="list-style-type:circle">Best Practices</li></ul><ul id="b0609b2c-5ec0-4516-8d3d-14551524c11c" class="bulleted-list"><li style="list-style-type:circle">Enhance Your Knowledge</li></ul></li></ul></details></li></ul><p id="b7101ce6-31a1-4b3e-9b45-e5d43e5241f7" class="">
</p><h1 id="cb861e80-c8c5-4662-a19a-11b6ad187d8b" class=""><mark class="highlight-brown">Learning Objective</mark></h1><h2 id="41952443-a443-41df-8e36-5a8ecde34ae6" class="block-color-default"><mark class="highlight-red">Introduction</mark></h2><p id="e4bca59f-3a58-4e87-85b6-5d595723f8a4" class="">In this introduction, we&#x27;ll be diving deeper into time and space complexity analysis specifically as it relates to searching algorithms. We&#x27;ll explore different algorithms such as linear search, binary search, and hash tables, and analyze how they perform under different scenarios. By the end of this topic, you&#x27;ll have a solid understanding of these concepts and be well on your way to becoming a proficient algorithm analyst!</p><p id="0484db66-edd8-4e92-8eb0-bec754ffcc79" class=""><strong>Duration: </strong>2 Hours</p><p id="e378ebbf-0368-45ea-a998-1dde5b60a8da" class=""><strong>Focus:</strong> Introduction, Working, Implementation, and Analysis of Ternary Search, Jump Search, and Exponential Search</p><p id="c1724824-b0b4-48b6-9be4-1d0ec50bee45" class=""><strong>Pre-requisite:</strong> JavaScript Basics, Sorting Algorithms, Basic Searching Algorithms</p><h2 id="40ede7f2-6cef-497b-af00-d5fc37d7500c" class="block-color-default"><mark class="highlight-red">Theme</mark></h2><p id="97187fb4-1e05-4e47-b3b8-9d308f110729" class=""><strong>Ternary Search</strong> is like searching for a book in a massive library. Imagine you&#x27;re looking for a specific book, and the librarian tells you if it&#x27;s in the left, middle, or right section. With each step, you narrow down your search, quickly honing in on your desired book. <strong>Jump Search</strong> comes in handy when you need to find a specific item in a sorted list. Imagine you&#x27;re looking for the Ace of Spades in a deck of cards. Instead of checking each card individually, you can jump ahead a fixed number of cards, greatly reducing your search time. <strong>Exponential Search</strong> is akin to finding your way through a complex maze. Instead of aimlessly wandering, you explore larger areas, doubling the search space until you&#x27;re closer to your destination. Then, you switch to a more precise search method to reach your goal efficiently.</p><p id="16b72046-b478-4c9f-bf92-dd4bd92b87e1" class="">These searching algorithms offer practical solutions in various scenarios, whether it&#x27;s searching for a book, locating an item in a sorted list, or navigating through intricate data structures.</p><h2 id="6deb4a4c-0001-442e-b3e7-6baa142a8cf4" class="block-color-default"><mark class="highlight-red">Primary Goals</mark></h2><ul id="ac84ce0b-3e22-4f63-bd49-19d9342c686c" class="bulleted-list"><li style="list-style-type:disc">Understand the concept of dividing the search space into three parts and narrowing down the search range.</li></ul><ul id="259ec625-deaf-4e44-9249-2c9bc1c623c5" class="bulleted-list"><li style="list-style-type:disc">Comprehend the idea of making jumps in a sorted list to quickly approach the target element.</li></ul><ul id="46e405e6-2388-4b56-aeaa-26d0c13ade0c" class="bulleted-list"><li style="list-style-type:disc">Grasp the concept of exponentially increasing the search range to approach the target element.</li></ul><ul id="ba4e89bd-1936-4d1a-91f6-c51040b0236f" class="bulleted-list"><li style="list-style-type:disc">Analyze the time and space complexity of Ternary Search, Jump Search, and Exponential Search to understand its efficiency.</li></ul><p id="c124cc03-e9ac-4824-921e-13041533a7d1" class="">
</p><h1 id="5eeb5ce9-8092-4256-956b-13dbd04c0860" class=""><mark class="highlight-brown">Advanced Searching Algorithms</mark></h1><h2 id="fe85741a-787f-4a98-a5d1-fd12499b056b" class=""><mark class="highlight-red">Introduction to Ternary Search</mark></h2><p id="935224fc-baad-4f63-90b1-edb2766bf372" class="">Ternary search is a divide-and-conquer algorithm used to find an element in a sorted array. It is an improvement over binary search as it divides the array into three parts instead of two, reducing the number of comparisons required.</p><h3 id="ba48355a-76f8-4f00-a97a-0920a39c4dd5" class=""><strong>Working of Ternary Search</strong></h3><ol type="1" id="0aef912b-745a-4209-b716-baadf945060b" class="numbered-list" start="1"><li><strong>Define the Search Space</strong>: Ternary search starts with a sorted array and defines the search space by setting the left and right pointers initially to the first and last indices of the array, respectively.</li></ol><ol type="1" id="57ae81bc-a68f-45e6-90a2-49c3404ebf2d" class="numbered-list" start="2"><li><strong>Divide the Search Space</strong>: Divide the search space into three equal parts by setting two mid-point pointers: <code>mid1 = left + (right - left) / 3</code> and <code>mid2 = right - (right - left) / 3</code>.</li></ol><ol type="1" id="2bfc4091-0acc-47e7-a767-c2b564b75794" class="numbered-list" start="3"><li><strong>Compare with the Target</strong>: Compare the target value with the elements at <code>mid1</code> and <code>mid2</code>. There are three possible outcomes:<ul id="1d7f6e1b-a61b-421e-82b7-dc8d923a4500" class="bulleted-list"><li style="list-style-type:disc">If the target matches the element at <code>mid1</code>, the search is successful, and the index of <code>mid1</code> is returned.</li></ul><ul id="12f41ebb-343c-4fd9-93b4-9f3a25a4ed5e" class="bulleted-list"><li style="list-style-type:disc">If the target matches the element at <code>mid2</code>, the search is successful, and the index of <code>mid2</code> is returned.</li></ul><ul id="cf2eb0d4-3ae5-4f95-91fa-82259ac9a487" class="bulleted-list"><li style="list-style-type:disc">If the target is smaller than the element at <code>mid1</code>, update the right pointer to <code>mid1 - 1</code> and repeat the process.</li></ul><ul id="724af0c6-4a88-4397-b336-e332c1b52d12" class="bulleted-list"><li style="list-style-type:disc">If the target is larger than the element at <code>mid2</code>, update the left pointer to <code>mid2 + 1</code> and repeat the process.</li></ul><ul id="bb377447-8769-466a-9e7b-84e49aa69b5a" class="bulleted-list"><li style="list-style-type:disc">If the target is between the elements at <code>mid1</code> and <code>mid2</code>, the search space is further divided, and the process is repeated recursively on the appropriate subarray.</li></ul></li></ol><ol type="1" id="aef3e73f-c255-4a7a-a432-31fdd3e26ed8" class="numbered-list" start="4"><li><strong>Repeat the Process</strong>: Steps 2 and 3 are repeated until either a match is found or the search space becomes empty.</li></ol><ol type="1" id="b41e5ba7-18a5-4676-878d-6338376ad4cc" class="numbered-list" start="5"><li><strong>End of Search</strong>: If the search space becomes empty without finding a match, ternary search concludes that the target value is not present in the array and returns a special value (e.g., -1) to indicate the absence of the target.</li></ol><h3 id="12fc8c5d-e153-4d60-bae0-c02275267a12" class="">Implementation of Ternary Search</h3><p id="f15bcdbe-31d6-4dfa-8168-bb12a0978116" class="">Here&#x27;s a simple implementation of the Ternary Search algorithm in JavaScript:</p><pre id="7c1490f5-5654-4a3c-987d-a1cb0cb91f9b" class="code code-wrap"><code>function ternarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left &lt;= right) {
    let mid1 = left + Math.floor((right - left) / 3);
    let mid2 = right - Math.floor((right - left) / 3);

    if (arr[mid1] === target) {
      return mid1;
    }

    if (arr[mid2] === target) {
      return mid2;
    }

    if (target &lt; arr[mid1]) {
      right = mid1 - 1;
    } else if (target &gt; arr[mid2]) {
      left = mid2 + 1;
    } else {
      left = mid1 + 1;
      right = mid2 - 1;
    }
  }

  return -1; // Target not found
}

// Example usage
var arr = [1, 2, 3, 4, 5, 6, 7];
var target = 5;
console.log(ternarySearch(arr, target)); // Output: 4 (index of the target element)</code></pre><ul id="3f61ccac-93ee-4527-b434-8a734733355d" class="toggle"><li><details class=""><summary><strong>Explanation</strong></summary><ol type="1" id="4ec7c5ee-bffd-4779-b200-0a6e7aee7bbf" class="numbered-list" start="1"><li>The <code>left</code> and <code>right</code> pointers are initialized to the first and last indices of the array, respectively.</li></ol><ol type="1" id="6023ca59-d581-4ffc-8ffc-23a8a20e638f" class="numbered-list" start="2"><li>The while loop continues as long as the <code>left</code> pointer is less than or equal to the <code>right</code> pointer. This ensures that the search space is not empty.</li></ol><ol type="1" id="d3b82a38-f9c0-41ae-8b48-891da82bc852" class="numbered-list" start="3"><li>Inside the loop, two mid-point pointers, <code>mid1</code> and <code>mid2</code>, are calculated to divide the search space into three equal parts.</li></ol><ol type="1" id="447e2693-8a31-4a18-b7a0-4c18f7e3ddae" class="numbered-list" start="4"><li>If the target value is found at <code>mid1</code> or <code>mid2</code>, the function returns the corresponding index.</li></ol><ol type="1" id="0998d7c0-d1e5-41c8-afc5-f3e44192faa6" class="numbered-list" start="5"><li>If the target is smaller than the element at <code>mid1</code>, the right pointer is updated to <code>mid1 - 1</code> to search in the left subarray.</li></ol><ol type="1" id="801de13b-02a3-47ae-bf85-ed4b9a7700c4" class="numbered-list" start="6"><li>If the target is larger than the element at <code>mid2</code>, the left pointer is updated to <code>mid2 + 1</code> to search in the right subarray.</li></ol><ol type="1" id="f5dabc0e-e812-49cd-be25-86a546a1341c" class="numbered-list" start="7"><li>If the target is between the elements at <code>mid1</code> and <code>mid2</code>, the search space is divided further by updating the left pointer to <code>mid1 + 1</code> and the right pointer to <code>mid2 - 1</code>.</li></ol><ol type="1" id="4db104cf-1613-400c-b02a-c20809296f24" class="numbered-list" start="8"><li>The loop continues until a match is found or the search space becomes empty.</li></ol><ol type="1" id="0c74a083-0d33-4cf5-95af-5991e808bfb9" class="numbered-list" start="9"><li>If the search space becomes empty without finding a match, the function returns -1 to indicate that the target value is not present in the array.</li></ol></details></li></ul><h3 id="982049b7-39d2-4f83-b0ac-1c9105b7d1f1" class="">Time Complexity of Ternary Search</h3><ul id="4bc2c3bd-4b8a-409e-adc0-2f53e6153cf3" class="bulleted-list"><li style="list-style-type:disc"><strong>Worst-case time complexity:</strong> <code>O(log3(n))</code><p id="f6da61f5-3d9d-4ddb-8e0d-d79842906db1" class="">The worst-case time complexity of ternary search is logarithmic with base 3. This is because the search space is divided into three equal parts in each iteration, reducing the search space by a factor of 3 at every step. Therefore, the number of comparisons required to find the target element grows logarithmically with the size of the input array.</p></li></ul><ul id="e1b27de1-c365-4cd5-83bb-df68088bd95b" class="bulleted-list"><li style="list-style-type:disc"><strong>Average-case time complexity:</strong> <code>O(log3(n))</code><p id="7fb79a3b-8a42-4bda-b643-1c9eb53e5f14" class="">The average-case time complexity of ternary search is also logarithmic with base 3. It performs a similar number of comparisons as the worst-case scenario on average.</p></li></ul><ul id="a495c6a3-2452-4712-81f2-ec37c143353b" class="bulleted-list"><li style="list-style-type:disc"><strong>Best-case time complexity:</strong> <code>O(1)</code><p id="2a539176-3dc4-4a33-bf7b-9bc484232356" class="">The best-case time complexity of ternary search occurs when the target element is found at the first attempt, resulting in a constant time complexity.</p></li></ul><h3 id="9b3253e5-c417-43fd-b077-13621ec8ce39" class="">Space Complexity of Ternary Search</h3><ul id="b3d95d12-04af-4833-992d-a00b1a1d987e" class="bulleted-list"><li style="list-style-type:disc"><strong>Space complexity of Ternary Search:</strong> <code>O(1)</code><p id="71677115-a0eb-4b0d-806c-a8a91665c6cb" class="">Ternary search is an in-place algorithm that uses a constant amount of extra space. It does not require additional data structures or recursion, resulting in a space complexity of O(1).</p></li></ul><p id="76d23519-356d-4fba-bed9-81220f594d3f" class="">
</p><h2 id="5f468388-8f67-425a-ba97-ae0712adc77d" class=""><mark class="highlight-blue">Do it Yourself</mark></h2><p id="987a44b8-8616-4f43-b49f-a7890fa61032" class=""><strong>Agree or Disagree:</strong></p><ol type="1" id="765a98b4-f9de-477a-a1a9-5bdd769852cd" class="numbered-list" start="1"><li>Ternary search is more efficient than binary search. </li></ol><ol type="1" id="1bfc488b-8063-4866-a795-f6598316d5ac" class="numbered-list" start="2"><li>Ternary search&#x27;s space complexity of O(n) makes it a memory-efficient algorithm for searching in large arrays.</li></ol><ol type="1" id="19e09aab-c411-464e-b9bd-83c2306d2861" class="numbered-list" start="3"><li>Ternary search can be modified to handle non-sorted arrays by applying a sorting algorithm before performing the search. </li></ol><ol type="1" id="3a33001d-b8de-408b-ab6b-a5f6f6814e38" class="numbered-list" start="4"><li>Ternary search is not suitable for dynamically changing arrays where elements are frequently inserted or removed, as it requires a sorted array for efficient searching. </li></ol><ol type="1" id="d8c0d0fa-15fd-40c2-8470-c71305f47588" class="numbered-list" start="5"><li>Ternary search requires a sorted array as input, which limits its applicability compared to other search algorithms. </li></ol><ul id="7a4b2aca-cce2-4179-ae52-a18229fc2d79" class="toggle"><li><details class=""><summary><strong>Answers</strong></summary><ol type="1" id="f1a419c6-2743-48a2-b97f-e06b0523319a" class="numbered-list" start="1"><li>Disagree</li></ol><ol type="1" id="f2e9a41b-14de-429b-a31a-113571c6687d" class="numbered-list" start="2"><li>Disagree</li></ol><ol type="1" id="57f6e5d6-98fa-496f-bea9-d80ae5dae086" class="numbered-list" start="3"><li>Agree</li></ol><ol type="1" id="9e0665c3-e170-4e68-ae23-860337163c88" class="numbered-list" start="4"><li>Agree</li></ol><ol type="1" id="758ea86c-19f2-4fc9-b39f-7276ef6dbd1c" class="numbered-list" start="5"><li>Agree</li></ol></details></li></ul><p id="625ddb78-b338-449d-b47a-0a67c5336b4d" class="">
</p><h2 id="3c4c9e15-c563-48d6-a952-ce75f7fb55ff" class=""><mark class="highlight-red">Introduction to Jump Search</mark></h2><p id="8041d7c5-41aa-409e-83f2-dbc9c1cd4190" class="">Jump search is a searching algorithm used to find the position of a target value in a sorted array. It works by jumping ahead a fixed number of steps and then linearly searching within the block until the target value is found or exceeded.</p><h3 id="b69edf67-2bf4-48f7-819f-aa223cb548c9" class=""><strong>Working of Jump Search</strong></h3><ol type="1" id="9b3092f5-f6aa-40be-b25d-ef74a1bdcac3" class="numbered-list" start="1"><li><strong>Define the Block Size</strong>: Jump search begins by determining the block size to jump ahead. It is typically calculated as the square root of the length of the array, denoted as <code>step = √n</code>, where <code>n</code> is the length of the array.</li></ol><ol type="1" id="1a0b40e5-0094-42ad-b62d-cad1c45fa37c" class="numbered-list" start="2"><li><strong>Jump Ahead</strong>: Starting from the beginning of the array, jump ahead by <code>step</code> indices at a time until you find an element greater than or equal to the target value, or you reach the end of the array.</li></ol><ol type="1" id="12437d33-193f-4156-838b-d7b5375bb10c" class="numbered-list" start="3"><li><strong>Linear Search Within the Block</strong>: Once the block with the target value is identified (either by finding the target value or exceeding it), perform a linear search within the block from the previous step to locate the exact position of the target value.</li></ol><ol type="1" id="73a44c0e-8bb9-47ab-a4f6-d6f89f49cc94" class="numbered-list" start="4"><li><strong>Repeat or Conclude</strong>: If the target value is found, return its index. If the target value is not found and the end of the array is not reached, repeat the process by jumping to the next block and performing another linear search. Continue until the target value is found or the end of the array is reached.</li></ol><h3 id="aedf309f-9e51-4fd1-8032-2f3af4f09f87" class="">Implementation of Jump Search</h3><p id="e7f89b58-7e91-4d30-a7bf-69744420982f" class="">Here&#x27;s a simple implementation of the Jump Search algorithm in JavaScript:</p><pre id="52a752bf-6a85-4589-ab39-a1d45929a30e" class="code code-wrap"><code>function jumpSearch(arr, target) {
  const n = arr.length;
  const step = Math.floor(Math.sqrt(n));
  let prev = 0;

  // Finding the block where the target may exist
  while (arr[Math.min(step, n) - 1] &lt; target) {
    prev = step;
    step += Math.floor(Math.sqrt(n));

    if (prev &gt;= n) {
      return -1; // Target not found
    }
  }

  // Performing a linear search within the block
  while (arr[prev] &lt; target) {
    prev++;

    if (prev === Math.min(step, n)) {
      return -1; // Target not found
    }
  }

  // Check if the target is found
  if (arr[prev] === target) {
    return prev; // Index of the target element
  }

  return -1; // Target not found
}

// Example usage
var arr = [1, 2, 3, 4, 5, 6, 7];
var target = 5;
console.log(jumpSearch(arr, target)); // Output: 4 (index of the target element)</code></pre><ul id="76805108-799b-4f1b-b6b7-8356d9ce512c" class="toggle"><li><details class=""><summary><strong>Explanation</strong></summary><ol type="1" id="d2659f27-afdb-4218-9829-99df25974376" class="numbered-list" start="1"><li>The block size <code>step</code> is calculated as the square root of the length of the array, rounded down to the nearest integer.</li></ol><ol type="1" id="6e7fc8ff-c735-420b-9a87-560355f05db8" class="numbered-list" start="2"><li>The algorithm starts by jumping ahead <code>step</code> indices at a time until it finds a block where the target value may exist (i.e., the current block&#x27;s last element is greater than or equal to the target value, or the end of the array is reached).</li></ol><ol type="1" id="ebc0dc5d-ae22-4797-80c9-328504e4fc05" class="numbered-list" start="3"><li>Once the block is identified, a linear search is performed within the block to find the exact position of the target value.</li></ol><ol type="1" id="b2fcea34-047a-4dc7-a608-3ec9028d9253" class="numbered-list" start="4"><li>If the target value is found, the function returns its index. If the target value is not found within the block and the end of the array is not reached, the process is repeated by jumping to the next block and performing another linear search.</li></ol><ol type="1" id="ce53ba83-d3a3-4c94-86ac-a202ba1d5d3d" class="numbered-list" start="5"><li>The algorithm continues until the target value is found or the end of the array is reached.</li></ol><ol type="1" id="6bf35f6f-08cc-45e9-8aaa-41c68c56ce6e" class="numbered-list" start="6"><li>If the target value is not found, the function returns -1 to indicate the absence of the target value in the array.</li></ol></details></li></ul><h3 id="dfb55428-35dc-4191-894a-b2afd455277c" class="">Time Complexity of Jump Search</h3><ul id="507f08a4-b461-45c8-b718-428a14953c93" class="bulleted-list"><li style="list-style-type:disc"><strong>Worst-case time complexity:</strong> <code>O(√n)</code><p id="7588a440-a608-4ef7-958e-65610604dcbe" class="">The worst-case time complexity of jump search is <code>O(√n)</code>, where <code>n</code> is the length of the array. This occurs when the target value is located at the last element of a block, and the algorithm performs a linear search within that block or reaches the end of the array.</p></li></ul><ul id="4bcec750-bfb9-485e-a268-70574043c45d" class="bulleted-list"><li style="list-style-type:disc"><strong>Average-case time complexity:</strong> <code>O(√n)</code><p id="a335e7c8-06f1-4d45-8133-635e8ca1a95a" class="">The average-case time complexity of jump search is also <code>O(√n)</code>. On average, the algorithm performs fewer comparisons compared to linear search, resulting in improved efficiency.</p></li></ul><ul id="1aa36860-b7e8-4b99-a901-7afb1d4fa3f3" class="bulleted-list"><li style="list-style-type:disc"><strong>Best-case time complexity:</strong> <code>O(1)</code><p id="7df8d5b6-df80-4e9b-bc19-0d300a15f2c7" class="">The best-case time complexity of jump search occurs when the target value is found in the first comparison, resulting in a constant time complexity of <code>O(1)</code>.</p></li></ul><h3 id="2a0c7ae6-0e60-4faa-9105-28c7d9ebd7f0" class="">Space Complexity of Jump Search</h3><ul id="0972f588-15f7-4783-8837-fff4b550eef2" class="bulleted-list"><li style="list-style-type:disc"><strong>Space complexity of Jump Search:</strong> <code>O(1)</code><p id="92d73fea-f82c-469d-a75f-230379f4f531" class="">Jump search is an in-place algorithm that does not require additional data structures. It operates directly on the input array, utilizing only a few variables for tracking indices and values. Therefore, its space complexity is <code>O(1)</code>.</p><p id="66e3985f-71be-4ab9-8d8f-22163e7225dd" class="">
</p></li></ul><h2 id="3819b434-4ab4-4c34-8618-6fcbe8558669" class=""><mark class="highlight-blue"><strong>Activity 1</strong></mark></h2><p id="bc08929a-bf68-4cc5-a957-eab3740f97f0" class=""><strong>Fill in the blanks:</strong></p><ol type="1" id="18887e25-2cd8-4485-bbde-75d3c1f4c56d" class="numbered-list" start="1"><li>The Jump Search algorithm performs a __________<strong>(linear/binary/sequential)</strong> search within the identified block to find the exact position of the target value.</li></ol><ol type="1" id="430cd079-f63d-4530-bab3-34f5054be9ff" class="numbered-list" start="2"><li>The block size in Jump Search is calculated as the __________<strong>(square root/logarithmic/reciprocal) </strong>of the length of the array.</li></ol><ol type="1" id="249ce50d-ff8f-412b-8231-e3c2fa30404b" class="numbered-list" start="3"><li>The Jump Search algorithm returns the index of the target element if it is found, or __________<strong>(-1 / 0 / null)</strong> if the target value is not present in the array.</li></ol><ol type="1" id="d8eee3c7-b49d-49fd-bad8-323ddaff15d5" class="numbered-list" start="4"><li>Jump Search is an __________<strong>(in-place/recursive/efficient)</strong> algorithm that operates directly on the input array without requiring additional data structures.</li></ol><ol type="1" id="f53cf85b-6011-41a3-8e3e-16ac3ff12ea9" class="numbered-list" start="5"><li>The average-case time complexity of Jump Search is __________<strong>( O(1)/O(log n)/O(√n) )</strong>, resulting in improved efficiency compared to linear search.</li></ol><ul id="01c7835e-bcdc-47ca-82a1-c687910d84b8" class="toggle"><li><details class=""><summary><strong>Answers</strong></summary><ol type="1" id="c96e739b-14d0-4dec-9c33-95028dd76d91" class="numbered-list" start="1"><li>sequential</li></ol><ol type="1" id="23d67791-eefe-42f1-b3ee-8f0babec0ae3" class="numbered-list" start="2"><li>square root</li></ol><ol type="1" id="d3d51fe6-31dc-4596-9e98-cecfaed9d425" class="numbered-list" start="3"><li>-1</li></ol><ol type="1" id="e0c6b655-c7cd-4312-9e58-91bed2e1c6d3" class="numbered-list" start="4"><li>in-place</li></ol><ol type="1" id="3a2f3279-20ee-45ea-b78d-4ff9a32f5c7d" class="numbered-list" start="5"><li>O(√n) </li></ol></details></li></ul><p id="2d6487d5-4267-41c0-ba04-04ae9978af46" class="">
</p><h2 id="4ace2025-5ea5-4048-a246-2ea2e355a61a" class=""><mark class="highlight-red">Introduction to Exponential Search</mark></h2><p id="b91c962c-5ee7-40f3-87c4-c4e3b1c042d9" class="">Exponential search is a searching algorithm designed to find the position of a target value in a sorted array by repeatedly doubling the search range. It combines elements of both binary search and linear search algorithms.</p><h3 id="0b72728e-f6eb-4b01-93ed-2a281c59898b" class=""><strong>Working of Exponential Search</strong></h3><ol type="1" id="d0312069-11c5-4885-975d-b4eb3c939fed" class="numbered-list" start="1"><li><strong>Determine the Search Range</strong>: Start with a minimum search range of size 1 (index 0) and gradually increase the search range by doubling its size until an element greater than or equal to the target value is found, or the end of the array is reached.</li></ol><ol type="1" id="5448e72c-e473-46ba-8f50-20e0a8fa8735" class="numbered-list" start="2"><li><strong>Perform Binary Search</strong>: Once the search range is identified, perform a binary search within that range to locate the exact position of the target value.</li></ol><ol type="1" id="487cdac1-5d8b-4e74-a219-f3a09af66c4c" class="numbered-list" start="3"><li><strong>Repeat or Conclude</strong>: If the target value is found, return its index. If the target value is not found and the end of the array is not reached, repeat the process by doubling the search range and performing another binary search. Continue until the target value is found or the end of the array is reached.</li></ol><h3 id="d8c4be22-a70d-48aa-bf47-a2de3373ddaf" class="">Implementation of Exponential Search</h3><p id="e8417b53-5b40-44c1-89cf-827140baa65f" class="">Here&#x27;s a simple implementation of the Exponential Search algorithm in JavaScript:</p><pre id="654c874f-6619-44de-9f20-eb243dd57aaa" class="code code-wrap"><code>function exponentialSearch(arr, target) {
  const n = arr.length;

  if (arr[0] === target) {
    return 0; // Target found at the first element
  }

  let i = 1;
  while (i &lt; n &amp;&amp; arr[i] &lt;= target) {
    i *= 2;
  }

  // Perform binary search within the identified range
  let left = Math.floor(i / 2);
  let right = Math.min(i, n - 1);

  while (left &lt;= right) {
    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      return mid; // Target found
    }

    if (arr[mid] &lt; target) {
      left = mid + 1; // Target may be in the right half
    } else {
      right = mid - 1; // Target may be in the left half
    }
  }

  return -1; // Target not found
}

// Example usage
var arr = [1, 2, 3, 4, 5, 6, 7];
var target = 5;
console.log(exponentialSearch(arr, target)); // Output: 4 (index of the target element)</code></pre><ul id="70d259db-1877-432d-961a-82b2e00009f7" class="toggle"><li><details class=""><summary><strong>Explanation</strong></summary><ol type="1" id="a156f550-955e-414a-b0df-ceac3b05a039" class="numbered-list" start="1"><li>The algorithm begins by checking if the first element of the array is the target value. If it is, the function returns the index 0 since the target value is found.</li></ol><ol type="1" id="873fae3e-9ce8-4d20-b765-a76d85b5c56a" class="numbered-list" start="2"><li>The search range starts with a size of 1 (index 0) and gradually doubles its size by multiplying the index <code>i</code> by 2 until an element greater than or equal to the target value is found, or the end of the array is reached.</li></ol><ol type="1" id="75296ffe-c6b1-4d74-a9de-44cea5f49447" class="numbered-list" start="3"><li>Once the search range is identified, a binary search is performed within that range to find the exact position of the target value.</li></ol><ol type="1" id="0a0aacaf-22a9-4e8a-a253-1e6d5c960cc6" class="numbered-list" start="4"><li>The binary search repeatedly divides the search range in half and compares the middle element with the target value. Depending on the comparison, the search range is adjusted accordingly by moving the left or right boundary.</li></ol><ol type="1" id="94145a59-8607-4315-97dc-db1af18d8cc2" class="numbered-list" start="5"><li>The process continues until the target value is found or the search range is exhausted.</li></ol><ol type="1" id="2281e3a1-7020-4621-92f2-0e6e5e392db9" class="numbered-list" start="6"><li>If the target value is found, the function returns its index. If the target value is not found and the end of the array is reached, the function returns -1 to indicate the absence of the target value.</li></ol></details></li></ul><h3 id="675b2a66-eab0-4225-a3bf-ee7fff7b9314" class="">Time Complexity of Exponential Search</h3><ul id="90a23d48-2806-452d-a816-8c1fa8f7b3f4" class="bulleted-list"><li style="list-style-type:disc"><strong>Worst-case time complexity:</strong> <code>O(log n)</code><p id="eab6c7cd-38f2-41b2-a90c-4e7348a1af6a" class="">The worst case time complexity of exponential search is <code>O(log n)</code>, where <code>n</code> is the length of the array. This occurs when the target value is located at the end of the array, and the algorithm performs a binary search on the last search range, which has a size of <code>n/2</code> (assuming the array is sorted in ascending order).</p></li></ul><ul id="05bd033d-4e6d-4a1d-90b9-8728d4cb0c8e" class="bulleted-list"><li style="list-style-type:disc"><strong>Average-case time complexity:</strong> <code>O(log n)</code><p id="c815e73b-7582-4189-a6cc-e18a8d185c1a" class="">The average-case time complexity of exponential search is also <code>O(log n)</code>. On average, the search range is divided in half during each iteration of the binary search, resulting in efficient searching.</p></li></ul><ul id="002f6c00-af72-4ffb-80a9-e7f6f17e1fd8" class="bulleted-list"><li style="list-style-type:disc"><strong>Best-case time complexity:</strong> <code>O(1)</code><p id="5eb4c99e-2a9f-4a0c-88ab-72a705ffe2cb" class="">The best-case time complexity of exponential search occurs when the target value is found at the first element of the array, resulting in a constant time complexity of <code>O(1)</code>.</p></li></ul><h3 id="de972178-d089-4b91-a5b9-35b08235bd9c" class="">Space Complexity of Exponential Search</h3><ul id="df3aa6cd-d09e-4042-a887-b091fde55b73" class="bulleted-list"><li style="list-style-type:disc"><strong>Space complexity of Exponential Search:</strong> <code>O(1)</code><p id="52945cce-fae7-455f-bf98-5c518de82972" class="">Exponential search is an in-place algorithm that does not require additional data structures. It operates directly on the input array, utilizing only a few variables for tracking indices and values. Therefore, its space complexity is <code>O(1)</code>.</p></li></ul><h2 id="a38ec26e-90c8-47fe-9d20-14d7ae2b83b0" class="block-color-default"><mark class="highlight-red">Practical Applications of Searching Algorithms</mark></h2><p id="7bb1b00c-200c-4035-b29a-dcea510fcdf7" class="">Searching algorithms are widely used in computer science and have practical applications in various fields. Some of the most common applications of searching algorithms are:</p><ol type="1" id="afaebe9b-adbd-489a-b556-200cfa458a3d" class="numbered-list" start="1"><li><strong>Database Search</strong>: Used in databases to efficiently locate records based on criteria.</li></ol><ol type="1" id="b729b69c-a7fb-4756-b783-045ce2076853" class="numbered-list" start="2"><li><strong>Web Search Engines</strong>: Employ searching algorithms to retrieve relevant web pages based on search queries.</li></ol><ol type="1" id="ae8f5c45-b9a7-457f-a6bb-3bc401a862cf" class="numbered-list" start="3"><li><strong>File Searching</strong>: Used in file systems and operating systems to locate files based on attributes.</li></ol><ol type="1" id="ae650094-e5f0-4e24-af39-fcd3b845cbf8" class="numbered-list" start="4"><li><strong>Genetic Sequencing</strong>: Searches for patterns or sequences in DNA or protein databases.</li></ol><ol type="1" id="d4ed0cb1-42a9-4a9a-becd-a71677e2142d" class="numbered-list" start="5"><li><strong>Artificial Intelligence</strong>: Used for pathfinding in robotics and game-playing algorithms.</li></ol><ol type="1" id="50c8a604-2b24-4ed1-a46a-393878390d3c" class="numbered-list" start="6"><li><strong>Information Retrieval</strong>: Retrieves relevant information from large collections based on user queries.</li></ol><ol type="1" id="eeb3069e-e277-4e5a-b56c-65a37f1c09e9" class="numbered-list" start="7"><li><strong>Recommendation Systems</strong>: Searches for relevant items or suggestions based on user preferences.</li></ol><ol type="1" id="890d23a9-483b-47f2-b61b-797de795196a" class="numbered-list" start="8"><li><strong>Data Mining</strong>: Searches for patterns or associations in large datasets for extracting insights.</li></ol><p id="5212e1b6-136d-41c7-acee-54f1c5a91c3f" class="">These applications highlight the diverse usage of searching algorithms in different domains, from databases and web search engines to artificial intelligence and data mining.</p><p id="c561cfe8-e4b2-4155-89ef-2c3722afd534" class="">
</p><h2 id="9784a98f-71ed-4b98-bf09-5130dea0a77c" class="block-color-default"><mark class="highlight-blue"><strong>Explore Further</strong></mark></h2><p id="04e9c4ba-1db3-41f7-a3c6-6ebd425ba745" class=""><mark class="highlight-orange"><strong>Uncover and unlock new insights as you dive into the captivating content found in the provided link.</strong></mark></p><p id="b443b00b-ac99-4188-8dca-5fd192c9a491" class=""><strong>Tri-Search Algorithm: </strong><a href="https://www.notion.so/Tri-Search-Algorithm-2e553221aeea4f06bd3fe06658ee8287?pvs=21">https://www.notion.so/almabetter/Tri-Search-Algorithm-2e553221aeea4f06bd3fe06658ee8287</a></p><p id="370f95c5-91f2-4d32-8b07-f10d1569071f" class="">
</p><p id="991b36dc-f389-4203-9d60-9fafc82fac87" class=""><mark class="highlight-orange"><strong>Tackle these questions head-on!</strong></mark></p><p id="6d8c42d2-5db5-4c6d-8bac-e2360027ed47" class=""><strong>True or False:</strong></p><ol type="1" id="f35ff555-72a5-452c-8277-becfd6c4dc1c" class="numbered-list" start="1"><li>Tri-Search is an extension of the Ternary Search algorithm that introduces variable partitioning to improve search efficiency.</li></ol><ol type="1" id="4a55f418-06d3-4c4c-aaca-c6c81e3e824b" class="numbered-list" start="2"><li>Tri-Search adaptively divides the search space into equal parts based on the characteristics of the data.</li></ol><ol type="1" id="9ec966e3-4fb7-4dad-83c0-62e83a1165c4" class="numbered-list" start="3"><li>Tri-Search performs a binary search between the mid1 and mid2 positions if the target value falls between those elements.</li></ol><ol type="1" id="5bbf60b2-3c70-402f-845d-09f2b834ea84" class="numbered-list" start="4"><li>The Tri-Search algorithm requires the input array to be sorted in ascending order.</li></ol><ol type="1" id="cee24290-c351-40e5-bed6-0b571914a6ca" class="numbered-list" start="5"><li>Tri-Search guarantees to find the target value in a sorted array in logarithmic time complexity.</li></ol><ul id="71255cd9-a550-465a-9af4-0f56a90c9a61" class="toggle"><li><details class=""><summary><strong>Answers</strong></summary><ol type="1" id="d7e6421d-36ba-4d97-847e-32533552b6c5" class="numbered-list" start="1"><li>True</li></ol><ol type="1" id="bb5d22b2-8e9c-4e5e-abf6-94f43f3a8316" class="numbered-list" start="2"><li>False</li></ol><ol type="1" id="a6654801-d22c-41f3-866d-beb1e0c5dd8a" class="numbered-list" start="3"><li>True</li></ol><ol type="1" id="b00353b7-9d0a-467b-9a73-46f2304c28d9" class="numbered-list" start="4"><li>True</li></ol><ol type="1" id="fa402c10-566c-4adb-8cf8-ffaca890f676" class="numbered-list" start="5"><li>False</li></ol></details></li></ul><p id="d7a6341b-e0b1-45b8-a605-7ac0e93a506b" class="">
</p><h1 id="591622db-2c56-4f64-b2e9-18c1577f011c" class=""><mark class="highlight-brown">Summary</mark></h1><h2 id="3c704f58-13cf-4ebe-803e-cb100e18bc7a" class="block-color-default"><mark class="highlight-red">What did we learn?</mark></h2><ul id="a6efe087-2e56-4a18-85dd-7d5c1c21e05c" class="bulleted-list"><li style="list-style-type:disc">Algorithm analysis is essential for understanding the behavior of algorithms as input size increases.</li></ul><ul id="a29253e7-5765-4d25-879f-7c1a6708eb01" class="bulleted-list"><li style="list-style-type:disc">Different types of searching algorithms have different time and space complexities, which affect their performance in practice.</li></ul><ul id="e3d2fcf1-9431-469a-b2ed-40c326bcd9aa" class="bulleted-list"><li style="list-style-type:disc">The best, worst, and average case analysis of searching algorithms provides insights into their performance in different scenarios.</li></ul><ul id="e88d776a-ed9d-45b7-9548-8ad89ee3d971" class="bulleted-list"><li style="list-style-type:disc">Empirical analysis involves measuring the performance of algorithms in practice to determine their efficiency.</li></ul><ul id="c7dc3fac-3cbe-4748-9d09-84224d8588c8" class="bulleted-list"><li style="list-style-type:disc">Determining the optimal search algorithm for a specific problem requires taking into account the tradeoffs between time and space complexity.</li></ul><ul id="b0b29efe-b051-4b85-a5a0-da1e9e5f3304" class="bulleted-list"><li style="list-style-type:disc">Searching algorithms have practical applications in various fields, including e-commerce, social media, and search engines.</li></ul><ul id="bafdb1ca-afcf-4669-8ba2-4b42bb041a1c" class="bulleted-list"><li style="list-style-type:disc">Efficient searching algorithms can significantly improve the performance of real-world applications, providing a better user experience.</li></ul><h2 id="a190706b-794b-41b4-b812-56bd5a4a263f" class="block-color-default"><mark class="highlight-red">Best Practices</mark></h2><ul id="1bf4b113-d9bc-499e-880a-b3655d51b561" class="bulleted-list"><li style="list-style-type:disc">Understand the basic concepts of algorithm analysis, including time and space complexity, before diving into the specifics of searching algorithms.</li></ul><ul id="f609e074-d701-42b4-a9ff-98d2d73e56b9" class="bulleted-list"><li style="list-style-type:disc">When analyzing searching algorithms, consider their time and space complexities in different scenarios, including best, worst, and average cases.</li></ul><ul id="ab5bad18-0f86-4fd4-96f8-f1f7dc44bc96" class="bulleted-list"><li style="list-style-type:disc">Use empirical analysis to measure the performance of searching algorithms in practice.</li></ul><ul id="0168ee0c-a696-4f0b-911b-5cfda73805ea" class="bulleted-list"><li style="list-style-type:disc">Consider the tradeoffs between time and space complexity when selecting an optimal search algorithm for a specific problem.</li></ul><ul id="69bd1a0d-b395-47f1-99eb-2ce74a2e720d" class="bulleted-list"><li style="list-style-type:disc">Implement and optimize searching algorithms using efficient data structures and programming techniques.</li></ul><ul id="ff308e6a-7e39-4947-8d7c-72792fd0d280" class="bulleted-list"><li style="list-style-type:disc">Stay up-to-date with the latest research and developments in the field of algorithm analysis.</li></ul><ul id="f04d92fe-1f0c-4b74-9402-d5f53af27e40" class="bulleted-list"><li style="list-style-type:disc">Test and validate the performance of searching algorithms using real-world data and use cases.</li></ul><h2 id="643b77e8-0539-4a9c-b36a-1f66d706e361" class="block-color-default"><mark class="highlight-red">Shortcomings &amp; Challenges</mark></h2><ul id="ca1e63be-af29-49e5-bfba-4b3ea22d6bc4" class="bulleted-list"><li style="list-style-type:disc">The time and space complexities of algorithms may vary depending on the hardware and software used to run them.</li></ul><ul id="6cce4832-0bc3-4261-99c7-c825d3d484d9" class="bulleted-list"><li style="list-style-type:disc">Selecting the optimal search algorithm for a specific problem may require trial-and-error and experimentation, which can be time-consuming and costly.</li></ul><ul id="a58ed61a-161e-46cc-9a7c-020f2f4a3ca1" class="bulleted-list"><li style="list-style-type:disc">Searching algorithms may not always provide the most efficient solution to a problem, and alternative approaches may need to be considered.</li></ul><h2 id="6fed3b79-8838-4d2d-9a66-791aea08ad81" class="block-color-default"><mark class="highlight-red">Enhanced your knowledge</mark></h2><ul id="9160a4b7-b407-466d-8728-24c98feae0b1" class="bulleted-list"><li style="list-style-type:disc"><code>Big-O notation explained</code>: a blog post by Rob Bell that provides an easy-to-understand explanation of Big-O notation, a key concept in algorithm analysis. Link: <a href="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/">https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/</a></li></ul><p id="dc372f30-df8e-4737-a4ec-d876dd94737e" class="">
</p></div></article></body></html>
