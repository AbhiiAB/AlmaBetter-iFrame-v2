<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Introduction to Searching Algorithms </title><link rel="stylesheet" href="../../../../../styles.css"></head><body><article id="30c23e4f-591a-446a-b16d-dfcbe120d9c7" class="page sans"><header><h1 class="page-title">Introduction to Searching Algorithms </h1><p class="page-description"></p></header><div class="page-body"><ul id="b7c7a79b-ef31-4abb-8baa-e1c179d1f684" class="toggle"><li><details close=""><summary><strong>Session Flow (5 minutes read)</strong></summary><ul id="537e9da1-5fac-483a-a217-6cb4b7d21be0" class="bulleted-list"><li style="list-style-type:disc"><strong>Learning Objective (5 minutes read)</strong><ul id="9aef81d1-93b5-4565-990c-d7467a430539" class="bulleted-list"><li style="list-style-type:circle">Introduction</li></ul><ul id="f3e441fa-b9a5-41ad-bc1d-cde89f814165" class="bulleted-list"><li style="list-style-type:circle">Theme</li></ul><ul id="d3966256-8b53-4f9e-a809-a30ea9753e48" class="bulleted-list"><li style="list-style-type:circle">Primary Goals</li></ul></li></ul><ul id="08d85423-dde0-44c5-992f-46214819ebee" class="bulleted-list"><li style="list-style-type:disc"><strong>Introduction to Searching Algorithms</strong> <strong>(120 minutes read)</strong><ul id="650d100e-9699-4ce9-afee-2e1179e63aed" class="bulleted-list"><li style="list-style-type:circle">Introduction to Linear Search<ul id="a9e2e465-639d-4e64-b0b9-d89df5f6544e" class="bulleted-list"><li style="list-style-type:square">Working of Linear Search</li></ul><ul id="c18e2071-b4dd-41d1-b645-332cf2df0b34" class="bulleted-list"><li style="list-style-type:square">Implementation of Linear Search</li></ul><ul id="7eb5f1f3-77c9-4931-a9d2-4cf79e0fe073" class="bulleted-list"><li style="list-style-type:square">Time Complexity of Linear Search</li></ul><ul id="da76c55e-14ec-4bec-aacc-27b73755ba5e" class="bulleted-list"><li style="list-style-type:square">Space Complexity of Linear Search</li></ul></li></ul><ul id="a95a5615-cdf0-4791-a87e-cc7f7bc39eb5" class="bulleted-list"><li style="list-style-type:circle">Variations of Linear Search</li></ul><ul id="407c316e-fd31-4e4a-9101-99cca8c696c4" class="bulleted-list"><li style="list-style-type:circle">Advantages and Disadvantages of Linear Search</li></ul><ul id="01a6dfcf-3938-4989-8ceb-91d4e6707bb9" class="bulleted-list"><li style="list-style-type:circle"><strong>Try it yourself</strong></li></ul><ul id="cd3b89f8-60a0-4d5c-97ea-46e228235ffd" class="bulleted-list"><li style="list-style-type:circle">Introduction to Binary Search<ul id="6fb8f6cd-4067-46d6-b142-2672555dde84" class="bulleted-list"><li style="list-style-type:square">Working of Binary Search</li></ul><ul id="4a22602f-8e4f-4766-83ed-38a4ad2a91cc" class="bulleted-list"><li style="list-style-type:square">Implementation of Binary Search</li></ul><ul id="8fee2eb7-3392-4b70-8e07-38f92ce596d5" class="bulleted-list"><li style="list-style-type:square">Time Complexity of Binary Search</li></ul><ul id="4b22e4b0-6007-4ea7-a4ab-ea484afd5e9c" class="bulleted-list"><li style="list-style-type:square">Space Complexity of Linear Search</li></ul></li></ul><ul id="d7253d39-1cbc-42e3-b803-d6d6f09d06d5" class="bulleted-list"><li style="list-style-type:circle">How does Binary Searching help us?</li></ul><ul id="226310cb-6eea-4817-81f6-9f9530f5b759" class="bulleted-list"><li style="list-style-type:circle">Drawbacks of Binary Search</li></ul><ul id="693e8f29-57fe-40c5-8a0f-52bd478c6aa4" class="bulleted-list"><li style="list-style-type:circle">Real-Life Applications of Linear and Binary Search</li></ul><ul id="2b6891c1-1189-42f8-a53c-c4e1f9013f14" class="bulleted-list"><li style="list-style-type:circle"><strong>Activity 1</strong></li></ul><ul id="4d874557-94cf-44a1-aba7-9afae974112d" class="bulleted-list"><li style="list-style-type:circle">Introduction to Hashmap<ul id="62cfea85-63fe-4355-895a-cd2410cab737" class="bulleted-list"><li style="list-style-type:square">What are Hashtables?</li></ul><ul id="5fbcfe1e-ba34-44c1-91c3-933848e03cae" class="bulleted-list"><li style="list-style-type:square">Working of Hashmap</li></ul><ul id="69dacc47-e439-4b96-abcc-9048d98add50" class="bulleted-list"><li style="list-style-type:square">Implementation of Hashmap</li></ul></li></ul><ul id="23f7ade2-f68f-4d40-b39d-e22a3bc0081b" class="bulleted-list"><li style="list-style-type:circle"><strong>Activity 2</strong></li></ul><ul id="2e82f53e-aaea-4736-a2b0-25e0fc0f6b85" class="bulleted-list"><li style="list-style-type:circle">Time Complexity of Hashmaps</li></ul><ul id="2be9c9fc-967a-4015-9f4f-6f5ed3bb28fa" class="bulleted-list"><li style="list-style-type:circle">Where to use Hashmaps?</li></ul><ul id="96f63937-1945-41a4-8005-926e68592ef5" class="bulleted-list"><li style="list-style-type:circle"><strong>Explore Further</strong></li></ul></li></ul><ul id="23717658-224f-4217-a72d-7f7e2061edb7" class="bulleted-list"><li style="list-style-type:disc"><strong>Summary (10 minutes read)</strong><ul id="64817f42-0e4d-43a8-8002-ae6730bb57d4" class="bulleted-list"><li style="list-style-type:circle">What did we learn?</li></ul><ul id="30595bf8-d6b9-438f-97ed-0a343d4dec17" class="bulleted-list"><li style="list-style-type:circle">Shortcomings &amp; Challenges</li></ul><ul id="a7b0c64d-75d3-4e7c-bca3-b75ade392c55" class="bulleted-list"><li style="list-style-type:circle">Best Practices</li></ul><ul id="c9468dc0-72b3-4650-977d-ae39986f86b5" class="bulleted-list"><li style="list-style-type:circle">Enhance Your Knowledge</li></ul></li></ul><p id="1b426854-009a-42ee-944a-a475f2808b2b" class="">
</p></details></li></ul><p id="17d3b1d2-d79b-4cfb-a847-9fc855a729cc" class="">
</p><h2 id="35ec3f57-93e1-43e7-b7cf-aff34ca1f790" class="block-color-default"><mark class="highlight-red">Introduction</mark></h2><p id="dc757a0c-7964-491e-8d3f-28dd3efb81f1" class="">Linear and binary search are two of the most basic and fundamental algorithms in computer science and programming. Both are used to search for a specific value from a collection of data. A Hashmap is a data structure comprising key-value pairs, providing constant-time storage and data retrieval, irrespective of the collection size.</p><p id="7ddcdbe4-d423-4d56-aabc-6def2a22bf3e" class=""><strong>Duration:</strong> 2 Hours</p><p id="565dd8cf-c6d7-4495-b302-260f776cd53f" class=""><strong>Focus:</strong> Introduction to Linear Search, Binary Search, and Hashmap, Implementation, and Use Cases</p><p id="7a4cc63e-4167-40a9-a444-d0fca0556fe6" class=""><strong>Pre-requisite: </strong>JavaScript</p><h2 id="ff8247b5-5c8e-46ba-9629-057173756722" class="block-color-default"><mark class="highlight-red">Theme</mark></h2><p id="635d61b0-8441-4ded-8294-a634669e9a39" class="">In a library setting, let&#x27;s consider a scenario where you need to assist patrons in finding books efficiently. When a patron requests a book without providing additional details, you perform a <strong>Linear search</strong> by sequentially checking each shelf. This method is useful when books are unsorted, or patrons have limited information about the book.</p><p id="1d2c6c28-bde1-4368-ab60-a92583b76ba8" class="">To enhance search speed, you have sorted the books on each shelf, allowing you to employ <strong>Binary search</strong>. When a patron provides the exact title of the book, you start searching from the middle, comparing the target title with the current book&#x27;s title. Based on the comparison, you continue searching in the lower or upper half of the shelf until the desired book is found.</p><p id="c2212ee9-497a-4b0c-8423-b433ae2bb28d" class="">Additionally, you have implemented a digital catalog using a <strong>Hashmap</strong>. Each book title serves as a key, and the corresponding shelf number is the value. By hashing the book titles, you can quickly retrieve the shelf number for any book, enabling patrons to locate books based on their titles efficiently.</p><h2 id="05b2cec7-321f-43c3-bb96-e0bb7036c119" class="block-color-default"><mark class="highlight-red">Primary Goals</mark></h2><ul id="bf1a46d6-09ed-4255-b637-9aa1f918f98e" class="bulleted-list"><li style="list-style-type:disc">Know the concept and implementation of the linear search and binary search algorithm.</li></ul><ul id="df3b02a3-f94b-440c-b785-a8d757d145bb" class="bulleted-list"><li style="list-style-type:disc">Understand the time and space complexity of linear search and binary search.</li></ul><ul id="e8908816-6f85-4ce9-825a-ae22710c9da0" class="bulleted-list"><li style="list-style-type:disc">Implement a hashmap in JavaScript.</li></ul><ul id="37e8c26f-7740-4bf0-9cde-647e022de501" class="bulleted-list"><li style="list-style-type:disc">Know the use cases where hashmaps are applicable, such as efficient data retrieval, caching, or frequency counting.</li></ul><h1 id="f46875e5-7afa-43ce-9842-320e713140b5" class=""><mark class="highlight-brown">Introduction to Searching Algorithms</mark></h1><p id="ac8e882f-84ec-4735-9786-0b469d47365c" class="">As a software engineer, James loved solving problems using algorithms. One day, he was assigned to develop a search function for a large e-commerce website that had thousands of products.</p><p id="b6557ecf-cf4f-42d4-89b5-e8b8e87429c3" class="">James knew he had to choose the right search algorithm to make the function efficient and fast. He decided to implement both linear search and binary search and tried to use the best algorithm for searching for the product.</p><p id="833b902b-fa7b-4ffb-844e-b774ac44bc01" class="">The e-commerce website&#x27;s customers were also happy with the new search function, as they could quickly and easily find the products they were looking for. James was proud of his work and knew his algorithms would continue to help people solve problems efficiently and effectively.</p><h2 id="345b94ac-7d94-4930-84a9-bb590570bc84" class="block-color-default"><mark class="highlight-red">Introduction to Linear Search</mark></h2><p id="1a05894e-1461-46bd-918d-9b74b26472b5" class="">Linear search, also known as sequential search, is a simple search algorithm that traverses an array or list sequentially to find a specific target element. It starts from the beginning of the array and checks each element one by one until either the target element is found or the end of the array is reached.</p><p id="77bb4f1d-4bd3-48f2-a0a1-e9566cb81aef" class="">Linear search is often used on small collections or for situations where the collection is unsorted or has a random order.</p><h3 id="1839da6a-7444-42a2-8ae0-5c95044b18f8" class=""><strong>Working of Linear Search</strong></h3><ol type="1" id="258c39c7-cfd7-477e-8404-0db544daafb0" class="numbered-list" start="1"><li><strong>Start at the Beginning</strong>: Linear Search starts at the first element of the collection.</li></ol><ol type="1" id="cba44e83-7665-42f5-9027-1af41de3ee5a" class="numbered-list" start="2"><li><strong>Compare with Target</strong>: It compares the current element with the target value that needs to be found.</li></ol><ol type="1" id="05222aba-3dad-4a18-8805-1bf3321ced33" class="numbered-list" start="3"><li><strong>Match Found</strong>: If the current element matches the target value, the search is successful, and the index of the element is returned.</li></ol><ol type="1" id="d0f057d8-4f4e-4551-ba18-03f0b9d9be69" class="numbered-list" start="4"><li><strong>Move to the Next Element</strong>: If the current element does not match the target value, Linear Search moves to the next element in the collection.</li></ol><ol type="1" id="882b23a7-d8db-45b9-bdaf-8c3dc2d7254b" class="numbered-list" start="5"><li><strong>Repeat the Process</strong>: Steps 3 and 4 are repeated until a match is found or the entire collection has been traversed.</li></ol><ol type="1" id="369ecd6a-5bcf-4ccc-a4f1-c955bde96668" class="numbered-list" start="6"><li><strong>End of Search</strong>: If the entire collection has been traversed without finding a match, Linear Search concludes that the target value is not present in the collection and returns a special value (e.g., -1) to indicate the absence of the target.</li></ol><figure id="b0b38162-3cd6-43e4-b37f-1a3c71e06c29" class="image"><img style="width:480px" src="https://www.tutorialspoint.com/data_structures_algorithms/images/linear_search.gif"/></a></figure><h3 id="a2de7fde-c4e2-48df-9ba4-98eeb9d4ac10" class=""><strong>Implementation of Linear Search</strong></h3><p id="5a41c564-edc8-45d4-8896-841d21880b51" class="">In JavaScript, we can implement linear search using a for loop that iterates through each element of an array and compares it with the search element.</p><p id="fdaa8233-8869-4e97-916e-ceb14dc6c23c" class="">Here&#x27;s a simple implementation of the Linear Search algorithm in JavaScript:</p><pre id="94091726-812c-49cb-a410-319ccd82a9d6" class="code code-wrap"><code>function linearSearch(arr, target) {
  for (let i = 0; i &lt; arr.length; i++) {
    if (arr[i] === target) {
      return i; // Match found, return the index
    }
  }
  return -1; // No match found, return -1
}

// Example usage
var arr = [4, 2, 7, 1, 9];
var target = 7;
console.log(linearSearch(arr, target)); // Output: 2</code></pre><ul id="a19205cd-0cbf-44ea-99f5-bf3e8797a3b4" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="ec94db24-4adf-4e16-bc89-b75eaf69730c" class="numbered-list" start="1"><li>The <code>linearSearch</code> function is defined with two parameters: <code>arr</code>, which is the collection to be searched, and <code>target</code>, which is the value to be found.</li></ol><ol type="1" id="03907a8b-ce4c-4629-968e-b9c3b0fb7cdf" class="numbered-list" start="2"><li>It iterates over each element of the collection using a <code>for</code> loop.</li></ol><ol type="1" id="5bd0538b-f163-48c6-b0e5-ad53abe5c5b3" class="numbered-list" start="3"><li>In each iteration, it compares the current element with the target value using the <code>===</code> equality operator.</li></ol><ol type="1" id="5b74ba32-529f-4881-9a62-66e6fa04a62d" class="numbered-list" start="4"><li>If a match is found, the index of the element is returned.</li></ol><ol type="1" id="511a8676-abb3-48bb-b97f-2a8eec26a3ea" class="numbered-list" start="5"><li>If the entire collection is traversed without finding a match, the function returns -1 to indicate the absence of the target value.</li></ol><ol type="1" id="82ce5c43-dfdb-4c60-92cc-c394938d26b7" class="numbered-list" start="6"><li>The function can be used to search for a target value in an array or any other collection.</li></ol></details></li></ul><p id="490c3a7e-18a1-4400-bb50-58e4206a11ac" class="">Linear search is a simple but inefficient algorithm, especially for large lists. For large lists, other searching algorithms like binary search or hash tables are more efficient.</p><h3 id="af5c2a25-54a1-4c84-8c19-8479eabed307" class=""><strong>Time Complexity of Linear Search</strong></h3><ul id="9d7730be-ecdf-4cd7-9423-f300dcc52164" class="bulleted-list"><li style="list-style-type:disc"><strong>Worst-case time complexity:</strong> <code>O(n)</code><p id="159a82b7-680a-4ec5-abd1-9c17510f548d" class="">Linear Search checks each element in the collection in the worst case, where <code>n</code> is the size of the collection.</p></li></ul><ul id="068e5061-71fb-4349-8c6b-d0852502d545" class="bulleted-list"><li style="list-style-type:disc"><strong>Average-case time complexity:</strong> <code>O(n)</code><p id="d48262a9-882e-4089-a26b-3d3c9d61cdfd" class="">On average, Linear Search needs to examine half of the elements in the collection to find the target value.</p></li></ul><ul id="bd46fd10-e12c-46dc-9558-8d2fce709ab0" class="bulleted-list"><li style="list-style-type:disc"><strong>Best-case time complexity:</strong> <code>O(1)</code><p id="c7f57b52-17d5-4b2a-8339-1922c4a27b86" class="">The best-case scenario occurs when the target value is found at the beginning of the collection. In this case, Linear Search performs only one comparison.</p></li></ul><h3 id="cfb319e0-8747-41ff-8e05-b61f8d746308" class=""><strong>Space Complexity of Linear Search</strong></h3><ul id="c10e1099-6ce6-4d07-a58f-2a15a6f25659" class="bulleted-list"><li style="list-style-type:disc"><strong>Space complexity of Linear Search:</strong> <code>O(1)</code><p id="9c81dbe2-5f32-498a-9fb8-292c2e604bcf" class="">Linear Search requires a constant amount of extra space to store variables for iteration and comparison, regardless of the size of the collection.</p></li></ul><h2 id="33ec6379-7e45-4be9-8993-b254c966f9c7" class="block-color-default"><mark class="highlight-red">Variations of Linear Search</mark></h2><p id="62b4f5d3-f9fa-49b1-a8a8-e4a90f9368ba" class="">There are a few variations of linear search that can be used depending on the specific problem requirements. Here are some examples:</p><ol type="1" id="c992976d-e097-4c94-a95b-39659b3a9c75" class="numbered-list" start="1"><li><strong>Simple Linear Search:</strong> This is the basic implementation of linear search, where we loop through each element of the array and check if it&#x27;s equal to the target value. If we find a match, we return the index of the element.<pre id="902b88aa-bc44-4556-907e-a7e29694d25e" class="code code-wrap"><code>function linearSearch(arr, target) {
  for (let i = 0; i &lt; arr.length; i++) {
    if (arr[i] === target) {
      return i;
    }
  }
  return -1; // Target value not found
}</code></pre></li></ol><ol type="1" id="25e5f6c8-a1de-4f8e-96e3-9996ce607de8" class="numbered-list" start="2"><li><strong>Last Occurrence Linear Search:</strong> In this variation, instead of returning the index of the first occurrence of the target value, we return the index of the last occurrence of the target value.<pre id="5dd31a5c-921a-4fde-b0af-6c391f30b927" class="code code-wrap"><code>function lastOccurrenceLinearSearch(arr, target) {
  let lastIndex = -1;
  for (let i = 0; i &lt; arr.length; i++) {
    if (arr[i] === target) {
      lastIndex = i;
    }
  }
  return lastIndex;
}</code></pre></li></ol><ol type="1" id="fd0b4c9e-7186-4056-bfac-3fc920a72627" class="numbered-list" start="3"><li><strong>Recursive Linear Search:</strong> This variation uses recursion to search for the target value. The array is split into two parts: the first element and the remaining elements. The first element is compared to the target value, and if it&#x27;s a match, we return the index. If not, we recursively call the function on the remaining elements until the target value is found or we reach the end of the array.<pre id="ac911feb-66b6-46a0-954a-2b77bdb7b743" class="code code-wrap"><code>function recursiveLinearSearch(arr, target, start = 0) {
  if (start &gt;= arr.length) {
    return -1; // Target value not found
  }
  if (arr[start] === target) {
    return start;
  }
  return recursiveLinearSearch(arr, target, start + 1);
}</code></pre></li></ol><ol type="1" id="44a0a799-a9df-413c-9063-922059a9245c" class="numbered-list" start="4"><li><strong>Sentinel Linear Search:</strong> In this variation, we add a &quot;sentinel&quot; value to the end of the array equal to the target value. This allows us to eliminate the need to check if we&#x27;ve reached the end of the array during the search, which can improve performance for very large arrays.<pre id="8aece813-a444-4ab0-a64b-c59ec12cbf2f" class="code code-wrap"><code>function sentinelLinearSearch(arr, target) {
  const lastIndex = arr.length - 1;
  const lastValue = arr[lastIndex];
  arr[lastIndex] = target;
  
  let i = 0;
  while (arr[i] !== target) {
    i++;
  }
  
  arr[lastIndex] = lastValue; // Reset the array to its original state
  if (i &lt; lastIndex || arr[lastIndex] === target) {
    return i;
  }
  return -1; // Target value not found
}</code></pre></li></ol><h2 id="d689b32f-ff8e-4af5-9f48-48713586d644" class="block-color-default"><mark class="highlight-red">Advantages and Disadvantages of Linear Search</mark></h2><div id="2c8d0112-e3ee-4775-a89f-dc9f115e8483" class="column-list"><div id="0e690fee-d597-4c65-88ee-6620e9323ce1" style="width:25%" class="column"><p id="82943874-da2d-4090-bb5c-423805873774" class="">
</p></div><div id="02f41c0e-5469-47fd-abb7-cc212649c645" style="width:93.75000000000001%" class="column"><table id="c78467c6-965f-4c81-9b93-63218a0bc5e2" class="simple-table"><thead class="simple-table-header"><tr id="5e90ab4c-250c-4029-8115-3662bcb0df01"><th id="J{og" class="simple-table-header-color simple-table-header" style="width:349px"><strong>Advantages</strong></th><th id="siuO" class="simple-table-header-color simple-table-header" style="width:349px"><strong>Disadvantages</strong></th></tr></thead><tbody><tr id="cef7cbb6-f8e4-4233-b72b-79170f85d4c2"><td id="J{og" class="" style="width:349px">Simple implementation</td><td id="siuO" class="" style="width:349px">Inefficient for large data sets</td></tr><tr id="bb84e010-dc87-4ed5-9e76-5544b0b77185"><td id="J{og" class="" style="width:349px">Suitable for small data sets</td><td id="siuO" class="" style="width:349px">Linear time complexity (O(n))</td></tr><tr id="7b94adb6-2ef4-4f60-8f3e-a99d6b3823e4"><td id="J{og" class="" style="width:349px">No requirements for data organization</td><td id="siuO" class="" style="width:349px">Not suitable for sorted data</td></tr><tr id="f5ee111f-30fb-4833-a766-7bc21b72994a"><td id="J{og" class="" style="width:349px">Works on unsorted data</td><td id="siuO" class="" style="width:349px">It may require searching the entire data set</td></tr><tr id="b3c45742-bdf7-4373-9b90-942c8a773d65"><td id="J{og" class="" style="width:349px">Easy to understand and implement</td><td id="siuO" class="" style="width:349px">Slower than more efficient search algorithms (e.g., binary search)</td></tr></tbody></table></div></div><p id="75728d45-7e9f-412f-a779-68a862e668e4" class="">Overall, linear search is a simple and flexible algorithm, but time complexity and limited search capabilities can make it inefficient for certain applications. It&#x27;s important to consider the size and complexity of the dataset, as well as the specific search requirements when choosing an appropriate search algorithm.</p><p id="5604ba5c-676e-48d3-8d2c-c86026da54d4" class="">
</p><h2 id="c2463f88-a75c-4e19-9e09-6729ef0c5622" class="block-color-default"><mark class="highlight-blue">Try it yourself</mark></h2><p id="354e1b53-ee63-406b-ad6a-db573e5aefa4" class=""><strong>Write a JavaScript function to search for the index of the minimum element in an unsorted array using linear search.</strong></p><ul id="afa7fda9-e49e-4a7d-b191-da5363a973f3" class="toggle"><li><details close=""><summary><strong>Solution</strong></summary><pre id="a97a5a63-53dd-4c2d-b35d-96271b40978c" class="code"><code>function linearSearchForMin(arr) {
  let minIndex = 0;
  for (let i = 1; i &lt; arr.length; i++) {
    if (arr[i] &lt; arr[minIndex]) {
      minIndex = i;
    }
  }
  return minIndex;
}

const arr = [7, 2, 9, 6, 4, 8, 1, 3];
const minIndex = linearSearchForMin(arr);
console.log(`The index of the minimum element in the array is ${minIndex}`); // Output: The index of the minimum element in the array is 6</code></pre><p id="fd15af6c-dbb2-43d0-8b52-05896d4ce0a0" class=""><strong>Explanation:</strong></p><p id="b51074cd-834d-4555-9f91-e9260257e3df" class="">In this example, the <code><strong>linearSearchForMin</strong></code> function takes an array as input and returns the index of the minimum element in the array using linear search.</p><p id="cf0ece4f-8bd3-4452-8096-73b964d2e251" class="">The function starts by initializing <code><strong>minIndex</strong></code> to 0, the index of the first element in the array. It then iterates through the array using a for loop, comparing each element with the element at the current minimum index. If the current element is less than the element at the current minimum index, <code><strong>minIndex</strong></code> is updated to the index of the current element.</p><p id="93ed9f62-7420-4fce-ab05-3e42fa35a83a" class="">After the iteration is complete, the function returns the index of the minimum element in the array.</p><p id="2385db43-f351-49f6-9ba9-0619f3f14f2d" class="">In the example, we search for the index of the minimum element in the array <code><strong>[7, 2, 9, 6, 4, 8, 1, 3]</strong></code>. The <code><strong>linearSearchForMin</strong></code> function returns the index 6, which is the index of the minimum element 1 in the array. The program then outputs &quot;The index of the minimum element in the array is 6&quot;.</p><p id="33216b04-6a21-4e20-8036-1eb4241b29c1" class="">
</p></details></li></ul><p id="bc7554fc-3614-4306-882b-1319a6112f83" class="">
</p><h2 id="1d436bdf-45e5-455c-8370-b38dcb8cdfaa" class=""><mark class="highlight-red">Introduction to Binary Search</mark></h2><p id="60e87a6c-e09d-42ff-b69c-0e5525a4ca84" class="">Binary search is a searching algorithm used to find the position of a specific value in a sorted array or list by repeatedly dividing the search interval in half. It works by comparing the middle element of the array to the target value and adjusting the search interval accordingly until the target value is found or the search interval is empty. </p><p id="2f1ece09-dafa-4205-b535-9a26a4f08707" class="">This approach allows for a significant reduction in the number of elements that need to be checked in comparison to linear search, resulting in a more efficient algorithm for searching large, sorted datasets.</p><figure id="1befc637-4ac9-4e27-bf16-4e1777ab249d" class="image"><img style="width:2490px" src="Introduction%20to%20Searching%20Algorithms%2030c23e4f591a446ab16ddfcbe120d9c7/Screenshot_2023-05-09_at_2.11.42_PM.png"/></a></figure><p id="bd96f06a-ba4e-4799-a6fd-8e61e9ab33d3" class="">Binary search is a more efficient search algorithm that works well for larger arrays. It involves dividing the array in half at each iteration, eliminating half of the remaining elements until the desired element is found.</p><h3 id="4c8f23db-7017-4a20-9100-ed53ecd99a52" class="">Working <strong>of Binary Search</strong></h3><ol type="1" id="4eb5bb5a-d751-4944-b54a-b7a311c1d1fb" class="numbered-list" start="1"><li><strong>Start with a Sorted Collection</strong>: Binary Search requires the collection to be sorted in ascending or descending order for optimal performance.</li></ol><ol type="1" id="336c2cff-b74a-4dbe-b6ee-9d39c6196882" class="numbered-list" start="2"><li><strong>Define Search Space</strong>: Binary Search starts with the entire collection as the initial search space.</li></ol><ol type="1" id="0d156470-28ae-4035-a6fc-7a664d124899" class="numbered-list" start="3"><li><strong>Find the Middle Element</strong>: It calculates the middle element of the search space by averaging the indices of the low and high ends.</li></ol><ol type="1" id="e5524739-e67c-4935-a5d6-e15759aad6c6" class="numbered-list" start="4"><li><strong>Compare with Target</strong>: The middle element is compared with the target value that needs to be found.</li></ol><ol type="1" id="7a752e26-9f70-4fc9-ad0b-2dbcc2fe3fb6" class="numbered-list" start="5"><li><strong>Match Found</strong>: If the middle element matches the target value, the search is successful, and the index of the element is returned.</li></ol><ol type="1" id="781b3f64-245e-4a38-9ab5-e3f142f08d81" class="numbered-list" start="6"><li><strong>Adjust Search Space</strong>: If the middle element is greater than the target value, the search is narrowed down to the lower half of the search space. Otherwise, if the middle element is less than the target value, the search is narrowed down to the upper half of the search space.</li></ol><ol type="1" id="44c3f3ed-d912-443d-951e-d8f2294ac093" class="numbered-list" start="7"><li><strong>Repeat the Process</strong>: Steps 3 to 6 are repeated until a match is found or the search space becomes empty (indicating the absence of the target value).</li></ol><ol type="1" id="135358a1-3db1-406c-9662-a8b97e062548" class="numbered-list" start="8"><li><strong>End of Search</strong>: If the search space becomes empty without finding a match, Binary Search concludes that the target value is not present in the collection and returns a special value (e.g., -1) to indicate the absence of the target.</li></ol><figure id="0e94c0a2-f5fd-4be4-90d6-3cac3e0960fc" class="image"><img style="width:720px" src="https://d18l82el6cdm1i.cloudfront.net/uploads/bePceUMnSG-binary_search_gif.gif"/></a></figure><h3 id="112124f2-cba0-4bf1-85ad-4d069f8d0873" class=""><strong>Implementation of Binary Search</strong></h3><pre id="53e127c4-7d27-43a9-8520-3f431841c83d" class="code code-wrap"><code>function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left &lt;= right) {
    let mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] &lt; target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}</code></pre><ul id="b9ad03bd-66ff-4ed3-8e2a-2c160ae12515" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="c91163dc-d3fc-4ab4-a814-59c86cf522f6" class="numbered-list" start="1"><li>The <code>binarySearch</code> function takes in two parameters: <code>arr</code>, which is the sorted array to search in, and <code>target</code>, which is the value being searched for.</li></ol><ol type="1" id="6bd705c8-7e62-47ee-8858-bbedc5c04538" class="numbered-list" start="2"><li>Two pointers, <code>left</code> and <code>right</code>, are initialized. The <code>left</code> pointer is set to the beginning of the array (index 0), and the <code>right</code> pointer is set to the end of the array (index <code>arr.length - 1</code>).</li></ol><ol type="1" id="d6766df9-3c6b-45b5-ad3e-2a2d1d7f4f43" class="numbered-list" start="3"><li>The code enters a while loop that continues as long as the <code>left</code> pointer is less than or equal to the <code>right</code> pointer. This condition ensures that there is still a valid range to search within the array.</li></ol><ol type="1" id="1759fa20-3392-458b-bd2d-2d91c29abb7d" class="numbered-list" start="4"><li>Inside the while loop, the code calculates the middle index, <code>mid</code>, by taking the average of the <code>left</code> and <code>right</code> pointers and rounding it down using <code>Math.floor((left + right) / 2)</code>. This index represents the middle element of the current search range.</li></ol><ol type="1" id="93bb2bf7-99d5-4dc1-8629-509eddfc2ab8" class="numbered-list" start="5"><li>The code checks if the value at the middle index, <code>arr[mid]</code>, is equal to the target value. If it is, it means the target has been found, and the code returns the index <code>mid</code>.</li></ol><ol type="1" id="a747fff8-3ea2-440c-a17a-04b955fbf0a9" class="numbered-list" start="6"><li>If <code>arr[mid]</code> is less than the target value, it means the target value must be in the right half of the remaining search range. The <code>left</code> pointer is moved to <code>mid + 1</code>, effectively discarding the left half of the search range.</li></ol><ol type="1" id="8d1b219b-f595-46fc-8023-792e06347c48" class="numbered-list" start="7"><li>If <code>arr[mid]</code> is greater than the target value, it means the target value must be in the left half of the remaining search range. The <code>right</code> pointer is moved to <code>mid - 1</code>, effectively discarding the right half of the search range.</li></ol><ol type="1" id="ed61bcc7-435c-42b1-b08d-7abd9122cc09" class="numbered-list" start="8"><li>If the while loop completes without finding the target value, the code reaches the end of the function and returns -1 to indicate that the target value is not present in the array.</li></ol></details></li></ul><h3 id="8279e128-cfb1-4805-a369-c8a642aa35ee" class=""><strong>Time Complexity of Binary Search</strong></h3><ul id="158624ec-283b-404b-998f-32ce0daab720" class="bulleted-list"><li style="list-style-type:disc"><strong>Worst-case time complexity:</strong> <code>O(log n)</code><p id="7a41c0a8-2f8a-440b-b5cb-fff3ee08dfb6" class="">Binary Search divides the search space in half at each iteration. In the worst case, it continues dividing until the search space reduces to a single element or becomes empty. This process can be repeated a maximum of <code>log n</code> times, where <code>n</code> is the size of the sorted collection.</p></li></ul><ul id="1574468f-cea4-49b4-87ed-02b26f79cae7" class="bulleted-list"><li style="list-style-type:disc"><strong>Average-case time complexity:</strong> <code>O(log n)</code><p id="d2166772-5c9d-470c-a83b-6491933fd4b8" class="">The average-case time complexity of Binary Search is also <code>O(log n)</code>. It divides the search space in half at each step, leading to a logarithmic time complexity.</p></li></ul><ul id="cbc70f39-72b0-463a-ba00-d9466905e9f2" class="bulleted-list"><li style="list-style-type:disc"><strong>Best-case time complexity:</strong> <code>O(1)</code><p id="7cccbb31-f309-4873-b017-892bb2b61852" class="">The best-case scenario occurs when the target value is found at the middle of the sorted collection. In this case, Binary Search performs only one comparison and terminates, resulting in constant time complexity.</p></li></ul><h3 id="d0bc02cf-58c3-4aa3-b983-cca758477ef2" class=""><strong>Space Complexity of Binary Search</strong></h3><ul id="10860d44-c2ba-4d2f-8311-4e7b9c4998d3" class="bulleted-list"><li style="list-style-type:disc"><strong>Space complexity of Binary Search:</strong> <code>O(1)</code><p id="6a4b806f-caea-41cb-ac96-26634bb4fd9f" class="">Binary Search uses a constant amount of extra space to store variables for iteration and comparison, regardless of the size of the sorted collection. It does not require any additional space that grows with the input size.</p></li></ul><h2 id="2e863062-85c4-4489-ad73-acb183ade961" class="block-color-default"><mark class="highlight-red">How does Binary Searching help us?</mark></h2><p id="fe3185c2-3ae6-44c2-b5af-0811c1e613b9" class="">Binary search is a very useful algorithm in JavaScript for searching sorted arrays efficiently. Here are some ways binary search can help us in JavaScript:</p><ul id="534d29d0-b7a8-4b2f-a986-0389f41405f6" class="bulleted-list"><li style="list-style-type:disc"><strong>Faster searching:</strong> Binary search can be significantly faster than linear search for large datasets, especially when the data is sorted. This makes it an important algorithm for performance-critical JavaScript applications.</li></ul><ul id="a28043ae-5d61-4a98-90d4-a693efaef127" class="bulleted-list"><li style="list-style-type:disc"><strong>Smaller memory footprint:</strong> Binary search only requires a small amount of memory to execute, making it a good choice for resource-constrained environments such as mobile devices or embedded systems.</li></ul><ul id="2cbb04a2-710f-43a5-8cdf-66cf7e2a22cf" class="bulleted-list"><li style="list-style-type:disc"><strong>More efficient algorithms:</strong> Binary search is a fundamental building block for more advanced search algorithms such as interpolation search or exponential search. These algorithms use a similar strategy as binary search but are optimized for specific use cases.</li></ul><ul id="02d858a0-8cd5-46ea-b30a-85bf730d6611" class="bulleted-list"><li style="list-style-type:disc"><strong>Better user experience: </strong>Faster search times can lead to a better user experience in JavaScript applications such as search engines or e-commerce sites. Binary search can reduce the time it takes for users to find the information they are looking for.</li></ul><ul id="de52b3ff-328a-4aad-ba6a-cd9dfa393d46" class="bulleted-list"><li style="list-style-type:disc"><strong>Simplified code:</strong> Implementing binary search in JavaScript is relatively straightforward, especially with the availability of powerful array methods such as <code>Array.prototype.slice()</code> and <code>Array.prototype.splice()</code>. This makes the binary search a good choice for developers looking for a simple, efficient search algorithm for their JavaScript applications.</li></ul><p id="cc229314-162c-4c53-b370-eca997283c58" class="">Binary search is an important algorithm for efficient searching in JavaScript applications. By taking advantage of its speed, small memory footprint, and ease of implementation, developers can build fast and responsive applications that provide a great user experience.</p><h2 id="f88f7afa-3655-4e7b-9303-5197e0e53d59" class="block-color-default"><mark class="highlight-red">Drawbacks of Binary Search</mark></h2><p id="276e6131-59d3-48f4-a1ae-eb45224b2837" class="">Binary search is a widely used search algorithm that has its own set of advantages and drawbacks. Here are some of the main drawbacks of binary search:</p><ol type="1" id="8bc6c82c-ea2e-4575-8752-7ca8ff71ce55" class="numbered-list" start="1"><li><strong>Requires sorted data:</strong> Binary search requires the input data to be sorted in ascending or descending order. If the data is not sorted beforehand, binary search requires additional time and resources to sort the data, which can make the algorithm inefficient for certain applications.</li></ol><ol type="1" id="052afe70-a72c-4bfe-b0af-b9f8c8da29d6" class="numbered-list" start="2"><li><strong>Limited to single-value search:</strong> Binary search can only search for a single value at a time. It cannot search for multiple values or perform complex searches based on multiple criteria.</li></ol><ol type="1" id="7449f1ae-9897-4e1a-a82f-7863073dd3ee" class="numbered-list" start="3"><li><strong>Not suitable for large datasets: </strong>Binary search has a time complexity of O(log n), which is faster than linear search for large datasets. However, for very large datasets, binary search can still be slow and inefficient compared to other search algorithms such as hash tables or tree-based search algorithms.</li></ol><ol type="1" id="2f2d3f98-17ab-414a-aa6c-1c799df21d00" class="numbered-list" start="4"><li><strong>Limited to contiguous data structures: </strong>Binary search can only be used on contiguous data structures, such as arrays or linked lists. It cannot be used on non-contiguous structures such as trees or graphs.</li></ol><ol type="1" id="dc8aeeca-6fd9-488e-bdb9-efc32ebef795" class="numbered-list" start="5"><li><strong>Complexity:</strong> Binary search is a more complex algorithm to implement than linear search, especially for beginners. The algorithm requires an understanding of recursion and other programming concepts that may be unfamiliar to novice programmers.</li></ol><h2 id="0c00389e-edc5-40c8-90b2-60fb20d67811" class="block-color-red"><mark class="highlight-red">Real-Life Applications of Linear and Binary Search</mark></h2><ol type="1" id="d3741d13-ec4f-4194-be1d-7c672611a8e2" class="numbered-list" start="1"><li><strong>Binary Search for Sorted Data</strong>: Binary search is commonly used for large, sorted datasets where the search can be divided into halves, eliminating one-half at each iteration. For example, in a library catalog, a binary search algorithm can be used to find a specific book by dividing the search space into halves based on the book&#x27;s title, author, or other criteria.</li></ol><ol type="1" id="b4f70485-57ad-453c-9990-517e71e9ad63" class="numbered-list" start="2"><li><strong>Autocomplete and Search Suggestions</strong>: Linear search can be used to implement autocomplete or search suggestions in a user interface, where the algorithm searches through a list of suggestions and presents them to the user. For example, when a user starts typing a search query in a search box, the linear search algorithm can suggest matching keywords or phrases from a list of frequently searched terms.</li></ol><ol type="1" id="560fb841-e2c4-4f98-821f-9b8557a4d270" class="numbered-list" start="3"><li><strong>Duplicate Detection</strong>: Linear search can be used to detect duplicates in a list or database by comparing each item to every other item in the list. For example, in an e-commerce website, the linear search algorithm can detect duplicate product listings and merge them into a single listing.</li></ol><ol type="1" id="9534a870-6b63-4ed8-bf98-5618aa64f77a" class="numbered-list" start="4"><li><strong>Sorting and Indexing</strong>: Binary search can be used in sorting and indexing algorithms to search through large datasets efficiently. For example, in a database, binary search can be used to search for records within a specific range of values or to index records based on specific criteria such as date or location.</li></ol><ol type="1" id="7c035abc-8e7c-4adc-95bd-3615a3ae8fd2" class="numbered-list" start="5"><li><strong>Machine Learning</strong>: Searching algorithms are used in machine learning to find the best parameters for a given model. For example, in neural network models, the search algorithm is used to find the best weights for the neural network that produces the desired output.</li></ol><p id="a291cb08-035d-4e53-ba4a-2454ebd1e2eb" class="">
</p><h2 id="a477e31e-372f-4af0-a622-146927b0a56b" class="block-color-blue">Activity 1</h2><p id="5c9571e9-5743-4b46-ab9a-5d7cbe86771b" class=""><strong>Fill in the Blanks:</strong></p><ol type="1" id="7c43903a-d1b2-4e54-9c6b-206857562491" class="numbered-list" start="1"><li>The time complexity of the binary search algorithm is ________ <strong>( O(n)/O(1)/O(log n) )</strong>.</li></ol><ol type="1" id="53decb43-b5f3-4a29-b84c-825c4a7e6932" class="numbered-list" start="2"><li>The time complexity of the linear search algorithm is ________ <strong>( O(N)/O(log N)/O(1) )</strong>.</li></ol><ol type="1" id="55a417a5-5ea3-4a57-8b36-808cc850c75a" class="numbered-list" start="3"><li>In binary search, the search interval is adjusted based on whether the  _________ <strong>(first/last/middle)</strong> element is less than or greater than the target value. </li></ol><ol type="1" id="fe295a92-bac5-42c2-aa6e-152b27ea6b24" class="numbered-list" start="4"><li>The time complexity of linear search grows ___________ <strong>(exponentially/linearly/quadratically) </strong>with the size of the data set. In contrast, the time complexity of binary search grows logarithmically with the size of the data set.</li></ol><ul id="87cb7e82-a37c-415c-9b77-b03bb2f1e2e5" class="toggle"><li><details close=""><summary><strong>Solutions</strong></summary><ol type="1" id="07faacfa-e7af-49e3-8514-24cdb8250e4d" class="numbered-list" start="1"><li>(O(log n))</li></ol><ol type="1" id="9dbdebf4-6934-4995-9835-4dad02f9b374" class="numbered-list" start="2"><li>(O(N))</li></ol><ol type="1" id="2c3e2ecb-1b2a-48cd-b856-1af4d85e058c" class="numbered-list" start="3"><li>(middle)</li></ol><ol type="1" id="fb8e9b74-409e-4c31-bd5f-a7b2c360a125" class="numbered-list" start="4"><li>(linearly)</li></ol></details></li></ul><p id="2c5b50bd-912b-416a-b0eb-232be078fd11" class="">
</p><h2 id="d9ff7e1b-e9ae-4640-b786-0660151451af" class=""><mark class="highlight-red">Introduction to Hashmap</mark></h2><p id="4a37ae5d-ebc9-4348-966b-af2d9c88d74c" class="">A <strong>library catalog</strong> is a tool librarians use to organize and locate books within a library. Just like how a library catalog stores information about where a book is located in a library, a Hashmap in JavaScript stores key-value pairs.</p><p id="c768371a-61d0-4fe3-93ad-a7b284761d96" class="">Each book in the library has a unique identification number, known as the call number, that allows the librarian to locate it quickly. Similarly, each key in the Hashmap is unique and allows for quick retrieval of the corresponding value.</p><figure id="e9b23755-8946-411f-8dca-5317ce24d2bb" class="image"><a href="Introduction%20to%20Searching%20Algorithms%2030c23e4f591a446ab16ddfcbe120d9c7/Screenshot_2023-05-09_at_5.44.16_PM.png"><img style="width:2424px" src="Introduction%20to%20Searching%20Algorithms%2030c23e4f591a446ab16ddfcbe120d9c7/Screenshot_2023-05-09_at_5.44.16_PM.png"/></a></figure><p id="02f35e48-ef10-42af-bcdf-90de5f873c30" class="">When a new book is added to the library, the librarian assigns it a call number and records it in the catalog. Similarly, when a new key-value pair is added to the hashmap, JavaScript assigns it a unique identifier using a hash function and stores it in the hashmap.</p><p id="301e4c0a-9bb1-4996-bfc1-98e4fc3d55de" class="">Like how a library catalog allows for quick and efficient location of books within the library, a hashmap allows for quick and efficient retrieval of values based on their corresponding keys.</p><h3 id="84609482-8c09-47fe-ab2f-e7b5bb3512aa" class="block-color-default">What are Hashmaps?</h3><p id="17fed70b-ddb2-4501-8dde-09940be39d9b" class="">A hashmap is a collection of <strong>key-value pairs</strong> that allows you to <strong>store </strong>and<strong> retrieve data</strong> constantly, regardless of the collection size. Hashmaps are often used to implement <strong>associative arrays, dictionaries, </strong>and other data structures<strong>.</strong></p><figure id="2122a5ad-d6c2-4f1d-9ebe-08816320fd8a" class="image"><img style="width:2460px" src="Introduction%20to%20Searching%20Algorithms%2030c23e4f591a446ab16ddfcbe120d9c7/Screenshot_2023-05-09_at_5.45.11_PM.png"/></a></figure><p id="8039f961-a69b-4dce-a65d-7dc9514f7cda" class="">A hashmap in JavaScript is implemented using an <strong>object</strong>, a built-in data type in the language. The keys in the object are used to store and retrieve values, and the values themselves can be of any data type, including strings, numbers, arrays, and even other objects.</p><p id="d07565b2-f8eb-4a7d-bb6e-32434952fcd4" class="">
</p><blockquote id="aabc329a-6c99-48ea-ae8e-533a587c74bd" class="">Hashmaps can be used in JavaScript to store and retrieve key-value pairs efficiently. While JavaScript does not have a built-in Hashmap data structure, you can create a Hashmap by using an object as a key-value store and generating unique keys for each value using a hash function.</blockquote><h3 id="438695ac-c18f-4b45-9651-339bce7d3069" class="">Working of Hashmap</h3><ol type="1" id="a423a634-2a25-40ed-9df7-73bd132ff314" class="numbered-list" start="1"><li><strong>Initialize an Empty Hashmap</strong>: To create a hashmap in JavaScript, you can use the <code>Map</code> object or utilize objects as key-value pairs.</li></ol><ol type="1" id="38c1b1b1-b300-4202-a2fa-5760852f7a32" class="numbered-list" start="2"><li><strong>Hashing the Key</strong>: When inserting a key-value pair into the hashmap, the key is hashed using a hashing function. The hashing function converts the key into a unique numeric value, known as the hash code. The hash code determines the index or bucket where the key-value pair will be stored.</li></ol><ol type="1" id="55db4298-9c95-4d98-ad23-2640f2c0c652" class="numbered-list" start="3"><li><strong>Store the Key-Value Pair</strong>: Using the hash code, the key-value pair is stored in the corresponding bucket or location in the hashmap. JavaScript&#x27;s <code>Map</code> object automatically handles this process, while with objects, the hash code is typically used as a property name to store the value.</li></ol><ol type="1" id="46c204a3-e6cd-422e-8612-24c64c4c2a31" class="numbered-list" start="4"><li><strong>Retrieve a Value</strong>: To retrieve a value from the hashmap, the key is hashed again to obtain the hash code. Using the hash code, the hashmap locates the bucket or property associated with the key and returns the corresponding value.</li></ol><ol type="1" id="502d3c7d-abeb-4f39-8bde-6018f7ada9c7" class="numbered-list" start="5"><li><strong>Update or Remove a Value</strong>: To update or remove a value, the process is similar to retrieval. The key is hashed to find the corresponding bucket or property, and the value is updated or removed accordingly.</li></ol><ol type="1" id="3dd717ef-5d86-451b-9883-9abc7c858951" class="numbered-list" start="6"><li><strong>Handling Collisions</strong>: Collisions occur when different keys produce the same hash code. To handle collisions, the hashmap employs various techniques such as chaining (using linked lists or arrays within the buckets to store multiple key-value pairs with the same hash code) or open addressing (finding an alternative empty location within the hashmap to store the colliding key-value pair).</li></ol><ol type="1" id="bd00ca58-b10b-49e4-8f77-2689c9c869a5" class="numbered-list" start="7"><li><strong>Resize and Rehash</strong>: As the number of key-value pairs in the hashmap grows, the hashmap may need to be resized to maintain efficient performance. Resizing involves creating a larger array or allocating additional memory space and rehashing all the key-value pairs to distribute them across the new buckets.</li></ol><p id="a294eb21-9d2b-4fe1-8ea4-149e76974650" class="">
</p><p id="f5d3f19c-9bc1-425e-8577-a3ee41cde36c" class="">To add a key-value pair to a hashmap in JavaScript, you can assign a value to a property of the object using the key as the property name. </p><p id="d1a6c022-0d9c-458a-ad15-eedda62aba62" class=""><strong>For example:</strong></p><pre id="c062cc3e-4aaa-43a2-b6df-808df948f9bc" class="code code-wrap"><code>const hashmap = {}; 
hashmap[&#x27;key1&#x27;] = &#x27;Arithmetic Operators&#x27;; 
hashmap[&#x27;key2&#x27;] = &#x27;Logical Operators&#x27;;
hashmap[&#x27;key3&#x27;] = &#x27;Comparison Operators&#x27;;
hashmap[&#x27;key4&#x27;] = &#x27;Bitwise Operators&#x27;;</code></pre><p id="c9353586-72fa-42b4-b0cb-34b415d850f3" class="">In this example, we create a hashmap empty object and add two key-value pairs using bracket notation. The keys are strings, and the values are also strings, but they could be any data type.</p><figure id="f6e54dc6-09e6-4a83-a46c-ca25ebf80b85" class="image"><img style="width:2474px" src="Introduction%20to%20Searching%20Algorithms%2030c23e4f591a446ab16ddfcbe120d9c7/Screenshot_2023-05-09_at_5.45.45_PM.png"/></a></figure><p id="10b2fe1a-653a-431c-816a-b6e2e62b88a2" class="">To retrieve a value from the hashmap, you can use the same bracket notation to access the property by its key:</p><pre id="e48f2329-1bda-4ec8-9c61-174138ce337d" class="code code-wrap"><code>console.log(hashmap[&#x27;key1&#x27;]); // output: &#x27;Arithmetic Operators&#x27;</code></pre><p id="32e2fe09-f586-4bb5-bc66-89b9f413c0b2" class="">If the key does not exist in the hashmap, attempting to retrieve its value will return <code>undefined</code>.</p><h3 id="dde2fe0b-49bc-4dbb-9a94-0353f10d4b0a" class="block-color-default">Implementation of Hashmap</h3><pre id="e12651b7-b840-493d-9b0f-c45228132819" class="code"><code>// Hashmap implementation using objects
class HashMap {
  constructor() {
    this.map = {}; // Object to store key-value pairs
  }

  // Insert a key-value pair into the hashmap
  insert(key, value) {
    this.map[key] = value;
  }

  // Retrieve the value associated with a given key
  get(key) {
    return this.map[key];
  }

  // Remove a key-value pair from the hashmap
  remove(key) {
    delete this.map[key];
  }

  // Check if a key exists in the hashmap
  contains(key) {
    return key in this.map;
  }

  // Get the number of key-value pairs in the hashmap
  size() {
    return Object.keys(this.map).length;
  }

  // Get all keys in the hashmap
  keys() {
    return Object.keys(this.map);
  }

  // Get all values in the hashmap
  values() {
    return Object.values(this.map);
  }
}

// Usage example
const myHashMap = new HashMap();

myHashMap.insert(&quot;name&quot;, &quot;John&quot;);
myHashMap.insert(&quot;age&quot;, 30);

console.log(myHashMap.get(&quot;name&quot;)); // Output: John
console.log(myHashMap.contains(&quot;age&quot;)); // Output: true

myHashMap.remove(&quot;age&quot;);
console.log(myHashMap.size()); // Output: 1
console.log(myHashMap.keys()); // Output: [ &#x27;name&#x27; ]
console.log(myHashMap.values()); // Output: [ &#x27;John&#x27; ]</code></pre><ul id="4dd9b525-003e-4e80-822e-b3e317d7b09b" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="8ded7e23-dbf0-47ed-b243-953d30ee2eb1" class="numbered-list" start="1"><li>The <code>HashMap</code> class is defined with a constructor that initializes an empty object (<code>this.map</code>) to store key-value pairs.</li></ol><ol type="1" id="f4c5d09d-2250-4469-b3ae-0221bf1c7a20" class="numbered-list" start="2"><li>The <code>insert</code> method takes a <code>key</code> and a <code>value</code> as parameters and assigns the <code>value</code> to the <code>key</code> in the <code>map</code> object. This is done by using the <code>key</code> as a property name and assigning the <code>value</code> to that property.</li></ol><ol type="1" id="0eba11ba-0788-40a1-a7a2-313de3b80aaf" class="numbered-list" start="3"><li>The <code>get</code> method takes a <code>key</code> as a parameter and returns the corresponding value from the <code>map</code> object by accessing the property with that <code>key</code>.</li></ol><ol type="1" id="2c9f0738-d774-4d0e-a725-c7474f902919" class="numbered-list" start="4"><li>The <code>remove</code> method takes a <code>key</code> as a parameter and removes the key-value pair from the <code>map</code> object using the <code>delete</code> operator.</li></ol><ol type="1" id="dc480e41-a584-42db-aeb4-b655f3310ec2" class="numbered-list" start="5"><li>The <code>contains</code> method takes a <code>key</code> as a parameter and checks if the <code>key</code> exists in the <code>map</code> object. It returns <code>true</code> if the <code>key</code> is present as a property in the <code>map</code> object and <code>false</code> otherwise.</li></ol><ol type="1" id="518bb524-565d-47cf-9bd1-82567130b24f" class="numbered-list" start="6"><li>The <code>size</code> method returns the number of key-value pairs in the <code>map</code> object by using <code>Object.keys(this.map).length</code>, which returns an array of keys and retrieves its length.</li></ol><ol type="1" id="d660000a-3232-4eea-8ea7-dc26dc194f72" class="numbered-list" start="7"><li>The <code>keys</code> method returns an array of all the keys in the <code>map</code> object by using <code>Object.keys(this.map)</code>.</li></ol><ol type="1" id="8235cb4e-5314-42b9-a8b7-840f87e09862" class="numbered-list" start="8"><li>The <code>values</code> method returns an array of all the values in the <code>map</code> object by using <code>Object.values(this.map)</code>.</li></ol></details></li></ul><p id="5539063a-fb76-466d-9d7f-c7dfcf1935ff" class="">
</p><h2 id="1c3bd0ca-2b50-4c7d-8064-eae7905c77f5" class="block-color-default"><mark class="highlight-blue">Activity 2</mark></h2><ol type="1" id="68481096-e273-4857-9808-98447421a067" class="numbered-list" start="1"><li><strong>Agree/Disagree</strong><ol type="a" id="3f17b0c7-ddd8-4d56-9b02-bc867a7411bf" class="numbered-list" start="1"><li>Does the hashmap approach&#x27;s time complexity depend on the input array&#x27;s size?</li></ol><ol type="a" id="940706df-a56a-4336-8396-e502e39dbb0f" class="numbered-list" start="2"><li>Do hashmaps provide constant-time access to values, regardless of the collection size? </li></ol><ol type="a" id="6fa906b4-c761-470e-ad0c-2ede9d312cca" class="numbered-list" start="3"><li>Is it necessary to use linked lists to store key-value pairs in a hashmap? </li></ol><ol type="a" id="d93737e5-6ccb-4bec-a630-6375b360b544" class="numbered-list" start="4"><li>Can hashmaps be used to encrypt sensitive data in a web application? </li></ol></li></ol><ol type="1" id="44ef88f8-3839-46b8-bd3d-418a34c0a6d2" class="numbered-list" start="2"><li><strong>True or False:</strong><ol type="a" id="2c2aae6e-e7cd-4197-9c89-96bf7e82c18d" class="numbered-list" start="1"><li>A hashmap is used to organize and locate books within a library. </li></ol><ol type="a" id="de0f7df6-511a-4ced-8a37-b557944a8351" class="numbered-list" start="2"><li>JavaScript has a built-in Hashmap data structure. </li></ol><ol type="a" id="10cb21a1-856b-403d-b4ae-b43c867c0940" class="numbered-list" start="3"><li>The keys in a Map object can be of any data type, including objects and functions.</li></ol><ol type="a" id="ed867db2-4f82-4bb0-9205-f7943f80b62a" class="numbered-list" start="4"><li>A hash table&#x27;s efficiency depends on the hash function&#x27;s quality and the strategy used to handle collisions. </li></ol></li></ol><ul id="3447a5e3-e6d7-40b5-9b49-ff34f58a8030" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><ol type="1" id="81211285-bfaa-4db2-a195-2f60c1ab6dff" class="numbered-list" start="1"><li><ol type="a" id="fda36ef3-4241-49ce-86ca-b312b41a81a7" class="numbered-list" start="1"><li>Agree</li></ol><ol type="a" id="bed5e00f-f78c-4571-aa52-97ad222a78ab" class="numbered-list" start="2"><li>Agree</li></ol><ol type="a" id="88460259-f509-4b2b-8304-5a018abf136c" class="numbered-list" start="3"><li>Disagree</li></ol><ol type="a" id="3647f269-d966-4547-9622-4a51cb1c877a" class="numbered-list" start="4"><li>Disagree</li></ol></li></ol><ol type="1" id="4688f67e-0e45-4109-940b-c5a00056e614" class="numbered-list" start="2"><li><ol type="a" id="2d6f08ac-77c2-4607-9163-3b32fc148a4c" class="numbered-list" start="1"><li>True</li></ol><ol type="a" id="27353a89-48b1-4ec8-b655-7e3890761d9a" class="numbered-list" start="2"><li>False</li></ol><ol type="a" id="86a9e5c8-036a-4c0d-afef-081bb84a31c2" class="numbered-list" start="3"><li>True</li></ol><ol type="a" id="31c04a57-1804-481d-9fd9-877a47657e94" class="numbered-list" start="4"><li>True</li></ol></li></ol></details></li></ul><p id="d44d6f54-8224-4581-892d-f1e906c583e1" class="">
</p><h2 id="b951f617-1af4-485f-b9dc-2fad3fdb2743" class=""><mark class="highlight-red">Time Complexity of Hashmaps</mark></h2><p id="3ea9f574-949c-4f76-8fe5-570ec311c742" class="">Let’s take a problem statement that can be solved with two approaches, and at the end, we’ll analyze that time complexity.</p><p id="e7ef3e40-4f13-4381-88fb-8f4db0732487" class=""><strong>Problem</strong></p><p id="450d317b-eaf3-458a-a44a-16f626cff914" class="">Given an array of integers, find two numbers that add up to a target number.</p><figure id="4d0f8b89-5323-456e-ab37-be1b96cef4c0" class="image"><img style="width:2350px" src="Introduction%20to%20Searching%20Algorithms%2030c23e4f591a446ab16ddfcbe120d9c7/Screenshot_2023-05-09_at_5.46.58_PM.png"/></a></figure><p id="9e8684f6-89cb-4d16-acba-0341acececaa" class="block-color-default"><strong>Using Traditional Approach:</strong></p><pre id="471e14f0-03c0-4de7-b76b-1702a8d598cc" class="code"><code>function twoSum(nums, target) {
  for (let i = 0; i &lt; nums.length; i++) {
    for (let j = i + 1; j &lt; nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }

  return null;
}

let nums = [4, 2, 5, 17, 9];
let target = 11;
let result = twoSum(nums, target);
console.log(result); // [1, 4]</code></pre><ul id="7789f450-5e3c-4a32-b9a1-c1798b2c351d" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="4299741b-51ee-4ed4-976a-d0ea6f8e2f98" class="numbered-list" start="1"><li>The code uses two nested <code>for</code> loops to iterate through all possible pairs of elements in the <code>nums</code> array.</li></ol><ol type="1" id="94163599-c43d-4643-9639-b59eb52a8d42" class="numbered-list" start="2"><li>The outer loop iterates over each element from the beginning to the second-to-last element. It uses the variable <code>i</code> to represent the index of the first element in the pair.</li></ol><ol type="1" id="f2a53310-e07f-40fd-99e9-2b498f44f63d" class="numbered-list" start="3"><li>The inner loop iterates over each element following the element represented by <code>i</code>. It uses the variable <code>j</code> to represent the index of the second element in the pair. The inner loop starts from <code>i + 1</code> to avoid considering the same pair multiple times and unnecessary duplicate calculations.</li></ol><ol type="1" id="76971b09-73a5-45c1-8d03-e003659726d2" class="numbered-list" start="4"><li>For each pair of elements, the code checks if their sum equals the target value: <code>if (nums[i] + nums[j] === target)</code>. If it does, it means that the pair of elements satisfies the condition, and the code returns an array containing the indices <code>[i, j]</code>.</li></ol><ol type="1" id="d765c8e9-d514-4c19-bd3c-52f4054d7de6" class="numbered-list" start="5"><li>If no pair is found after checking all possible combinations, the code returns <code>null</code> to indicate that no solution was found.</li></ol></details></li></ul><p id="28bcef98-76c1-499c-a451-c38ccb6080bd" class="">he time complexity of this algorithm is <code>O(n^2)</code>, where n is the number of elements in the <code>nums</code> array. This is because the code uses two nested loops that iterate over the entire array. For each element, the inner loop iterates over the remaining elements. As a result, the number of iterations is roughly proportional to <strong>n * (n-1) / 2</strong>, which simplifies to <code>O(n^2)</code> in Big O notation. Therefore, the time complexity is <code>O(n^2)</code>.</p><p id="4ba33c6e-3b62-4e67-8f0b-7c7b6b59074f" class="">
</p><p id="1072a643-32ef-4187-a16b-fe9cdc49ac79" class="block-color-default"><strong>Using Hashmap: </strong></p><pre id="4eafdf0f-b75b-4b80-963c-4d71c938a928" class="code"><code>function twoSum(nums, target) {
  const map = new Map();

  for (let i = 0; i &lt; nums.length; i++) {
    const complement = target - nums[i];
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    map.set(nums[i], i);
  }

  return null;
}

let nums = [4, 2, 5, 17, 9];
let target = 11;
let result = twoSum(nums, target);
console.log(result); // [1, 4]</code></pre><ul id="4b4fe55b-62c0-4d42-a6af-bf2b8384a9bd" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="10b9deff-06e6-453f-a2ba-601f8e7d3ecc" class="numbered-list" start="1"><li>A <code>Map</code> data structure is created to store the array elements and their indices. The map will allow efficient lookups to find the complement of each element later on.</li></ol><ol type="1" id="f081d6df-8281-45bd-b04c-9eb668493985" class="numbered-list" start="2"><li>The code iterates through the <code>nums</code> array using a <code>for</code> loop.</li></ol><ol type="1" id="99853e3d-ba14-4e35-a135-a653aaea19bf" class="numbered-list" start="3"><li>For each element, it calculates the complement by subtracting the current element from the target: <code>const complement = target - nums[i];</code></li></ol><ol type="1" id="350af315-ad71-4a77-b855-7f01f4c33d5b" class="numbered-list" start="4"><li>It then checks if the complement is present in the map using the <code>has</code> method: <code>if (map.has(complement))</code>. If it is, that means we have found the two elements that sum up to the target.</li></ol><ol type="1" id="6585ec85-b39d-40d3-8426-672721c5dec9" class="numbered-list" start="5"><li>If the complement is found in the map, the code returns an array containing the indices of the complement and the current element: <code>[map.get(complement), i]</code>.</li></ol><ol type="1" id="17b10aa2-794e-4a16-a981-59a7b1b982b7" class="numbered-list" start="6"><li>If the complement is not found in the map, the code adds the current element and its index to the map using the <code>set</code> method: <code>map.set(nums[i], i)</code>.</li></ol><ol type="1" id="28a0fcfd-e0d6-494b-b5ff-a2e1aa2dfffe" class="numbered-list" start="7"><li>If the loop finishes without finding a valid pair, it returns <code>null</code> to indicate that no solution was found.</li></ol></details></li></ul><p id="e3338e3c-9604-4893-a61f-42d4cfb2e4c4" class="">The time complexity of this algorithm is O(n), where n is the number of elements in the <code>nums</code> array. This is because the code only needs to iterate through the array once to find the desired pair of numbers. The map operations (insertion, deletion, and lookup) have an average time complexity of <code>O(1)</code> since they are implemented using a hash table. Therefore, the overall time complexity is dominated by the single loop, resulting in a linear time complexity of <code>O(n)</code>.</p><h2 id="0ab84d5d-4895-4c05-b393-97e27efaa19a" class=""><mark class="highlight-red">Where to use Hashmaps?</mark></h2><p id="8d4bfd89-f873-4977-92d7-0db09548861c" class="">Hashmaps are a fundamental data structure in computer science and are widely used in various programming languages, including JavaScript.</p><p id="3d740f79-7aca-4efc-9524-ea9b54232378" class="">In JavaScript, hashmaps are implemented using objects, and they are an important data structure for storing and retrieving key-value pairs efficiently.</p><ol type="1" id="dc511796-6099-4997-bf7f-bb0de43a61e8" class="numbered-list" start="1"><li><strong>Caching data:</strong> Hash tables can be used to cache data in memory, which can significantly improve the performance of web applications. <p id="25e8729c-0c47-44d7-bdcb-b84b20f88355" class="">For example, you could use a hash table to cache the results of expensive database queries so that subsequent requests for the same data can be served quickly from memory.</p></li></ol><ol type="1" id="fcac8a52-9d81-4445-9780-728cb4d68ebb" class="numbered-list" start="2"><li><strong>Counting occurrences:</strong> Hash tables can be used to count the occurrences of elements in an array. <p id="9210e2b6-f25b-4db8-86dd-4f02e9c59753" class="">For example, you could use a hash table to count the number of times each word appears in a text document or to count the frequency of each character in a string.</p></li></ol><ol type="1" id="6c50ab30-73e5-441a-a428-eca4594f531d" class="numbered-list" start="3"><li><strong>Storing user sessions:</strong> Hash maps can be used to store user sessions in memory.<p id="361c3328-b299-4a36-b652-34fb9251b482" class="">When a user logs in to a web application, a hash map can be used to store the user&#x27;s session ID and any associated data, such as their name, email, and preferences.</p></li></ol><ol type="1" id="38714af9-dce9-4293-afdc-e820dfa2e13f" class="numbered-list" start="4"><li><strong>Storing configuration data:</strong> Hash maps can be used to store configuration data for a web application. <p id="71fe3f18-d459-4443-a6d7-48e7dc720a08" class="">For example, you could use a hash map to store the database connection string, the SMTP server details, and other settings that are used throughout the application.</p></li></ol><ol type="1" id="a2dd90c3-45c9-4642-98ee-672afe824ae6" class="numbered-list" start="5"><li><strong>Implementing memoization:</strong> Memoization is a technique used to speed up the execution of functions by caching the results of expensive function calls. Hash tables can be used to implement memoization in JavaScript. <p id="428d3cf3-cdb6-4363-985c-8c9f3ce7e6cf" class="">By storing the input arguments and their corresponding output values in a hash table, the function can quickly retrieve the cached result for any previously seen input.</p></li></ol><p id="824b9ae8-2a0a-46a0-8032-fd96b91c176d" class="">
</p><h2 id="920f5af8-3931-464f-b9a2-9fe135dafad1" class="block-color-default"><mark class="highlight-blue">Explore Further</mark></h2><p id="d582b593-0145-4623-8227-d3a6f0c3a53e" class=""><mark class="highlight-orange"><strong>Uncover and unlock new insights as you dive into the captivating content found in the provided link.</strong></mark></p><p id="c76756cc-8d07-4ae7-8a6c-f62b3b7e5301" class=""><strong>SHA-1, SHA-2 and SHA-256 Hash Algorithms: </strong><a href="https://www.thesslstore.com/blog/difference-sha-1-sha-2-sha-256-hash-algorithms/">https://www.thesslstore.com/blog/difference-sha-1-sha-2-sha-256-hash-algorithms/</a></p><p id="2f144821-f8d3-4740-97d2-bf70b89c604b" class="">
</p><p id="1b500fc7-bc0b-4495-9ed3-84807c844204" class=""><mark class="highlight-orange"><strong>Tackle these questions head-on!</strong></mark></p><p id="f4e18361-5a30-40d0-9cf7-999a1b0462b0" class=""><strong>Guess the word</strong></p><ol type="1" id="4dddca18-d6f4-4c62-aa6d-0da06fbfd2bb" class="numbered-list" start="1"><li>What do the initials &quot;SHA&quot; stand for?</li></ol><ol type="1" id="6d169c4a-5d70-448b-bc66-9d4a32aee910" class="numbered-list" start="2"><li>What is the most popular bit-length for SHA-2?</li></ol><ol type="1" id="53bb44c5-50f5-4621-a873-054082647476" class="numbered-list" start="3"><li>What is the term used to describe two different values producing the same hash?</li></ol><ol type="1" id="271cc834-dbf2-43c1-9e1b-96fce1898ffb" class="numbered-list" start="4"><li>Which algorithm did the SSL industry transition to in 2015?</li></ol><ul id="285630c0-56bc-4a69-a7fd-e2bb5e007df9" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><ol type="1" id="691ccbc4-7edd-4b01-8317-4de1ed1a3cf8" class="numbered-list" start="1"><li>Secure Hashing Algorithm</li></ol><ol type="1" id="a217307c-8d8a-40a6-8c6b-f567bc2df5e5" class="numbered-list" start="2"><li>256-bit</li></ol><ol type="1" id="73fc75ed-a7a2-49a9-b552-1da8066decaa" class="numbered-list" start="3"><li>Collision</li></ol><ol type="1" id="d5a049c8-4e74-44a0-bcf6-59f3d0286606" class="numbered-list" start="4"><li>SHA-2</li></ol></details></li></ul><p id="5e904214-6640-4e76-9425-da630bf7043e" class="">
</p><h1 id="4632ddfc-ab12-4398-b88d-f79eb2d181db" class=""><mark class="highlight-brown">Summary</mark></h1><h2 id="1e1d14bd-2be4-4bf0-af25-7bca713fe008" class="block-color-default"><mark class="highlight-red">What did we learn?</mark></h2><ul id="34933228-662b-4fc7-89e3-639f43f2befc" class="bulleted-list"><li style="list-style-type:disc">Linear search is a simple algorithm that sequentially checks each element in a dataset until the desired element is found. It is efficient for small datasets but can become slow and inefficient for larger datasets.</li></ul><ul id="81fad5ac-7b29-4e7b-b9df-0167f03799d8" class="bulleted-list"><li style="list-style-type:disc">Binary search is a more advanced algorithm that utilizes a divide-and-conquer approach to search for the desired element. It works by repeatedly dividing the dataset in half and eliminating the half that does not contain the desired element. </li></ul><ul id="abb6a305-73c8-426e-88de-731c5c1dbbb5" class="bulleted-list"><li style="list-style-type:disc">In JavaScript, the linear search can be implemented using a simple for loop that iterates through each element in the dataset. In contrast, binary search can be implemented recursively or iteratively using the divide-and-conquer approach.</li></ul><ul id="c10c3caa-ba2d-4d67-b398-e4b7ddc91e83" class="bulleted-list"><li style="list-style-type:disc">Understanding the time complexity of linear and binary search algorithms is important for choosing the right algorithm for a given dataset. Linear search has a time complexity of O(n), while binary search has a time complexity of O(log n).</li></ul><ul id="791ca09c-cba5-4a6a-bffa-42c06e435561" class="bulleted-list"><li style="list-style-type:disc">Mastering linear and binary search algorithms in JavaScript is essential for any programmer looking to improve their problem-solving skills and write more efficient and optimized code.</li></ul><ul id="5136c507-2000-4279-8dfe-876a9d2c66a8" class="bulleted-list"><li style="list-style-type:disc">A hashmap is a data structure consisting of key-value pairs that can be accessed constantly. It is implemented in JavaScript using an object and is useful for implementing associative arrays and other data structures. </li></ul><ul id="d75bf5c0-daf7-4ad7-a077-9e02d92ba8fe" class="bulleted-list"><li style="list-style-type:disc">Hash tables are similar to hashmaps but are typically implemented using an array. The main advantage of using a hashmap is its constant-time access to values. </li></ul><ul id="36e464aa-2aad-4eef-b2ba-d3409ea12e9c" class="bulleted-list"><li style="list-style-type:disc">The time complexity of a hashmap is O(1) for insertion, deletion, and retrieval operations.</li></ul><h2 id="a5158212-8a98-4c05-8eeb-d57a72627f4c" class=""><mark class="highlight-red">Shortcomings &amp; Challenges</mark></h2><ul id="9bc35356-57db-4f34-b6b7-51852599808a" class="bulleted-list"><li style="list-style-type:disc">Linear search can become slow and inefficient for larger datasets. This is because it has a time complexity of O(n), where n is the size of the dataset. Therefore, it is not recommended to use linear search for large datasets.</li></ul><ul id="47435144-19e4-43d3-8c7a-67b03d3d6f6a" class="bulleted-list"><li style="list-style-type:disc">Both linear search and binary search algorithms can be memory-intensive, especially if the dataset is very large. This can lead to performance issues and slow down the program&#x27;s overall operation.</li></ul><ul id="1a3660d1-6c36-43dc-92b3-19366ec1076a" class="bulleted-list"><li style="list-style-type:disc">Hashmaps can also experience collisions, where multiple keys may hash to the same index, impacting performance. </li></ul><ul id="3dac30c6-df16-495f-8f61-de863469ec8c" class="bulleted-list"><li style="list-style-type:disc">Hash tables can experience degraded performance as the number of elements grows and collisions become more frequent.</li></ul><h2 id="09501172-7d0f-4ceb-8731-a5dfbb6ccc0d" class="block-color-default"><mark class="highlight-red">Best Practices</mark></h2><ul id="9a2b54b0-56dd-4257-8017-b70522cdd80f" class="bulleted-list"><li style="list-style-type:disc">Linear search is efficient for small datasets, while binary search is more efficient for larger datasets. Always choose the appropriate algorithm based on the size and characteristics of the dataset.</li></ul><ul id="0ba32992-0977-4ae9-a0b4-f3ceb57203d3" class="bulleted-list"><li style="list-style-type:disc">When implementing the algorithms, always consider ways to optimize the code for performance. This includes reducing unnecessary loops or function calls, avoiding duplicate code, and using efficient data structures.</li></ul><ul id="d0b64fa0-3f57-46be-a2d8-284ed2e1c0a0" class="bulleted-list"><li style="list-style-type:disc">Test and debug thoroughly: Test the implementation of the algorithms with different datasets to ensure that they are working as expected. Debug any errors that are encountered during testing to ensure that the algorithms are functioning properly.</li></ul><ul id="49e7d858-9acf-4401-b895-2803853ab230" class="bulleted-list"><li style="list-style-type:disc">Be mindful of potential collisions, where multiple keys may hash to the same index, and implement a strategy to handle them, such as chaining or open addressing.</li></ul><ul id="1d016622-72e4-4aff-9c31-704405a775b3" class="bulleted-list"><li style="list-style-type:disc">Consider the size of the hashmap when initializing it, as having too many or too few buckets can affect performance.</li></ul><ul id="991706bf-7ddb-438f-b8e2-490fd3b2011b" class="bulleted-list"><li style="list-style-type:disc">Avoid modifying the keys of the hashmap after they have been added, as this can cause issues with accessing and retrieving values.</li></ul><h2 id="4c782b6d-210a-41d0-aa0f-64fc0f06d6d7" class="block-color-default"><mark class="highlight-red">Enhance Your Knowledge</mark></h2><ul id="1063f5cd-8307-4f69-b9b0-468b1f9bfe30" class="bulleted-list"><li style="list-style-type:disc"><a href="https://github.com/trekhleb/javascript-algorithms/">https://github.com/trekhleb/javascript-algorithms/</a></li></ul><ul id="99442437-d0c5-4414-80c3-b9c1259aeeed" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.freecodecamp.org/news/javascript-hash-table-associative-array-hashing-in-js/">https://www.freecodecamp.org/news/javascript-hash-table-associative-array-hashing-in-js/</a></li></ul><p id="e542b9f6-9cc9-4740-92d0-74087ed2f534" class="">
</p><p id="94e363b0-9039-4e03-962b-0d17431b9cbd" class="">
</p></div></article></body></html>
