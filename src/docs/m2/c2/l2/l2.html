<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Advanced Sorting Algorithms </title><link rel="stylesheet" href="../../../../../styles.css"></head><body><article id="2ad8c01b-6c01-423a-9837-eb201e06b6db" class="page sans"><header><h1 class="page-title">Advanced Sorting Algorithms </h1><p class="page-description"></p></header><div class="page-body"><ul id="2420e4dc-5161-4b3e-b3a5-ca837951e69d" class="toggle"><li><details close=""><summary><strong>Session Flow (5 minutes read)</strong></summary><ul id="a8663b99-b733-4364-af6d-e86b2ad87215" class="bulleted-list"><li style="list-style-type:disc"><strong>Learning Objective (5 minutes read)</strong><ul id="c292fea2-e69a-4a9c-b0a0-67c0505143ed" class="bulleted-list"><li style="list-style-type:circle">Introduction</li></ul><ul id="f71fc41d-108f-4d82-9588-bdc729e6f6b8" class="bulleted-list"><li style="list-style-type:circle">Theme</li></ul><ul id="ee391eb7-df92-4805-8135-e8bfecdaf32e" class="bulleted-list"><li style="list-style-type:circle">Primary Goals</li></ul></li></ul><ul id="717c3c18-26e1-4dda-a757-2377c0809369" class="bulleted-list"><li style="list-style-type:disc"><strong>Advanced Sorting Algorithms (120 minutes read)</strong><ul id="05116d9b-90d4-42b0-aa7a-cf5187ee7af5" class="bulleted-list"><li style="list-style-type:circle">Introduction to Heap Sort<ul id="ff59c0c8-482f-4b88-9b2e-a2bb902f721e" class="bulleted-list"><li style="list-style-type:square">Working of Heap Sort</li></ul><ul id="0821f43f-fabb-423e-bcfa-9de3ef674fb7" class="bulleted-list"><li style="list-style-type:square">Implementation of Heap Sort</li></ul><ul id="a877acca-34f5-4573-955f-2e9d4f5dbf3e" class="bulleted-list"><li style="list-style-type:square">Time complexity of Heap Sort</li></ul><ul id="a1b7d624-7544-4df2-a8b6-ee6437da2294" class="bulleted-list"><li style="list-style-type:square">Space Complexity of Heap Sort</li></ul></li></ul><ul id="85f308e4-e8cb-4e65-8621-4fa0de71c6a6" class="bulleted-list"><li style="list-style-type:circle"><strong>Do it yourself</strong></li></ul><ul id="f77ec454-5298-40e9-bd96-f3d89f105b0c" class="bulleted-list"><li style="list-style-type:circle">Introduction to Bucket Sort<ul id="238ab1ff-4fdc-4c0a-a8dd-b04e3238c42c" class="bulleted-list"><li style="list-style-type:square">Working of Bucket Sort</li></ul><ul id="b9380d91-f99f-4eb4-b88d-c6e42496330f" class="bulleted-list"><li style="list-style-type:square">Implementation of Bucket Sort</li></ul><ul id="d4d00c0d-a519-4dd5-beb9-2bc4fc1e7fbb" class="bulleted-list"><li style="list-style-type:square">Time complexity of Bucket Sort</li></ul><ul id="5ac9ec0a-1fa5-443a-b455-0bd9a9f23a43" class="bulleted-list"><li style="list-style-type:square">Space Complexity of Bucket Sort</li></ul></li></ul><ul id="9371ce3c-6e3e-4922-b843-6e29aa3d560c" class="bulleted-list"><li style="list-style-type:circle">Introduction to Radix Sort<ul id="2ab06aab-5610-4e12-bb53-230c2b036994" class="bulleted-list"><li style="list-style-type:square">Working of Radix Sort</li></ul><ul id="dd6a4b14-8f8f-4593-af22-eaf674fdb131" class="bulleted-list"><li style="list-style-type:square">Implementation of Radix Sort</li></ul><ul id="ba1c6c20-7801-4f23-bacd-c253c2a67cba" class="bulleted-list"><li style="list-style-type:square">Time complexity of Radix Sort</li></ul><ul id="df17ea6d-7acb-4543-8ca9-154fe051f5b1" class="bulleted-list"><li style="list-style-type:square">Space Complexity of Radix Sort</li></ul></li></ul><ul id="1f483fc6-f446-424c-9555-14b5258c87ed" class="bulleted-list"><li style="list-style-type:circle"><strong>Activity 1</strong></li></ul><ul id="d86bc0cc-55c6-49a6-a1e3-ced6e658b2f2" class="bulleted-list"><li style="list-style-type:circle">Introduction to Counting Sort<ul id="6b768197-aa52-45da-8b67-e0c449fc4caa" class="bulleted-list"><li style="list-style-type:square">Working of Counting Sort</li></ul><ul id="f31d0f8a-f94c-4c48-879b-e9c08744b862" class="bulleted-list"><li style="list-style-type:square">Implementation of Counting Sort</li></ul><ul id="b0107927-a458-4010-9e47-e112337b010e" class="bulleted-list"><li style="list-style-type:square">Time complexity of Counting Sort</li></ul><ul id="42995dc6-1fa5-442e-89ba-c90e15ecfecb" class="bulleted-list"><li style="list-style-type:square">Space Complexity of Counting Sort</li></ul></li></ul><ul id="521dac9b-f8c7-4a73-aa76-65e3c285f821" class="bulleted-list"><li style="list-style-type:circle"><strong>Explore Further</strong></li></ul></li></ul><ul id="d2683c0e-3364-4e1e-8f3d-541882f940a6" class="bulleted-list"><li style="list-style-type:disc"><strong>Summary (10 minutes read)</strong><ul id="2494e3bc-5d36-46e9-98b3-aab8c0a11087" class="bulleted-list"><li style="list-style-type:circle">What did we learn?</li></ul><ul id="d8096bf6-e3fb-4bbe-8e5c-0354aa414f11" class="bulleted-list"><li style="list-style-type:circle">Shortcomings &amp; Challenges</li></ul><ul id="6351ad8c-5a3e-4d43-ae3d-1fbfa7722a82" class="bulleted-list"><li style="list-style-type:circle">Best Practices</li></ul><ul id="0cc9cbc0-41c0-432b-9dcb-9183ae6cd797" class="bulleted-list"><li style="list-style-type:circle">Enhance Your Knowledge</li></ul></li></ul></details></li></ul><h1 id="60ff56cd-4411-4acd-ac6c-0fa33cb2ae36" class=""><mark class="highlight-brown">Learning Objective</mark></h1><h2 id="a9cc58b1-dad1-40be-a6c8-a34e0e6a698c" class="block-color-default"><mark class="highlight-red"><strong>Introduction</strong></mark></h2><p id="55e51b83-2391-41ae-9072-5d254ceda5aa" class="">Time and space complexity analysis is a crucial aspect of evaluating the efficiency of sorting algorithms. It involves determining how the algorithms&#x27; runtime and memory usage change with different input sizes.</p><p id="b75de66d-57b3-4b4c-9334-34543ac78762" class=""><strong>Duration:</strong> 2 Hours</p><p id="ecf7e0f1-0ffc-4e25-bcf9-845dea9ff267" class=""><strong>Focus:</strong> Introduction, Working, Implementation, and Analysis of Heap Sort, Bucket Sort, Radix Sort, and Counting Sort</p><p id="0b48ca54-c295-43b7-a594-0bad96fd0ff1" class=""><strong>Prerequisite:</strong> Basic understanding of Arrays and their manipulation, Programming Concepts such as loops and conditional statements in JavaScript.</p><h2 id="c0d30ff6-53d5-48c7-91b2-8f57488ac929" class="block-color-default"><mark class="highlight-red"><strong>Theme</strong></mark></h2><p id="021488d2-a3ac-47d1-9af6-85e61738816a" class="">In the world of e-commerce, sorting algorithms play a crucial role in providing a seamless shopping experience for customers. Let&#x27;s consider a real-world scenario where a popular online marketplace needs to sort a vast array of products based on their prices.</p><p id="3e1a001a-167b-479d-9860-8b58f226b0d3" class=""><strong>Heap Sort</strong> can be an ideal choice in this scenario. With its efficient memory usage, it can handle large data sets, such as the countless products available for sale. The algorithm organizes the products based on their prices, allowing customers to easily navigate through various price ranges and find the best deals.</p><p id="9f9a3c0e-83ff-4909-b027-d7c6c8662e82" class="">On the other hand, <strong>Bucket Sort</strong> proves useful when dealing with a wide range of product prices. Imagine the marketplace has products ranging from inexpensive items to luxury goods. By dividing the price range into buckets and sorting each bucket separately, Bucket Sort enables efficient categorization of products, facilitating better browsing and filtering options for customers.</p><p id="e6bc8b0c-7362-4019-95f5-e7faf5d74040" class=""><strong>Radix Sort</strong> comes into play when the marketplace needs to sort products based on multiple attributes simultaneously. For instance, besides price, the marketplace might want to sort products by brand, rating, and popularity. Radix Sort can handle this scenario by sequentially sorting the products based on each attribute, ensuring a comprehensive and accurate sorting result.</p><p id="464b8673-0837-430e-9c20-4e35611c9b90" class=""><strong>Counting Sort</strong> can be utilized in situations where the marketplace needs to sort products based on specific criteria, such as the number of customer reviews. By counting the occurrences of each review count, Counting Sort can efficiently arrange the products in ascending or descending order of review counts, providing valuable insights for customers looking for highly rated or popular items.</p><p id="57c610c7-c743-4a75-9f4d-5c6ca5ae6061" class="">In summary, these sorting algorithms, including Heap Sort, Bucket Sort, Radix Sort, and Counting Sort, find practical application in various real-world scenarios, such as e-commerce platforms, where efficient data organization enhances user experience, enables better decision-making, and ultimately drives business success.</p><h2 id="7b718998-6f2c-4f8e-881c-4eaf1595a19b" class="block-color-default"><mark class="highlight-red"><strong>Primary Goals</strong></mark></h2><ul id="d5fe3bed-a745-40b4-b5a9-f5a5be443a75" class="bulleted-list"><li style="list-style-type:disc">Grasp the fundamental concepts, underlying principles , and the step-by-step process involved in each sorting algorithm.</li></ul><ul id="5461944a-a0e4-4737-b315-fc6ea36d932e" class="bulleted-list"><li style="list-style-type:disc">Analyze the time and space complexity of each sorting algorithm.</li></ul><ul id="b27f2b67-c4da-4fcc-b191-08727d981405" class="bulleted-list"><li style="list-style-type:disc">Gain proficiency in implementing these sorting algorithms in JavaScript.</li></ul><p id="5d6a66d6-44d1-4d49-97c2-c6ed80f7a6fa" class="">
</p><h1 id="6ca111c2-0977-4840-b88d-da3c1855c714" class=""><mark class="highlight-brown">Advanced Sorting Algorithms</mark></h1><h2 id="777cb4fc-f54f-41f3-82ce-bc39b6ca7687" class=""><mark class="highlight-red">Introduction to Heap Sort</mark></h2><p id="cf6cf234-2896-413c-a4f5-1434be9f3ae1" class="">Heap Sort is an efficient and comparison-based sorting algorithm that uses a binary heap data structure to sort elements. It divides the input into a sorted region and an unsorted region, repeatedly extracting the maximum element from the unsorted region and placing it at the end of the sorted region. The algorithm takes advantage of the heap property, which ensures that the maximum (or minimum, depending on the heap type) element is always at the root of the heap.</p><h3 id="0f3d5920-1af1-42ae-920f-a4a89de3f2da" class="">Working of Heap Sort</h3><ol type="1" id="f600fca3-87ab-4b1e-81f7-522b3d584154" class="numbered-list" start="1"><li><strong>Build the Heap</strong>: The first step in Heap Sort is to build a heap from the input array. This involves arranging the elements of the array into a binary heap structure. The heap can be built in linear time using a bottom-up approach starting from the last non-leaf node and sifting down each node to its correct position.</li></ol><ol type="1" id="e75c8950-23e9-4628-b1c3-98da95680d43" class="numbered-list" start="2"><li><strong>Extract the Maximum Element</strong>: Once the heap is built, the maximum element is located at the root of the heap. It is swapped with the last element in the unsorted region of the array. This effectively places the maximum element in its correct sorted position at the end of the array.</li></ol><ol type="1" id="6b2ddb6a-3111-4669-8bc0-d0b0ddc04dd4" class="numbered-list" start="3"><li><strong>Restore Heap Property</strong>: After swapping the maximum element, the heap property may be violated. To restore the heap property, sift down the new root (previously the last element of the unsorted region) to its correct position in the heap.</li></ol><ol type="1" id="97830227-d192-4598-9343-7cb2fb41721a" class="numbered-list" start="4"><li><strong>Repeat the Process</strong>: Repeat steps 2 and 3 until the entire array is sorted. In each iteration, the sorted region of the array expands by one element, and the unsorted region decreases by one element.</li></ol><ol type="1" id="fb4e70b7-bafb-4039-8d95-233715dcb8f8" class="numbered-list" start="5"><li><strong>Final Sorted Array</strong>: After all iterations, the array will be completely sorted in ascending order.</li></ol><div id="a5d03948-c84d-4c8b-9e95-a8d40efb278d" class="column-list"><div id="d818ee78-71fd-4bbc-8ee0-98f40cf38b34" style="width:20.833333333333332%" class="column"><p id="c98134f7-80ad-4190-84e8-ba3ca77561ee" class="">
</p></div><div id="88bf1e96-88ca-4cfd-9e30-a002b75cf656" style="width:54.166666666666664%" class="column"><figure id="0c046da8-1d52-4e61-9452-6897b51f2851" class="image"><img style="width:528px" src="Advanced%20Sorting%20Algorithms%202ad8c01b6c01423a9837eb201e06b6db/Heap_sort.gif"/></a></figure></div><div id="4e20252e-ac7a-4fa9-b4fa-20825b3e9761" style="width:24.99999999999999%" class="column"><p id="3b2a0c46-d708-47d9-9b72-ad13693a2860" class="">
</p></div></div><h3 id="02a30a36-5b12-4c58-9ecb-0d7483f3a7d1" class="">Implementation of Heap Sort</h3><p id="66de52db-bfd2-44fa-9f57-9593eac5a11d" class="">Here&#x27;s a simple implementation of the Heap Sort algorithm in JavaScript:</p><pre id="f0d96381-8647-41d7-a616-d981b14397b1" class="code code-wrap"><code>function heapSort(arr) {
  let length = arr.length;

  // Build the heap
  for (let i = Math.floor(length / 2) - 1; i &gt;= 0; i--) {
    heapify(arr, length, i);
  }

  // Extract elements one by one from the heap
  for (let i = length - 1; i &gt; 0; i--) {
    // Swap the root (maximum element) with the last element
    let temp = arr[0];
    arr[0] = arr[i];
    arr[i] = temp;

    // Restore heap property for the remaining heap
    heapify(arr, i, 0);
  }

  return arr;
}

function heapify(arr, length, rootIndex) {
  let largest = rootIndex;
  let left = 2 * rootIndex + 1;
  let right = 2 * rootIndex + 2;

  // Compare the root with the left child
  if (left &lt; length &amp;&amp; arr[left] &gt; arr[largest]) {
    largest = left;
  }

  // Compare the largest with the right child
  if (right &lt; length &amp;&amp; arr[right] &gt; arr[largest]) {
    largest = right;
  }

  // If the largest element is not the root, swap them and heapify the affected subtree
  if (largest !== rootIndex) {
    let temp = arr[rootIndex];
    arr[rootIndex] = arr[largest];
    arr[largest] = temp;

    // Recursively heapify the affected subtree
    heapify(arr, length, largest);
  }
}

// Example usage
var arr = [6, 2, 5, 3, 9];
console.log(heapSort(arr)); // Output: [2, 3, 5, 6, 9]</code></pre><ul id="b2457b51-3abf-47cc-90e1-39df9b6f04ce" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="5ad9a873-a49b-4ee1-a064-06501e89116e" class="numbered-list" start="1"><li>The <code>heapSort</code> function is defined with one parameter, <code>arr</code>, which is the array to be sorted.</li></ol><ol type="1" id="cda8ab63-d7b0-4a45-8592-4a321864a4bb" class="numbered-list" start="2"><li>The <code>heapify</code> function is a helper function used to maintain the heap property. It takes the array, the length of the heap, and the index of the current root node as parameters.</li></ol><ol type="1" id="079ddafb-1936-4fe0-b9a4-190dc32cc9ca" class="numbered-list" start="3"><li>In the <code>heapSort</code> function, the initial heap is built by calling <code>heapify</code> on each non-leaf node in the array, starting from the last non-leaf node and moving upwards.</li></ol><ol type="1" id="dab7c452-4df8-4c7c-b890-2d7cb0a77d5c" class="numbered-list" start="4"><li>The maximum element (root) is extracted by swapping it with the last element in the unsorted region of the array. Then, the heap property is restored by calling <code>heapify</code> on the root.</li></ol><ol type="1" id="63d90ddd-1b31-4338-8a7a-34553b72e9a4" class="numbered-list" start="5"><li>Steps 4 and 5 are repeated until the entire array is sorted.</li></ol><ol type="1" id="c90e7596-538f-47dd-aa93-501e2044eadf" class="numbered-list" start="6"><li>The sorted array is then returned.</li></ol></details></li></ul><h3 id="d66ae9f2-c66b-4e20-8767-5a50b3e102a8" class="">Time Complexity of Heap Sort</h3><ul id="8a906331-c63e-437c-802a-b25efacccd69" class="bulleted-list"><li style="list-style-type:disc"><strong>Worst-case time complexity:</strong> <code>O(n log n)</code><p id="07b8d210-bc67-4335-a37f-00bfee635f14" class="">Heap Sort has a worst-case time complexity of <code>O(n log n)</code> for both the average and worst cases. This is because building the heap takes <code>O(n)</code> time, and extracting the maximum element and restoring the heap property both take <code>O(log n)</code> time. Since these operations are performed <code>n</code> times, the overall time complexity is <code>O(n log n)</code>.</p></li></ul><ul id="04a5267b-c5d6-425b-9b80-c8b615cef110" class="bulleted-list"><li style="list-style-type:disc"><strong>Average-case time complexity:</strong> <code>O(n log n)</code><p id="425484c0-09bf-4b26-8775-f22e181f8d5b" class="">Heap Sort has the same average-case time complexity as the worst case, which is <code>O(n log n)</code>.</p></li></ul><ul id="f6711e58-652b-4eb7-a7bb-8c654de971c4" class="bulleted-list"><li style="list-style-type:disc"><strong>Best-case time complexity:</strong> <code>O(n log n)</code><p id="5f227ed6-af0d-4131-8417-c2c9e300f9d1" class="">The best-case time complexity of Heap Sort is also <code>O(n log n)</code>. This occurs when the input array is already sorted or contains identical elements. Although building the heap still takes <code>O(n)</code> time, the extraction and restoration steps will require fewer comparisons but still take <code>O(log n)</code> time, resulting in the same overall time complexity.</p></li></ul><h3 id="6f1e69ff-1a68-4cf1-9823-2461efca3d13" class="">Space Complexity of Heap Sort</h3><ul id="471e203d-760e-44c5-b65b-292fac87fdef" class="bulleted-list"><li style="list-style-type:disc"><strong>The space complexity of Heap Sort:</strong> <code>O(1)</code><p id="be6473e4-76ba-4bcf-ae31-52861b3449f3" class="">Heap Sort is an in-place sorting algorithm, meaning it does not require any additional space proportional to the input size. The sorting is done directly within the input array, resulting in a space complexity of <code>O(1)</code>.</p></li></ul><p id="76f5ba12-827f-4eb0-9543-e57f0cd3e15a" class="">
</p><h2 id="bc9e1455-6185-411e-a27f-97d3a45de23e" class=""><mark class="highlight-blue">Do it yourself</mark></h2><p id="abff3a8a-756c-4440-b225-da80b220ee83" class=""><strong>True or False:</strong></p><ol type="1" id="bd3bde60-9561-4498-9f97-13a4423e8083" class="numbered-list" start="1"><li>The heap sort algorithm divides the input into a sorted region and an unsorted region. </li></ol><ol type="1" id="938e3ecc-cc7e-4c0a-8c46-7db5aa38b4c0" class="numbered-list" start="2"><li>Heap sort uses a binary heap data structure to sort elements. </li></ol><ol type="1" id="077a9071-3fcf-477f-af5e-5764e888b102" class="numbered-list" start="3"><li>The heap sort algorithm has a worst-case time complexity of O(n^2). </li></ol><ol type="1" id="f114a437-141a-444d-bcbb-b72c4e2a07cf" class="numbered-list" start="4"><li>The space complexity of heap sort is O(n).</li></ol><ol type="1" id="ad337246-520d-4dc6-9dc9-6a53a6db2745" class="numbered-list" start="5"><li>The initial heap in heap sort is built using a top-down approach. </li></ol><ol type="1" id="f3ae404e-1432-45bf-803d-7c193fbe8270" class="numbered-list" start="6"><li>Heap sort can be implemented using a bottom-up approach to build the heap. </li></ol><ul id="056be9bc-77e6-4223-82fd-1da28fce71d4" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><ol type="1" id="47f7d5e6-15c7-44d2-b236-ee7eab28dd9c" class="numbered-list" start="1"><li>True</li></ol><ol type="1" id="55be3a8a-e5a8-49b2-8995-5fc927679a34" class="numbered-list" start="2"><li>True</li></ol><ol type="1" id="129ef803-4002-4c0b-83ca-683a1ecb96d1" class="numbered-list" start="3"><li>False</li></ol><ol type="1" id="433ba3ad-a9ff-4ef1-b654-31709e688761" class="numbered-list" start="4"><li>False</li></ol><ol type="1" id="d48e6384-4549-46a8-b00d-5b82a6b4d845" class="numbered-list" start="5"><li>False</li></ol><ol type="1" id="5bf270ab-5765-4065-a2e3-8294fe200540" class="numbered-list" start="6"><li>True</li></ol></details></li></ul><p id="a6748dde-06db-40bc-9cb0-dd891b278785" class="">
</p><h2 id="f673b71b-e0c5-4de9-82cf-a0224ad93229" class=""><mark class="highlight-red">Introduction to Bucket Sort</mark></h2><p id="799f25ce-4278-43f9-8f0a-03cf28758297" class="">Bucket Sort is a sorting algorithm that works by distributing elements of an input array into a finite number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm or by recursively applying the bucket sort algorithm. After sorting all the buckets, the elements are concatenated to obtain the sorted array.</p><h3 id="f767f5a2-c2bc-4c2c-b244-742e01f88a05" class="">Working of Bucket Sort</h3><ol type="1" id="82f2a8ee-d862-4f6f-aa70-e6ac5a0cefe8" class="numbered-list" start="1"><li><strong>Create Buckets</strong>: Divide the range of the input values into a fixed number of equally sized intervals or buckets. Each bucket represents a subrange of values.</li></ol><ol type="1" id="ff6cbcb8-2579-4136-a950-d8594455a457" class="numbered-list" start="2"><li><strong>Distribute Elements</strong>: Iterate over the input array and place each element into its corresponding bucket based on its value. The placement can be determined by dividing the element by the range of values and multiplying it by the number of buckets.</li></ol><ol type="1" id="a08b3078-a2f9-4abd-9533-d512e3a33101" class="numbered-list" start="3"><li><strong>Sort Buckets</strong>: Sort each bucket individually, either using another sorting algorithm or by recursively applying the bucket sort algorithm if the bucket size is large enough.</li></ol><ol type="1" id="9e502d6e-ed53-4981-9923-74bae24611ee" class="numbered-list" start="4"><li><strong>Concatenate Buckets</strong>: After all the buckets are sorted, concatenate them in order to obtain the sorted array. The elements from each bucket are combined to form the final sorted array.</li></ol><div id="f0267b41-8764-4ed2-9cb2-fffce5b16aca" class="column-list"><div id="bc6475db-2489-4070-8c12-dc0dd47dcc90" style="width:20.833333333333332%" class="column"><p id="48444c57-e34e-4eb3-bb17-9de7d50a1d4d" class="">
</p></div><div id="4cf1cb21-ee7b-4165-b2ec-1a57c85a0f43" style="width:58.33333333333333%" class="column"><figure id="f34c7b14-94c4-4964-9a72-bb286253a2fc" class="image"><img style="width:576px" src="https://miro.medium.com/v2/resize:fit:1024/1*_2l-UN7jcQp54hgazT6iVA.gif"/></a></figure></div><div id="1ee8504c-6dce-4873-9520-9f22295fdeb9" style="width:20.833333333333332%" class="column"><p id="cd209462-7f1e-4e3a-827c-839c5a372115" class="">
</p></div></div><h3 id="c410fffb-e208-453b-8e98-8ede4e9e82e5" class="">Implementation of Bucket Sort</h3><p id="6990702a-f537-4c60-830e-e9404b5ee6c6" class="">Here&#x27;s a simple implementation of the Bucket Sort algorithm in JavaScript:</p><pre id="7dad5d07-c6b2-41a5-8750-b8620621ca28" class="code code-wrap"><code>function bucketSort(arr, bucketSize = 5) {
  if (arr.length === 0) {
    return arr;
  }

  // Find the minimum and maximum values in the input array
  let minValue = arr[0];
  let maxValue = arr[0];
  for (let i = 1; i &lt; arr.length; i++) {
    if (arr[i] &lt; minValue) {
      minValue = arr[i];
    } else if (arr[i] &gt; maxValue) {
      maxValue = arr[i];
    }
  }

  // Determine the number of buckets needed
  const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;
  const buckets = new Array(bucketCount);

  // Initialize the buckets
  for (let i = 0; i &lt; bucketCount; i++) {
    buckets[i] = [];
  }

  // Distribute the elements into the buckets
  for (let i = 0; i &lt; arr.length; i++) {
    const bucketIndex = Math.floor((arr[i] - minValue) / bucketSize);
    buckets[bucketIndex].push(arr[i]);
  }

  // Sort each bucket and concatenate them
  const sortedArray = [];
  for (let i = 0; i &lt; bucketCount; i++) {
    insertionSort(buckets[i]);
    sortedArray.push(...buckets[i]);
  }

  return sortedArray;
}

function insertionSort(arr) {
  const length = arr.length;
  for (let i = 1; i &lt; length; i++) {
    const current = arr[i];
    let j = i - 1;
    while (j &gt;= 0 &amp;&amp; arr[j] &gt; current) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = current;
  }
}

// Example usage
var arr = [6, 2, 5, 3, 9];
console.log(bucketSort(arr)); // Output: [2, 3, 5, 6, 9]</code></pre><ul id="50cafae1-5b52-4bbc-b223-34d94136913c" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="297e3123-2039-406a-887b-c3f40590e1d7" class="numbered-list" start="1"><li>The <code>bucketSort</code> function is defined with two parameters: <code>arr</code>, the input array to be sorted, and <code>bucketSize</code>, the number of elements that can be placed in each bucket. The default <code>bucketSize</code> is set to 5 if not provided.</li></ol><ol type="1" id="51eb6f32-8666-435d-bf55-1658dc2311f6" class="numbered-list" start="2"><li>The minimum and maximum values of the input array are determined to establish the range of values.</li></ol><ol type="1" id="1044db9a-b8be-4aec-97f7-2b951d85f125" class="numbered-list" start="3"><li>The number of buckets needed is calculated based on the range of values and the <code>bucketSize</code>.</li></ol><ol type="1" id="b042c9e8-1bc1-4183-8f2b-73ed3c5901de" class="numbered-list" start="4"><li>An array of empty buckets is created.</li></ol><ol type="1" id="1719635e-978e-4293-a9f2-cf1b9c4e1f52" class="numbered-list" start="5"><li>The elements of the input array are distributed into the buckets based on their values.</li></ol><ol type="1" id="1c664d8e-7f0a-42d2-90ce-171ba831807c" class="numbered-list" start="6"><li>Each non-empty bucket is sorted individually either by applying insertion sort if the bucket size is 1, or by recursively applying bucket sort to the bucket with a reduced <code>bucketSize</code>.</li></ol><ol type="1" id="94a99a42-43aa-4b71-b30a-a54bd80d570f" class="numbered-list" start="7"><li>The sorted elements from each bucket are concatenated to form the final sorted array, which is then returned.</li></ol></details></li></ul><h3 id="05d5346b-1089-48f5-a2d8-c4bfebd5f5bc" class="">Time Complexity of Bucket Sort</h3><ul id="6a3b7e01-c022-4542-b4b9-4d9217508b40" class="bulleted-list"><li style="list-style-type:disc"><strong>Average-case time complexity:</strong> <code>O(n + k)</code><p id="4d73bdcc-cc1d-42d4-9dfa-39b7ba12416e" class="">The average-case time complexity of Bucket Sort depends on the average number of elements in each bucket. When the elements are evenly distributed across the buckets, the average time complexity becomes linear. Here, <code>n</code> represents the number of elements in the input array, and <code>k</code> represents the number of buckets.</p></li></ul><ul id="786a44f0-94e3-4dea-a35e-9e3a7fb954fe" class="bulleted-list"><li style="list-style-type:disc"><strong>Worst-case time complexity:</strong> <code>O(n^2)</code><p id="d6af66aa-e9ed-4c7b-a900-94d65852b5e3" class="">The worst-case time complexity of Bucket Sort occurs when all the elements fall into the same bucket. In such cases, the algorithm needs to use another sorting algorithm, such as insertion sort, to sort the elements within the bucket. This results in a quadratic time complexity.</p></li></ul><h3 id="22e137a2-de2d-4e37-ba5c-9e65dd4411df" class="">Space Complexity of Bucket Sort</h3><ul id="8a8ec9d7-f5c1-466f-bc5f-4f5e47051bf2" class="bulleted-list"><li style="list-style-type:disc"><strong>The space complexity of Bucket Sort:</strong> <code>O(n + k)</code><p id="08da51a7-3f7e-4677-af43-876b496b92ce" class="">Bucket Sort requires additional space to store the buckets and their elements. The space complexity is dependent on the number of elements in the input array (<code>n</code>) and the number of buckets (<code>k</code>). In the worst case, when all the elements fall into the same bucket, the space complexity is <code>O(n)</code>. However, on average, the space complexity is <code>O(n + k)</code>.</p></li></ul><p id="df03c64a-0f16-45bf-b582-85273a700e34" class="">
</p><h2 id="2ca86a0c-9e58-4732-88ac-c623abc6d995" class=""><mark class="highlight-red">Introduction to Radix Sort</mark></h2><p id="a98ab6cc-1179-4ea3-b8be-4f8710df5a80" class="">Radix Sort is a non-comparative sorting algorithm that sorts elements by processing their digits or bits from the least significant digit to the most significant digit. It works based on the concept of grouping elements by their place value and repeatedly sorting them based on each digit or bit position. Radix Sort can be applied to both integer and string representations.</p><h3 id="9086b714-f00d-4e3b-9d26-0807c797be8c" class="">Working of Radix Sort</h3><ol type="1" id="3d16866b-d45a-40f9-aaeb-e87be749745b" class="numbered-list" start="1"><li><strong>Choose a Radix</strong>: Radix Sort uses a radix, which represents the number of unique digits or bits in the elements being sorted. Common radices include base 10 (decimal) for integers and base 2 (binary) for bits.</li></ol><ol type="1" id="ca28e08c-bbcb-41a1-aa4a-73dcb1e2ee97" class="numbered-list" start="2"><li><strong>Grouping by Digits/Bits</strong>: Start by considering the least significant digit or bit of each element. Group the elements into buckets based on the value of this digit or bit. Elements with the same digit or bit value are placed in the same bucket.</li></ol><ol type="1" id="be54f88f-9567-4672-a061-5824301569fb" class="numbered-list" start="3"><li><strong>Sorting Each Bucket</strong>: Sort the elements within each bucket. This can be done using any stable sorting algorithm, such as counting sort, insertion sort, or recursively applying Radix Sort.</li></ol><ol type="1" id="6f674b89-71cf-4f7f-8ab0-c6725d6f6732" class="numbered-list" start="4"><li><strong>Repeat for Each Digit/Bit</strong>: Move to the next significant digit or bit and repeat steps 2 and 3 until all digits or bits have been processed.</li></ol><ol type="1" id="3faea24e-d542-45cb-8877-ea797789ad6e" class="numbered-list" start="5"><li><strong>Concatenating Buckets</strong>: After sorting the elements based on the most significant digit or bit, concatenate the elements from each bucket to obtain the fully sorted array.</li></ol><div id="49158d8b-b6d4-4865-acba-07b36d1d19f4" class="column-list"><div id="ba82e59e-be95-4e05-bc6f-c89a4711dfd2" style="width:20.833333333333332%" class="column"><p id="40319884-de51-49c4-906b-07a6c605657a" class="">
</p></div><div id="8594b9a8-4d70-4d9e-9ee7-d7a252c664f2" style="width:58.33333333333333%" class="column"><figure id="e8639501-67d3-493c-bd49-74d76a15a174" class="image"><img style="width:576px" src="Advanced%20Sorting%20Algorithms%202ad8c01b6c01423a9837eb201e06b6db/Radix_sort.gif"/></a></figure></div><div id="59217ca4-b724-48ae-8d75-9808005e9739" style="width:20.83333333333334%" class="column"><p id="827bb4c2-390f-481b-88f5-b1740f73b9dd" class="">
</p></div></div><h3 id="e691a080-d68d-436c-a39d-c8b8ba8245bd" class="">Implementation of Radix Sort</h3><p id="c822713c-2a88-474c-9a7f-df3e21e465e6" class="">Here&#x27;s a simple implementation of the Radix Sort algorithm in JavaScript:</p><pre id="c63eda3f-3d0e-444a-a917-571250b3ddf0" class="code code-wrap"><code>function radixSort(arr) {
  const max = Math.max(...arr);
  let divisor = 1;

  while (divisor &lt;= max) {
    arr = countingSort(arr, divisor);
    divisor *= 10;
  }

  return arr;
}

function countingSort(arr, divisor) {
  const count = new Array(10).fill(0);
  const n = arr.length;
  const output = new Array(n);

  for (let i = 0; i &lt; n; i++) {
    const digit = Math.floor((arr[i] / divisor) % 10);
    count[digit]++;
  }

  for (let i = 1; i &lt; 10; i++) {
    count[i] += count[i - 1];
  }

  for (let i = n - 1; i &gt;= 0; i--) {
    const digit = Math.floor((arr[i] / divisor) % 10);
    output[count[digit] - 1] = arr[i];
    count[digit]--;
  }

  for (let i = 0; i &lt; n; i++) {
    arr[i] = output[i];
  }

  return arr;
}

// Example usage
var arr = [170, 45, 75, 90, 802, 24, 2, 66];
console.log(radixSort(arr)); // Output: [2, 24, 45, 66, 75, 90, 170, 802]</code></pre><ul id="7d21480c-7d2a-459c-a932-ead5852bf1cc" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="221d3de6-37bb-4215-bb47-a0dc4ee17fcd" class="numbered-list" start="1"><li>The <code>radixSort</code> function is defined, taking an array <code>arr</code> as a parameter.</li></ol><ol type="1" id="a5200eb7-08dc-40e1-a9c7-a710006a303f" class="numbered-list" start="2"><li>The maximum value in the array, <code>max</code>, is calculated to determine the number of digits or bits to process.</li></ol><ol type="1" id="3db7aa1a-4887-42ae-b257-ac1404b27894" class="numbered-list" start="3"><li>The <code>countingSort</code> function is defined, which implements the counting sort algorithm.</li></ol><ol type="1" id="6e3ced54-baa4-4f1b-aa36-8db421398eb7" class="numbered-list" start="4"><li>The <code>countingSort</code> function takes the input array <code>arr</code> and a <code>divisor</code> as parameters.</li></ol><ol type="1" id="bc6f10db-d443-4684-9781-5d5a84ada4fa" class="numbered-list" start="5"><li>An array <code>count</code> is initialized to store the count of each digit or bit.</li></ol><ol type="1" id="71e5082a-673f-41cb-b0f2-50bbab97e0b3" class="numbered-list" start="6"><li>The input array is iterated, and the count of each digit or bit is incremented accordingly.</li></ol><ol type="1" id="039a8d0e-ee15-436b-bd0c-f332bfcf8e01" class="numbered-list" start="7"><li>The count array is modified to store the cumulative count of each digit or bit.</li></ol><ol type="1" id="26f87862-4c11-4336-8758-26b722cbe154" class="numbered-list" start="8"><li>The input array is iterated in reverse order, and each element is placed in its correct position in the output array based on the digit or bit value.</li></ol><ol type="1" id="54f8ae51-5dac-4745-997d-cc8a64cd472c" class="numbered-list" start="9"><li>The output array is copied back to the input array.</li></ol><ol type="1" id="8039bc05-a023-4b89-8a26-dacd3053e44c" class="numbered-list" start="10"><li>The <code>countingSort</code> function returns the sorted array.</li></ol><ol type="1" id="030d449e-32e4-43c1-a214-e5ed699994d2" class="numbered-list" start="11"><li>The <code>radixSort</code> function performs multiple iterations of the counting sort, gradually considering digits or bits of increasing significance.</li></ol><ol type="1" id="673fd234-3e8e-4eb6-8a34-010fa2527619" class="numbered-list" start="12"><li>Finally, the sorted array is returned.</li></ol></details></li></ul><h3 id="bda5a18a-9bee-4e5f-9c5f-4e6bd53cedf5" class="">Time Complexity of Radix Sort</h3><ul id="42cd70ea-6851-448f-b495-f2d3b15ea974" class="bulleted-list"><li style="list-style-type:disc"><strong>Time complexity:</strong> <code>O(d * (n + k))</code><p id="be80d51c-5e09-453a-9bac-0da1655a63c1" class="">Here, <code>n</code> represents the number of elements in the input array, <code>d</code> represents the number of digits or bits in the maximum element, and <code>k</code> represents the range of values for each digit or bit (usually 10 or 2). The time complexity of Radix Sort is linear with respect to the number of elements and the number of digits or bits being processed.</p></li></ul><h3 id="d7c75908-d2df-4d34-ac0c-ba8b29c85980" class="">Space Complexity of Radix Sort</h3><ul id="e2f4ccac-df46-4549-9e08-dc942dcccb4b" class="bulleted-list"><li style="list-style-type:disc"><strong>The space complexity of Radix Sort:</strong> <code>O(n + k)</code><p id="13ba0b80-e08e-4d7f-9a6f-64c31d3d33ce" class="">Radix Sort requires additional space to store the count array and the output array used in the counting sort step. The space complexity is dependent on the number of elements in the input array (<code>n</code>) and the range of values for each digit or bit (<code>k</code>).</p></li></ul><p id="7ec062f0-5c9b-46ae-82f9-7342c7826802" class="">
</p><h2 id="c12b6724-6b7c-4909-b618-6fff7675d757" class=""><mark class="highlight-blue">Activity 1</mark></h2><p id="3dcc1f97-8fd9-4812-9aed-4b6ec8a53fc9" class=""><strong>Fill in the blanks:</strong></p><ol type="1" id="13619a0f-737f-47dd-a870-b82ad00dfe29" class="numbered-list" start="1"><li>The concatenation of sorted buckets in Bucket Sort results in _____________ <strong>(a partially sorted array/a fully sorted array/an unsorted array)</strong>.</li></ol><ol type="1" id="9178dbb0-7f51-4a2d-b1a0-77fde850762c" class="numbered-list" start="2"><li>If the bucket size in Bucket Sort is larger, the number of recursive calls __________<strong>(increases/decreases/remains the same).</strong></li></ol><ol type="1" id="6738ac1a-2b36-4546-8ae6-dcd7af8d64b0" class="numbered-list" start="3"><li>The number of buckets needed in Bucket Sort is determined by __________<strong>(The size of the input array/The range of values in the input array/The desired sorting order)</strong>.</li></ol><ol type="1" id="4d40ff00-5afe-4615-beb0-6d54939c0bb4" class="numbered-list" start="4"><li>Radix Sort uses a radix, which represents the number of unique ________ <strong>(digits/letters/symbols)</strong> in the elements being sorted.</li></ol><ol type="1" id="a95e606b-3b77-4e1b-b7ae-9acc1865faff" class="numbered-list" start="5"><li>Radix Sort works based on the concept of grouping elements by their ________ <strong>(magnitude/binary/place) </strong>value and repeatedly sorting them based on each digit or bit position.</li></ol><ul id="8f02547b-1b53-457d-b346-5bbafa0d3aa2" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><ol type="1" id="d73d6286-2270-4222-a8dc-3ce7ff669587" class="numbered-list" start="1"><li>A fully sorted array</li></ol><ol type="1" id="2f14e985-0f4c-49ce-ba30-91a56f84de7e" class="numbered-list" start="2"><li>decreases</li></ol><ol type="1" id="6b8ea7be-402b-4c7f-876d-c2c395cdd8a6" class="numbered-list" start="3"><li>The range of values in the input array</li></ol><ol type="1" id="25408dcf-fddf-4ea8-aba9-5c82cd090270" class="numbered-list" start="4"><li>digits</li></ol><ol type="1" id="8b8ba7a6-df48-4384-bdd7-e476f3784845" class="numbered-list" start="5"><li>place</li></ol></details></li></ul><p id="7906e17e-011c-4020-a668-16b68d899456" class="">
</p><h2 id="ba35c4b1-8011-4397-aaca-066c56d07a60" class=""><mark class="highlight-red">Introduction to Counting Sort</mark></h2><p id="d2f542b1-3adf-4f33-bf93-ef90008f180c" class="">Counting Sort is a non-comparative sorting algorithm that works by determining the number of occurrences of each distinct element in the input array. It creates a count array to store the frequency of each element and uses this information to determine the correct position of each element in the sorted output array. Counting Sort assumes that the input elements are integers or can be mapped to integers.</p><h3 id="e823ea99-d3c5-4a9c-95e3-2c641765b044" class="">Working of Counting Sort</h3><ol type="1" id="0b998496-813a-4361-8197-30e6a7fa0909" class="numbered-list" start="1"><li><strong>Determine Range</strong>: Find the minimum and maximum values in the input array to determine the range of values for the count array.</li></ol><ol type="1" id="b44bd86e-db6a-4456-8983-ca5f5c5d9e54" class="numbered-list" start="2"><li><strong>Count Frequencies</strong>: Create a count array of size <code>range</code>, initialized with all zeros. Iterate through the input array, and for each element, increment the corresponding index in the count array.</li></ol><ol type="1" id="110d10f6-dd53-4bee-a556-d078d0f9b2eb" class="numbered-list" start="3"><li><strong>Compute Cumulative Counts</strong>: Modify the count array to store the cumulative count of each element. Each count represents the number of elements that are less than or equal to the corresponding index.</li></ol><ol type="1" id="03bec88d-b947-4277-8b6c-694da25947c9" class="numbered-list" start="4"><li><strong>Place Elements in Sorted Order</strong>: Iterate through the input array in reverse order. For each element, find its index in the count array, which represents its sorted position in the output array. Place the element in the correct position, and decrement the count in the count array for that index.</li></ol><ol type="1" id="bd2b7d5f-45c2-4293-ab66-62f77a43ab9b" class="numbered-list" start="5"><li><strong>Build Sorted Array</strong>: The output array is now sorted, with elements placed in their correct order based on their counts.</li></ol><div id="c9b478d5-a3f4-40db-95aa-a9cfa02aa959" class="column-list"><div id="6d6e3fcb-24bb-4869-bc08-58b236826d9e" style="width:29.166666666666664%" class="column"><p id="6c3e119c-c6f0-4f91-8298-8d1a908f8d2b" class="">
</p></div><div id="f45fe137-5b69-4794-b7be-121cac06408c" style="width:41.666666666666664%" class="column"><figure id="5b44a648-a7d8-4b1e-a4c5-7a8622e8dca4" class="image"><img style="width:432px" src="Advanced%20Sorting%20Algorithms%202ad8c01b6c01423a9837eb201e06b6db/Counting_SOrt.gif"/></a></figure></div><div id="2f08a5df-92e0-4fd4-bdad-91d6b1e46946" style="width:29.166666666666657%" class="column"><p id="44fa3241-37c8-4d76-9af8-6c6daa101329" class="">
</p></div></div><h3 id="76a4cebe-3a19-40e7-a07a-320b413495bf" class="">Implementation of Counting Sort</h3><p id="706deba4-303c-4d02-967d-7d034eb70f7e" class="">Here&#x27;s a simple implementation of the Counting Sort algorithm in JavaScript:</p><pre id="d1909b2b-11a9-43a3-8e07-1e8b4e6698e8" class="code code-wrap"><code>function countingSort(arr) {
  if (arr.length === 0) {
    return arr;
  }

  const max = Math.max(...arr);
  const min = Math.min(...arr);
  const range = max - min + 1;
  const count = new Array(range).fill(0);
  const output = new Array(arr.length);

  for (let i = 0; i &lt; arr.length; i++) {
    count[arr[i] - min]++;
  }

  for (let i = 1; i &lt; range; i++) {
    count[i] += count[i - 1];
  }

  for (let i = arr.length - 1; i &gt;= 0; i--) {
    output[count[arr[i] - min] - 1] = arr[i];
    count[arr[i] - min]--;
  }

  return output;
}

// Example usage
var arr = [4, 2, 2, 8, 3, 3, 1];
console.log(countingSort(arr)); // Output: [1, 2, 2, 3, 3, 4, 8]</code></pre><ul id="1b9d44e9-1c86-4da4-b5fb-4472ccc7205b" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="21e453fa-e662-4c6a-ba2a-5bbced54266a" class="numbered-list" start="1"><li>The <code>countingSort</code> function is defined, taking an array <code>arr</code> as a parameter.</li></ol><ol type="1" id="cffb5caf-5c79-4dd0-8cb3-fdf898cc9f8a" class="numbered-list" start="2"><li>The minimum and maximum values in the array, <code>min</code> and <code>max</code>, are determined to establish the range of values.</li></ol><ol type="1" id="f7917590-9d32-4c38-a68a-63478b663f19" class="numbered-list" start="3"><li>A count array, <code>count</code>, is created with a size equal to the range of values. It is initialized with all zeros.</li></ol><ol type="1" id="0aa2224a-75d7-447f-a82c-9480340c6992" class="numbered-list" start="4"><li>The input array is iterated, and the count of each element is incremented in the corresponding index of the count array.</li></ol><ol type="1" id="648f69c7-b52c-4712-b391-6d38fc4ff549" class="numbered-list" start="5"><li>The count array is modified to store the cumulative count of each element.</li></ol><ol type="1" id="b98beb28-f6d2-4f6c-8f69-dc97f41aca40" class="numbered-list" start="6"><li>The input array is iterated in reverse order. Each element is placed in its correct position in the output array based on its count, and the count is decremented.</li></ol><ol type="1" id="13e331c0-c8de-44dc-a346-9408b5cbc335" class="numbered-list" start="7"><li>The sorted output array is returned.</li></ol></details></li></ul><h3 id="5853494c-b8ee-4670-ab75-6998fea80527" class="">Time Complexity of Counting Sort</h3><ul id="a52a55c4-8358-49e7-9f67-ac46b7d54808" class="bulleted-list"><li style="list-style-type:disc"><strong>Time complexity:</strong> <code>O(n + k)</code><p id="8b3685d1-078c-4e17-afc5-dcac57eb2fb5" class="">Counting Sort has a linear time complexity, where <code>n</code> represents the number of elements in the input array and <code>k</code> represents the range of values. It performs two passes over the input array: one to count the occurrences of each element and another to place the elements in their sorted order. The time complexity is not affected by the initial order of the input elements.</p></li></ul><h3 id="b44337b8-3bb5-4181-a17d-6f956980f09e" class="">Space Complexity of Counting Sort</h3><ul id="2ac25964-8a27-4bca-a6b8-203eb68d64ef" class="bulleted-list"><li style="list-style-type:disc"><strong>The space complexity of Counting Sort:</strong> <code>O(n + k)</code><p id="943472b2-790d-4257-939f-a9eed85c436d" class="">Counting Sort requires additional space to store the count array and the output array. The space complexity is dependent on the number of elements in the input array (<code>n</code>) and the range of values (<code>k</code>). The space complexity is considered linear.</p></li></ul><p id="e7b0b8d9-32ff-4283-8636-0ee92b8d809e" class="">
</p><h2 id="8a015b28-2c6e-4086-9333-60ae345e6b83" class=""><mark class="highlight-blue">Explore Further</mark></h2><p id="17f2839f-f59f-458e-8e6d-5b224a059585" class=""><mark class="highlight-orange"><strong>Uncover and unlock new insights as you dive into the captivating content found in the provided link.</strong></mark></p><p id="c77de4e3-26ef-4aae-8773-48dad6136d08" class=""><strong>Shell Sort: </strong><a href="https://learnersbucket.com/tutorials/algorithms/shell-sort-algorithm-in-javascript/">https://learnersbucket.com/tutorials/algorithms/shell-sort-algorithm-in-javascript/</a></p><p id="f9ca60f6-5c9b-4176-9124-27c80b99ed77" class="">
</p><p id="f0833360-0a00-4b52-ad67-dbad2fccb584" class=""><mark class="highlight-orange"><strong>Tackle these questions head-on!</strong></mark></p><p id="771d6439-7af3-4dd8-aed6-e512d20e8dae" class=""><strong>Let&#x27;s say we have an array of numbers: [8, 3, 1, 5, 9, 2, 7, 4, 6].</strong></p><p id="cf628679-f408-4128-b57d-ada8694d67ae" class=""><strong>Arrange the following in order:</strong></p><ol type="1" id="a266da8b-3b3c-46c6-aabd-a1e931991634" class="numbered-list" start="1"><li>Reduce the gap value (typically halved) and repeat steps 2-3 until the gap becomes 1.</li></ol><ol type="1" id="cc57387f-d0fb-44b0-a63f-c7ba69411e34" class="numbered-list" start="2"><li>Choose a gap value (initially set as n/2, where n is the length of the array).</li></ol><ol type="1" id="ce3bc7fc-6947-4735-bdb7-4330ed703388" class="numbered-list" start="3"><li>Compare and swap elements that are gap positions apart.</li></ol><ol type="1" id="25f943cc-9254-4848-bcb4-0117f28e38af" class="numbered-list" start="4"><li>Perform a pass with gap = 1, using a standard insertion sort to sort the array.</li></ol><ol type="1" id="082e6770-f365-4314-949c-254f8cdf2d41" class="numbered-list" start="5"><li>Repeat the comparison and swapping process for all elements in the array.</li></ol><ul id="1a9e1da8-2267-4926-aa46-9389c9e64eb6" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><p id="5ff109fc-91c0-4a5f-ac8c-05da9975ef8c" class=""><strong>Correct order is: 2-3-5-1-4</strong></p><ol type="1" id="0290c2d5-0610-4130-9d15-f65bd0b93713" class="numbered-list" start="1"><li>Choose a gap value (initially set as n/2, where n is the length of the array).</li></ol><ol type="1" id="58770234-af9d-49fa-865d-5a24745cd1b2" class="numbered-list" start="2"><li>Compare and swap elements that are gap positions apart.</li></ol><ol type="1" id="4cb82baa-cefe-4b0b-af78-365b3afecf30" class="numbered-list" start="3"><li>Repeat the comparison and swapping process for all elements in the array.</li></ol><ol type="1" id="68b44ba4-fe14-4e5b-a322-15bf1bc9d6a1" class="numbered-list" start="4"><li>Reduce the gap value (typically halved) and repeat steps 2-3 until the gap becomes 1.</li></ol><ol type="1" id="ab7bd9a0-1017-4584-b172-dce7c533cf01" class="numbered-list" start="5"><li>Perform a final pass with gap = 1, using a standard insertion sort to sort the array.</li></ol><p id="893c9698-8be9-4896-aed4-11bd03dfb838" class="">By gradually reducing the gap and performing sorting passes, Shell Sort moves elements toward their correct positions, resulting in a sorted array.</p></details></li></ul><p id="7f61f726-0718-462e-81ec-2b23ccbfca70" class="">
</p><h1 id="4c0b9cbc-3cf2-49c8-a7d4-942e694d8fb5" class=""><mark class="highlight-brown">Summary</mark></h1><h2 id="56843fca-0421-4c05-be20-25b90e0af6c2" class="block-color-default"><mark class="highlight-red">Key Takeaways</mark></h2><ul id="2cf7b1fa-3516-416f-83f5-d927b6787ef0" class="bulleted-list"><li style="list-style-type:disc">Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure.</li></ul><ul id="32d47eb8-3846-402d-be37-0017daa84217" class="bulleted-list"><li style="list-style-type:disc">Heap Sort has a time complexity of <code>O(n log n)</code> in all cases, making it efficient for large datasets. Heap Sort operates directly on the input array, resulting in a space complexity of <code>O(1)</code>.</li></ul><ul id="3998d5dc-c60b-4abf-bc41-c92a79265f52" class="bulleted-list"><li style="list-style-type:disc">Bucket Sort is a non-comparative sorting algorithm that divides the input into a fixed number of buckets. It distributes the elements into the buckets based on their values and applies another sorting algorithm within each bucket.</li></ul><ul id="06440301-e09d-4ec9-a315-02cafed08a31" class="bulleted-list"><li style="list-style-type:disc">Bucket Sort is useful when the input is uniformly distributed over a range.</li></ul><ul id="9d1024e7-51f0-4d16-a2ca-b6f449dec200" class="bulleted-list"><li style="list-style-type:disc">It has an average-case time complexity of <code>O(n + k)</code>, where <code>n</code> is the number of elements and <code>k</code> is the number of buckets used. The space complexity of Bucket Sort is <code>O(n + k)</code>, depending on the number of elements and the number of buckets.</li></ul><ul id="98c7c496-4537-456a-946d-802e548716fc" class="bulleted-list"><li style="list-style-type:disc">Radix Sort is a non-comparative sorting algorithm that sorts elements based on their digits or bits from the least significant to the most significant. It works by repeatedly sorting the elements based on each digit or bit position.</li></ul><ul id="8f1e35b4-6eb5-4edd-83e9-4a4c587e5870" class="bulleted-list"><li style="list-style-type:disc">Radix Sort has a time complexity of <code>O(d * (n + k))</code>, where <code>d</code> is the number of digits or bits, <code>n</code> is the number of elements, and <code>k</code> is the range of values for each digit or bit.</li></ul><ul id="77e9218e-7a8e-4148-ab8a-b394c6a74e86" class="bulleted-list"><li style="list-style-type:disc">The space complexity of Radix Sort is <code>O(n + k)</code>, depending on the number of elements and the range of values.</li></ul><ul id="8b0c3993-00fe-4d3d-9acc-08cc7c2b1528" class="bulleted-list"><li style="list-style-type:disc">Counting Sort is a non-comparative sorting algorithm that determines the frequency of each distinct element in the input array. It creates a count array to store the occurrence of each element and uses this information to place elements in the correct order.</li></ul><ul id="7149277a-59aa-411f-a8dc-2a09285d69a4" class="bulleted-list"><li style="list-style-type:disc">Counting Sort has a time complexity of <code>O(n + k)</code>, where <code>n</code> is the number of elements and <code>k</code> is the range of values.</li></ul><ul id="e17644a8-0f41-4f24-b6c4-239ed0e85bce" class="bulleted-list"><li style="list-style-type:disc">The space complexity of Counting Sort is <code>O(n + k)</code>, depending on the number of elements and the range of values.</li></ul><h2 id="c9c49a6b-066a-40b3-aac2-d50ce95c6eb8" class="block-color-default"><mark class="highlight-red">Shortcomings &amp; Challenges</mark></h2><ul id="dd8874dc-b553-4e0d-8b05-2ec4f190b4c1" class="bulleted-list"><li style="list-style-type:disc"><strong>Space Complexity:</strong> Some of these sorting algorithms, such as Bucket Sort and Counting Sort, may require additional memory to store auxiliary data structures like buckets or count arrays. This can be a challenge when dealing with limited memory resources or sorting very large datasets.</li></ul><ul id="8118021e-3161-43b6-a1fa-821baac62a9f" class="bulleted-list"><li style="list-style-type:disc"><strong>Data Distribution:</strong> The performance of these sorting algorithms can be sensitive to the distribution of the input data. Unevenly distributed or skewed data can lead to suboptimal performance and slower execution times.</li></ul><ul id="7b434650-42f1-4c3a-ba97-468d7eaef357" class="bulleted-list"><li style="list-style-type:disc"><strong>Non-Adaptive:</strong> These sorting algorithms do not adapt their runtime based on the input data. They have fixed time complexities and do not take advantage of pre-sorted or partially sorted input arrays. This can result in unnecessary comparisons and swaps, leading to inefficiencies in certain scenarios.</li></ul><h2 id="b722ce16-a868-463f-9749-57194cfb6ec7" class="block-color-default"><mark class="highlight-red">Best Practices</mark></h2><ul id="fadf2d30-02d2-4346-89b7-e557669619ef" class="bulleted-list"><li style="list-style-type:disc">Carefully handle the indexing in the array, as most implementations start indexing at 1 rather than 0.</li></ul><ul id="84c57243-49ca-4728-a06d-8ea662fc572d" class="bulleted-list"><li style="list-style-type:disc">Select an efficient sorting algorithm to sort the elements within each bucket. Insertion Sort or Quick Sort are commonly used for this step.</li></ul><ul id="e255e036-7e4c-4b65-a141-d93f935d0e12" class="bulleted-list"><li style="list-style-type:disc">Handle negative numbers properly by applying appropriate transformations or by using a variant of Radix Sort like MSD (Most Significant Digit) or LSD (Least Significant Digit) Radix Sort.</li></ul><ul id="53fe583f-26a0-43d2-902b-fd724750ecbd" class="bulleted-list"><li style="list-style-type:disc">Ensure that the range of input elements is known in advance, as Counting Sort requires this information to allocate the counting array.</li></ul><h2 id="957a5868-3843-46ae-9ee5-b88e1ae2f643" class="block-color-default"><mark class="highlight-red">Additional Resources</mark></h2><ul id="c390d056-7a70-4d42-be5d-a7cfa4b4870c" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.boardinfinity.com/blog/time-complexity-of-sorting-algorithms/">https://www.boardinfinity.com/blog/time-complexity-of-sorting-algorithms/</a></li></ul><ul id="01b3f038-ea5f-4165-aa89-8996c6ff1dac" class="bulleted-list"><li style="list-style-type:disc"><a href="https://levelup.gitconnected.com/sorting-algorithms-comparing-the-best-and-the-rest-2448129f5b4a">https://levelup.gitconnected.com/sorting-algorithms-comparing-the-best-and-the-rest-2448129f5b4a</a></li></ul><ul id="b28accfb-70f1-48a0-895a-fb29e9531a13" class="bulleted-list"><li style="list-style-type:disc"><a href="https://blog.devgenius.io/the-10-common-sorting-algorithms-dbcf253d344a">https://blog.devgenius.io/the-10-common-sorting-algorithms-dbcf253d344a</a></li></ul></div></article></body></html>
