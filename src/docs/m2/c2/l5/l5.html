<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Skill Mastery Challenge</title><link rel="stylesheet" href="../../../../../styles.css"></head><body><article id="7051eba6-c4a6-4ba7-a05e-714e72d21d20" class="page sans"><header><h1 class="page-title">Skill Mastery Challenge</h1><p class="page-description"></p></header><div class="page-body"><h2 id="662db968-1a1f-4d3e-a847-328aa4d1594a" class="block-color-default"><mark class="highlight-red">What did we learn?</mark></h2><ul id="ab83b5e5-7783-4bc5-b7b3-672781129739" class="bulleted-list"><li style="list-style-type:disc">Bubble sort, Insertion sort, and Selection sort are simple and easy-to-implement sorting algorithms that work well for small datasets but are inefficient for larger datasets.</li></ul><ul id="f0612b2f-6708-4105-abaf-72a125785929" class="bulleted-list"><li style="list-style-type:disc">Merge sort and Quicksort are more advanced and efficient sorting algorithms that work well for larger datasets. Merge sort has a time complexity of O(n log n), and Quicksort has a time complexity of O(n log n) on average.</li></ul><ul id="71fe9766-2217-4b30-bf32-d80e6b108e6e" class="bulleted-list"><li style="list-style-type:disc">Time complexity analysis is an important aspect of sorting algorithms, as it helps determine the efficiency of the algorithm. The time complexity can be analyzed in terms of the best-case, worst-case, and average-case scenarios.</li></ul><ul id="c68178ea-8836-47ec-be21-b0f4e1184f06" class="bulleted-list"><li style="list-style-type:disc">Space complexity analysis is another important aspect of sorting algorithms, as it helps determine the amount of memory required for the algorithm. The space complexity can be analyzed in terms of the amount of extra memory required by the algorithm or the amount of memory required by the algorithm in total.</li></ul><ul id="c671e308-4df0-4628-829b-dd1315004b5d" class="bulleted-list"><li style="list-style-type:disc">Linear search is a simple searching algorithm that checks each element of a list or array until a match is found. It has a time complexity of O(n).</li></ul><ul id="848684ab-fe7b-45ac-86b1-88bee55551f9" class="bulleted-list"><li style="list-style-type:disc">Binary search is a more efficient searching algorithm that works by repeatedly dividing the search interval in half. It has a time complexity of O(log n).</li></ul><ul id="1cafe089-c05a-4db2-9271-293682f312ed" class="bulleted-list"><li style="list-style-type:disc">Hashmap is a data structure that allows for constant-time retrieval of values based on their associated keys. It uses a hash function to map keys to indices in an array.</li></ul><ul id="901daabb-866b-4ddc-bb01-a6614ce4d046" class="bulleted-list"><li style="list-style-type:disc">Time and space complexity analysis is a crucial tool for evaluating the performance of searching algorithms. It allows us to understand how an algorithm&#x27;s performance scales with increasing input size and helps us to identify the most efficient algorithm for a given problem.</li></ul><h2 id="393be8e3-fd6e-4999-b5ff-6d135b8bec33" class="block-color-default"><mark class="highlight-red">Best Practices to follow</mark></h2><ul id="5db8b136-5890-407e-ace5-ee36751f11c3" class="bulleted-list"><li style="list-style-type:disc">Choose the appropriate sorting and searching algorithm based on the size of the input and the type of data being sorted.</li></ul><ul id="7fe5f150-f619-4fdb-bf5c-b9cbb1c0befc" class="bulleted-list"><li style="list-style-type:disc">Understand the time and space complexity of the sorting and searching algorithm before using it. This will help you determine whether it is suitable for your use case.</li></ul><ul id="63a3a3ba-0558-4cbf-a9c2-4df4b9ba3f1c" class="bulleted-list"><li style="list-style-type:disc">Use a divide-and-conquer approach whenever possible, as it can lead to more efficient sorting algorithms.</li></ul><ul id="2c29a6a5-f464-4437-b5d5-f0bb13f96bff" class="bulleted-list"><li style="list-style-type:disc">Use appropriate data structures such as heaps and binary trees to optimize the sorting and searching algorithm for specific use cases.</li></ul><ul id="0512fc4d-b073-4835-a8cd-68a270b08842" class="bulleted-list"><li style="list-style-type:disc">Always test your sorting and searching algorithm on a variety of input sizes and types to ensure that it works correctly and efficiently in all cases.</li></ul><h2 id="8f160995-104c-4391-b0ed-b208b5bc9965" class=""><mark class="highlight-red">Interview Prep</mark></h2><h3 id="c96ab493-d5b9-4692-ab7d-5f6e3d10cd8b" class="">Modify bubble sort to make it more efficient</h3><p id="7fc64fcd-1943-46c6-b8df-ac94bf7431c5" class=""><strong> </strong>Bubble sort has a time complexity of O(n^2), which makes it inefficient for large datasets. However, there are a few modifications that can be made to make bubble sorting more efficient:</p><ul id="1277d69d-8539-4a57-b693-435fed76c4e7" class="bulleted-list"><li style="list-style-type:disc">To terminate early, add a flag to check if the list is already sorted.</li></ul><ul id="b91dcf90-e09d-48f7-8f2c-a0be9eb6a008" class="bulleted-list"><li style="list-style-type:disc">Implement a bidirectional bubble sort to reduce the number of passes needed.</li></ul><ul id="c7d50afd-a5a8-4078-8a6c-02e35b7d4dfe" class="bulleted-list"><li style="list-style-type:disc">Combine bubble sort with another sorting algorithm, such as insertion sort or quicksort, to create a hybrid algorithm that takes advantage of both strengths.</li></ul><h3 id="7656fa1f-a0ed-461f-9871-f7552ac0f39a" class="">Difference between internal and external sorting</h3><table id="4e53ae90-8fbe-44eb-a6cf-4ec09822e749" class="simple-table"><thead class="simple-table-header"><tr id="a8cd0d93-2399-4252-8534-3b2688446046"><th id="NO:?" class="simple-table-header-color simple-table-header" style="width:350px">Keyword</th><th id="tV&lt;&gt;" class="simple-table-header-color simple-table-header" style="width:350px"><strong>Internal Sorting</strong></th><th id="QnYj" class="simple-table-header-color simple-table-header" style="width:350px"><strong>External Sorting</strong></th></tr></thead><tbody><tr id="937238d7-f731-41ef-af92-e5bb58f0b40a"><td id="NO:?" class="" style="width:350px">Definition</td><td id="tV&lt;&gt;" class="" style="width:350px">Sorting data that can be stored entirely in memory.</td><td id="QnYj" class="" style="width:350px">Sorting data that exceeds the available memory must be stored on external devices such as disks.</td></tr><tr id="9f7f7c29-953a-431d-ab94-53a8ca6fabcc"><td id="NO:?" class="" style="width:350px">Dataset size</td><td id="tV&lt;&gt;" class="" style="width:350px">Suitable for small to moderate-sized datasets that fit entirely in memory.</td><td id="QnYj" class="" style="width:350px">Suitable for large datasets that exceed the available memory and must be stored on external storage devices.</td></tr><tr id="177fecd9-37f6-478b-b9b1-03f1358b8484"><td id="NO:?" class="" style="width:350px">Access Speed</td><td id="tV&lt;&gt;" class="" style="width:350px">Faster access to data in memory, resulting in faster sorting times.</td><td id="QnYj" class="" style="width:350px">Slower access to data on external storage devices, resulting in slower sorting times.</td></tr><tr id="e821ff06-5786-4fa6-b0d3-90fe58168526"><td id="NO:?" class="" style="width:350px">I/O operations</td><td id="tV&lt;&gt;" class="" style="width:350px">Fewer I/O operations are needed since data is stored in memory.</td><td id="QnYj" class="" style="width:350px">More I/O operations are needed to read and write data to and from external storage devices.</td></tr><tr id="1ab8b0fd-421d-4aed-bb56-87518120f32a"><td id="NO:?" class="" style="width:350px">Sorting algorithms</td><td id="tV&lt;&gt;" class="" style="width:350px">Quick sort, merge sort, heap sort, insertion sort, selection sort, bubble sort.</td><td id="QnYj" class="" style="width:350px">External merge sort, external quick sort, multiway merge sort, distribution sort.</td></tr></tbody></table><p id="4cf96065-96c0-4de8-9f20-3d4350dec108" class="">External sorting algorithms that are efficient with I/O operations and memory usage are better suited for sorting large datasets that cannot fit in memory. These algorithms include External Merge Sort, External Quick Sort, Multiway Merge Sort, and Distribution Sort. These algorithms have been optimized for disk access and minimize the number of I/O operations needed to read and write data to and from external storage devices, making them efficient for external sorting.</p><h3 id="070eaa3f-a040-49ef-8f32-13edb85ae919" class="">Comparison-based and non-comparison-based sorting algorithms</h3><table id="eb17cd0c-18fa-429a-9a00-94254c7b18b1" class="simple-table"><thead class="simple-table-header"><tr id="99d9b377-d51d-4589-ab07-d85b88ff6297"><th id="&gt;?`q" class="simple-table-header-color simple-table-header" style="width:350px"><strong>Criterion</strong></th><th id="jRBl" class="simple-table-header-color simple-table-header" style="width:350px"><strong>Comparison-based sorting algorithms</strong></th><th id="ZlO]" class="simple-table-header-color simple-table-header" style="width:350px"><strong>Non-comparison-based sorting algorithms</strong></th></tr></thead><tbody><tr id="a0362e02-41ae-4117-9d32-b405679a40e4"><td id="&gt;?`q" class="" style="width:350px">Basic approach</td><td id="jRBl" class="" style="width:350px">Compare elements and swap them if necessary.</td><td id="ZlO]" class="" style="width:350px">Not based on a comparison of elements.</td></tr><tr id="ff0ae2b4-e1c8-4aab-b186-11a73f5a9347"><td id="&gt;?`q" class="" style="width:350px">Number of comparisons</td><td id="jRBl" class="" style="width:350px">Generally requires O(n log n) comparisons.</td><td id="ZlO]" class="" style="width:350px">It only depends on the number of elements.</td></tr><tr id="d29ee02b-2480-49cf-909c-0c67c63645e5"><td id="&gt;?`q" class="" style="width:350px">Best-case time complexity</td><td id="jRBl" class="" style="width:350px">O(n log n)</td><td id="ZlO]" class="" style="width:350px">O(n) or O(n log n)</td></tr><tr id="f7fc1e8c-7d6f-4f28-ac89-734516d4d347"><td id="&gt;?`q" class="" style="width:350px">Examples</td><td id="jRBl" class="" style="width:350px">Quick sort, Merge sort, Heap sort, Bubble sort, Insertion sort, Selection sort</td><td id="ZlO]" class="" style="width:350px">Counting sort, Radix sort, Bucket sort</td></tr></tbody></table><p id="a43d3c5c-a411-4ed5-bcb8-5f505460d90a" class="">Bubble sort, Insertion sort, and Selection sort are all comparison-based sorting algorithms. They fall into this category because they are based on comparing elements and swapping them if necessary to sort them. Bubble sort compares adjacent elements in the array and swaps them if they are in the wrong order. Insertion sort compares an element with the sorted elements on its left and inserts it in the correct position. Selection sort selects the minimum or maximum element in the unsorted part of the array and places it at the beginning of the sorted part.</p><p id="3f752ae9-6b41-433e-b3b7-5b31f19016dc" class="">Although these sorting algorithms are simple and easy to implement, they are generally less efficient than other comparison-based sorting algorithms, such as quicksort, merge sort, and heapsort, which use more advanced techniques to sort the data more efficiently.</p><h3 id="a357af0d-d9a6-4803-b913-33eb689d9efc" class="">Pivot selection strategy of Quicksort</h3><p id="eb600206-8247-415b-a1b9-27184a122458" class="">The pivot selection strategy in Quicksort affects its performance. A good strategy results in a balanced array partitioning, leading to better worst-case time complexity. A poor strategy can result in unbalanced partitions and the worst-case performance of O(n^2). Common strategies include selecting the first, last, or middle element, selecting a random element, and selecting the median of three elements. Advanced strategies include &quot;median of medians&quot; and &quot;introspective&quot; approaches.</p><h3 id="47adcec4-f3d8-4efb-82cb-b99249d13711" class="">Quicksort implementation with three-way partitioning</h3><p id="37e149bf-c573-4dc8-9e07-9b950f731f33" class="">Quicksort can be implemented with three-way partitioning to handle cases where there are many elements equal to the pivot. The algorithm divides the array into three parts: elements less than the pivot, elements equal to the pivot, and elements greater than the pivot. This ensures that all equal elements are grouped together and can improve the algorithm&#x27;s performance. The partitioning algorithm keeps track of two pointers and places each element in the appropriate part of the array based on its value relative to the pivot. The recursive step is then applied to the first and third parts of the array.</p><h2 id="4eb7a825-2d07-44f5-9ade-70c1cbd3bc43" class="block-color-default"><mark class="highlight-red">Shortcomings &amp; Challenges</mark></h2><ul id="2f53be71-edde-4a42-b1e5-51cba8c63166" class="bulleted-list"><li style="list-style-type:disc">Some sorting algorithms, like Bubble Sort and Insertion Sort, are inefficient for large data sets or data sets with certain types of patterns.</li></ul><ul id="6bfdc392-8f9b-4f60-b07e-9d0ee67b90fc" class="bulleted-list"><li style="list-style-type:disc">Linear search has a time complexity of O(n), which can be very slow for large arrays or datasets.</li></ul><ul id="a775dd4a-933b-441d-a83c-de33966dd3ff" class="bulleted-list"><li style="list-style-type:disc">Both linear and binary searches are inefficient for unordered linked lists.</li></ul><ul id="1a2dd26a-3736-4df2-8f2a-d05a2b3465f7" class="bulleted-list"><li style="list-style-type:disc">As sorting algorithms become more efficient in terms of time complexity, they often require more space complexity.</li></ul><ul id="8e49653c-ee86-4071-8b53-f8bde9882e8f" class="bulleted-list"><li style="list-style-type:disc">Some sorting algorithms, like Heap Sort and Radix Sort, are complex to implement compared to simpler algorithms like Bubble Sort and Selection Sort.</li></ul><ul id="db1e245a-1898-47ce-9502-f962dea0f85b" class="bulleted-list"><li style="list-style-type:disc">Hash tables have a higher space complexity compared to other data structures.</li></ul><h2 id="cb6c3434-a39c-4528-a7cf-9439256dea02" class="block-color-default"><mark class="highlight-red">Enhance your knowledge</mark></h2><ul id="04153b60-0457-4aff-ab59-d8b86ad364a8" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.toptal.com/developers/sorting-algorithms">https://www.toptal.com/developers/sorting-algorithms</a></li></ul><ul id="875af1ea-2bd6-4c1b-96b4-3b6cdb455857" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html</a></li></ul><ul id="cd3c22db-3324-4370-bb09-40610902b34c" class="bulleted-list"><li style="list-style-type:disc"><a href="https://medium.com/@sujanxchhetri/searching-algorithms-in-javascript-ecb880f70e07">https://medium.com/@sujanxchhetri/searching-algorithms-in-javascript-ecb880f70e07</a></li></ul><p id="1a11e899-8747-49fa-bbd8-3cac67778ea7" class="">
</p></div></article></body></html>