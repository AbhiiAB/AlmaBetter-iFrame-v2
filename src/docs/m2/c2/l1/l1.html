<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Introduction to Sorting Algorithms</title><link rel="stylesheet" href="../../../../../styles.css"></head><body><article id="7444ff59-428a-454d-8e3f-830c5f0107ce" class="page sans"><header><h1 class="page-title">Introduction to Sorting Algorithms</h1><p class="page-description"></p></header><div class="page-body"><ul id="43c3ced2-9f5b-4919-90c0-5c8d820725b8" class="toggle"><li><details close=""><summary><strong>Session Flow (5 minutes read)</strong></summary><ul id="0500d04b-d871-4eaa-95f0-66529bbe419b" class="bulleted-list"><li style="list-style-type:disc"><strong>Learning Objective (5 minutes read)</strong><ul id="eb47a087-fdfc-4420-b468-16f6fdc71c82" class="bulleted-list"><li style="list-style-type:circle">Introduction</li></ul><ul id="f79dcfee-76b5-457e-a0f5-039ce6d36bd6" class="bulleted-list"><li style="list-style-type:circle">Theme</li></ul><ul id="bf0a2103-e894-47b7-9da7-3c97b7ebf2fe" class="bulleted-list"><li style="list-style-type:circle">Primary Goals</li></ul></li></ul><ul id="316ffa68-ce34-4002-ab35-6b82e3e65712" class="bulleted-list"><li style="list-style-type:disc"><strong>Introduction to Sorting Algorithms (120 minutes read)</strong><ul id="712b58cd-fadb-4195-b5d7-df66749c3363" class="bulleted-list"><li style="list-style-type:circle">Introduction to Bubble Sort<ul id="dcf98fbd-5d27-40c6-a10d-2e3bcb189476" class="bulleted-list"><li style="list-style-type:square">Working of Bubble Sort</li></ul><ul id="2549e9c9-29b8-4924-8c5f-868865cf5514" class="bulleted-list"><li style="list-style-type:square">Implementation of Bubble Sort</li></ul><ul id="717e8c01-f371-49ef-89da-a523dd1efe1d" class="bulleted-list"><li style="list-style-type:square">Time complexity of Bubble sort</li></ul><ul id="06779d02-c2a3-499d-85e9-2b69d2cb39f2" class="bulleted-list"><li style="list-style-type:square">Space Complexity of Bubble sort</li></ul></li></ul><ul id="e2766789-3113-408a-b548-ad2e48a7d1c2" class="bulleted-list"><li style="list-style-type:circle"><strong>Do it yourself</strong></li></ul><ul id="73b2c5f5-e58e-4935-b08f-cdcc75825bf3" class="bulleted-list"><li style="list-style-type:circle">Introduction to Selection Sort<ul id="64452d5f-512f-4965-876b-95a609bd06b3" class="bulleted-list"><li style="list-style-type:square">Working of Selection Sort</li></ul><ul id="6ae22e56-1067-4174-b73f-e9b32a8fcdaa" class="bulleted-list"><li style="list-style-type:square">Implementation of Selection Sort</li></ul><ul id="a3fa5d73-a9cb-4dac-bad3-335878a725e4" class="bulleted-list"><li style="list-style-type:square">Time complexity of Selection Sort</li></ul><ul id="8f6d2793-8e4b-4c62-adcd-9013ab8f416a" class="bulleted-list"><li style="list-style-type:square">Space Complexity of Selection Sort</li></ul></li></ul><ul id="631980c4-d4d0-4181-a31d-47ec31bdc066" class="bulleted-list"><li style="list-style-type:circle"><strong>Activity 1</strong></li></ul><ul id="908fb1a3-3a64-43cf-9968-38997901fa35" class="bulleted-list"><li style="list-style-type:circle">Introduction to Insertion Sort<ul id="7522fa97-79bc-4745-b0be-cd30e8dcc497" class="bulleted-list"><li style="list-style-type:square">Working of Insertion Sort</li></ul><ul id="715296da-ec09-4df1-80bf-62acb3d23a46" class="bulleted-list"><li style="list-style-type:square">Implementation of Insertion Sort</li></ul><ul id="0c5f676b-d6b6-49a1-a857-3461279049a1" class="bulleted-list"><li style="list-style-type:square">Time complexity of Insertion Sort</li></ul><ul id="d3124b57-e8ae-4d61-a82e-b6543744f449" class="bulleted-list"><li style="list-style-type:square">Space Complexity of Insertion Sort</li></ul></li></ul><ul id="33c4b0a7-2dad-4c81-ba5f-e0ea16a250bd" class="bulleted-list"><li style="list-style-type:circle">Introduction to Merge Sort<ul id="66fe3553-b9b7-48da-8c91-8779d9e2975b" class="bulleted-list"><li style="list-style-type:square">Working of Merge Sort</li></ul><ul id="4420641a-55ff-4699-9e5c-9d8c22bb1bb3" class="bulleted-list"><li style="list-style-type:square">Implementation of Merge Sort</li></ul><ul id="ad410d89-c1d9-4ba0-a342-facd6110f85b" class="bulleted-list"><li style="list-style-type:square">Time complexity of Merge Sort</li></ul><ul id="e4301227-e139-4444-86e8-ad0536382025" class="bulleted-list"><li style="list-style-type:square">Space Complexity of Merge Sort</li></ul></li></ul><ul id="67ec3696-fcfe-4f19-a446-7eb649eeb847" class="bulleted-list"><li style="list-style-type:circle"><strong>Activity 2</strong></li></ul><ul id="5363d73f-b540-4fee-a838-80656e3dbc68" class="bulleted-list"><li style="list-style-type:circle">Introduction to Quick Sort<ul id="03e279f7-ccca-4ff3-82b8-1b6de062a3c2" class="bulleted-list"><li style="list-style-type:square">Working of Quick Sort</li></ul><ul id="6f6854ee-3467-4b65-8175-9d73f3cc70b5" class="bulleted-list"><li style="list-style-type:square">Implementation of Quick Sort</li></ul><ul id="72994be0-a948-4977-b105-457f653501b8" class="bulleted-list"><li style="list-style-type:square">Time complexity of Quick Sort</li></ul><ul id="20790ce1-63a6-4abc-bf34-f11be50c5edd" class="bulleted-list"><li style="list-style-type:square">Space Complexity of Quick Sort</li></ul></li></ul><ul id="5de405b7-d3c0-405c-a210-2a02a2e3427d" class="bulleted-list"><li style="list-style-type:circle"><strong>Explore Further</strong></li></ul></li></ul><ul id="bc5522fe-7096-4f0c-90e9-b6a4bc53d19f" class="bulleted-list"><li style="list-style-type:disc"><strong>Summary (10 minutes read)</strong><ul id="cb9dc216-9a01-4c1f-b2e9-684e0dc87805" class="bulleted-list"><li style="list-style-type:circle">What did we learn?</li></ul><ul id="c684f237-ee71-4ebb-878d-8b06123f2453" class="bulleted-list"><li style="list-style-type:circle">Shortcomings &amp; Challenges</li></ul><ul id="9b650d02-81a2-460f-9588-54c12989d436" class="bulleted-list"><li style="list-style-type:circle">Best Practices</li></ul><ul id="f5d8ad82-f53d-43f2-9761-3a988d57f283" class="bulleted-list"><li style="list-style-type:circle">Enhance Your Knowledge</li></ul></li></ul></details></li></ul><h1 id="4af4ec2c-d507-4b79-ba52-d5449184d32d" class=""><mark class="highlight-brown">Learning Objective</mark></h1><h2 id="8dfbc1a3-5051-440b-bb34-5ca91aa47313" class="block-color-default"><mark class="highlight-red">Introduction</mark></h2><p id="0ffc93cc-3c38-4d51-9014-618be0cc247a" class="">Sorting algorithms compare and rearrange elements: Bubble Sort compares adjacent elements; Insertion Sort shifts elements; Selection Sort selects and places the smallest (or largest), Quick Sort partitions and recursively sorts; Merge Sort divides, recursively sorts, and merges.</p><p id="57c9b2fe-1706-4c01-88c1-6d4f6c163544" class=""><strong>Duration</strong>: 2 hours </p><p id="f286c135-5108-4dff-9b65-9d2a93881f5a" class=""><strong>Focus</strong>: Introduction, Working, Implementation and Analysis of Bubble sort, Selection sort, Insertion sort, Merge sort, and Quick sort</p><p id="19793829-9bda-40e4-b699-821d6847e4f1" class=""><strong>Prerequisites</strong>: Basic understanding of Arrays and their manipulation, Programming Concepts such as loops and conditional statements in JavaScript.</p><h2 id="a97be5f3-f954-4ee3-839c-ec23ad89374e" class="block-color-default"><mark class="highlight-red">Theme</mark></h2><p id="588e6d52-f5b1-438a-a79a-ff442249b62f" class=""><strong>Netflix</strong> utilizes sorting algorithms in its recommendation system to personalize the content recommendations for each user. <strong>Sorting algorithms</strong> are used to analyze user preferences, viewing history, and ratings to determine the most relevant movies and TV shows to suggest. By applying sorting algorithms, Netflix can efficiently sort and present a tailored list of recommendations to individual users, enhancing their viewing experience and increasing engagement on the platform.</p><p id="db58f2f6-423a-4b57-95b1-2c438cb89af3" class="">Furthermore, sorting algorithms play a crucial role in Netflix&#x27;s content categorization and browsing functionalities. When users browse through different genres, release years, or actors, sorting algorithms are used to sort and present the content in a meaningful and organized manner. This allows users to navigate and find the content they are interested in easily.</p><p id="462b84e0-e36e-4913-beb2-e21c125394f0" class="">By leveraging sorting algorithms, Netflix optimizes its recommendation system and enhances the user experience by delivering personalized content suggestions and facilitating efficient content discovery.</p><h2 id="550e3b30-8999-4ff0-84c7-824b8538d323" class="block-color-default"><mark class="highlight-red">Primary Goals</mark> </h2><ul id="a19497b6-5383-4cb9-a995-df4ca3ad242d" class="bulleted-list"><li style="list-style-type:disc">Understand the basics of sorting algorithms and their working.</li></ul><ul id="bdb133db-00ed-4117-b16f-aab1596cc67c" class="bulleted-list"><li style="list-style-type:disc">Implement Bubble Sort, Selection Sort, Merge Sort, Quick Sort, and Insertion Sort in JavaScript and optimize them for better performance.</li></ul><ul id="72d75fbd-29b9-4b60-bb65-2f2b0b36c34e" class="bulleted-list"><li style="list-style-type:disc">Analyze the time complexity and performance of each algorithm.</li></ul><ul id="2c601242-119f-4139-bd6a-43776b58c0d0" class="bulleted-list"><li style="list-style-type:disc">Learn to choose the appropriate algorithm and use it effectively for solving problems.</li></ul><p id="52e73c40-2e2c-488a-be71-27280fb2e5f9" class="">
</p><h1 id="720d72cf-c316-44c2-8c11-28b8882c47fe" class=""><mark class="highlight-brown">Introduction to Sorting Algorithms</mark></h1><h2 id="b2bfabe3-5890-4720-bcbe-7bc01713ad41" class=""><mark class="highlight-red">Introduction to Bubble Sort</mark></h2><p id="9790a601-fc63-4be4-a7c7-553ca694b307" class="">Bubble Sort is a straightforward sorting technique that operates by continuously examining each neighboring pair in a sequence and exchanging their positions if they are not in the correct sequence. The algorithm&#x27;s name, &quot;Bubble Sort,&quot; comes from the way elements gradually ascend to their correct positions in the sequence, akin to bubbles rising to the surface. This method is performed repeatedly until the sequence is entirely sorted.</p><h3 id="f100c824-6338-4e82-9434-5197e42a45fb" class="block-color-default">Working of Bubble Sort</h3><ol type="1" id="42847df7-7aa3-48e9-ba80-f6d734bf22cb" class="numbered-list" start="1"><li><strong>Compare the First Two Elements</strong>: Start at the beginning of the list. Compare the first and second elements. Switch their positions if the first element is greater than the second.</li></ol><ol type="1" id="3ec87726-42df-4b7d-98c9-4b65b975176d" class="numbered-list" start="2"><li><strong>Move to the Next Pair</strong>: Move one position to the right and compare the second and third elements. Again, if the second element is larger than the third, swap them.</li></ol><ol type="1" id="c60397f5-2273-4268-8ad0-fb5b27ae1fa1" class="numbered-list" start="3"><li><strong>Continue Until the End of the List</strong>: Repeat this process for each pair of adjacent elements in the list, from the start to the end. At the end of this process, The largest item in the list will have moved to the end due to the &quot;bubbling up&quot; process finding its correct position.</li></ol><ol type="1" id="ce7b5f62-68ef-412c-8cd5-989edfdca939" class="numbered-list" start="4"><li><strong>Repeat the Process</strong>: Now, start again from the beginning of the list. To continue, repeat the process of comparing neighboring pairs and switching them if they are not in the correct sequence. This time, since the largest element has already found its correct position, you need to go only up to the second last element.</li></ol><ol type="1" id="e3186d18-480e-4ca5-a612-1da3fe482052" class="numbered-list" start="5"><li><strong>Continue Until the List is Sorted</strong>: Keep repeating this process, each time going up to one less element until you go through the list without making a single swap. At this point, the list is fully sorted.</li></ol><figure id="4f907f65-85ef-4a45-9ac8-5da77a053f05" class="image"><img style="width:2456px" src="Introduction%20to%20Sorting%20Algorithms%207444ff59428a454d8e3f830c5f0107ce/Screenshot_2023-05-08_at_7.17.05_PM.png"/></a></figure><h3 id="b040553e-80f3-44b1-a99e-6f7c50052233" class="block-color-default">Implementation of Bubble Sort</h3><p id="c9273b74-e63d-48b9-8619-50b5c19ec7f5" class="">Here&#x27;s a simple implementation of the Bubble Sort algorithm in JavaScript:</p><pre id="c0f3ac51-af49-47f2-a268-3a8bc2d74bfb" class="code code-wrap"><code>function bubbleSort(arr) {
  let length = arr.length;
  for (let i = 0; i &lt; length; i++) {
    for (let j = 0; j &lt; length - i - 1; j++) {
      if (arr[j] &gt; arr[j + 1]) {
        // Swap arr[j] and arr[j + 1]
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}

// Example usage
var arr = [6, 2, 5, 3, 9];
console.log(bubbleSort(arr)); // Output: [2, 3, 5, 6, 9]</code></pre><ul id="5467e407-3a12-4161-8d23-95ee06cbe017" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="3a20e916-f083-412b-9b26-d3167ad88808" class="numbered-list" start="1"><li>The <code>bubbleSort</code> function is defined with one parameter, <code>arr</code>, which is the array to be sorted.</li></ol><ol type="1" id="6963be74-135a-4ca5-a3c1-516527609c90" class="numbered-list" start="2"><li>Two nested loops are used to iterate over the array. The outer loop runs for each element, and the inner loop compares each element with its adjacent element.</li></ol><ol type="1" id="15be3db3-59a8-4bb5-a7fc-9895321ffba4" class="numbered-list" start="3"><li>If the current element is greater than the next one, they are swapped. This is done using a temporary variable, <code>temp</code>.</li></ol><ol type="1" id="d1b5011f-197e-4e9f-b750-d0df7bcbd188" class="numbered-list" start="4"><li>This process continues until the entire array is sorted, with smaller elements &quot;bubbling&quot; towards the front of the array and larger ones moving towards the end.</li></ol><ol type="1" id="52056284-d59b-4f7c-91cc-f325c7c3e9b9" class="numbered-list" start="5"><li>The sorted array is then returned.</li></ol></details></li></ul><h3 id="6ecbbd48-04f6-460f-a655-13c5b7d60e50" class="">Time Complexity of Bubble Sort</h3><ul id="911c347b-7c24-42ce-a5ef-e3425fa0ade0" class="bulleted-list"><li style="list-style-type:disc"><strong>Worst-case time complexity:</strong> <code>O(n^2)</code><p id="e01d0681-4d0e-479a-8a9f-2aff0b485666" class="">This happens when the input list is in reverse order, meaning every pair of elements is swapped in every pass through the list.</p></li></ul><ul id="8e952960-665d-435a-afde-22460f921e16" class="bulleted-list"><li style="list-style-type:disc"><strong>Average-case time complexity:</strong> <code>O(n^2)</code><p id="fc3ce611-a0b1-4f8a-89b6-7722e503a97f" class="">On average, Bubble Sort will need to go through the entire array <code>n</code> times for each of the <code>n</code> elements.</p></li></ul><ul id="44db5ba8-724f-4a78-832f-60c0eaed73d7" class="bulleted-list"><li style="list-style-type:disc"><strong>Best-case time complexity:</strong> <code>O(n)</code><p id="2d2b6a9b-5d50-4f62-9907-628395d6e529" class="">This happens when the input list is already sorted. In this case, bubble sort only needs to pass through the list once to confirm that it is sorted.</p></li></ul><h3 id="70d973e9-ea73-4059-adc4-ea1372849285" class="">Space Complexity of Bubble Sort</h3><ul id="93a3b601-c1d3-4b7d-9902-3d3783edaa6c" class="bulleted-list"><li style="list-style-type:disc"><strong>The space complexity of Bubble Sort:</strong> <code>O(1)</code><p id="a63bfb84-a128-494e-a6ad-5fa797cd143d" class="">Bubble Sort is an in-place sorting algorithm, meaning it only uses a constant amount of extra space to rearrange the elements directly within the input array or list.</p></li></ul><p id="25884178-2413-4fa3-8e27-d713e29c6adf" class="">
</p><h2 id="6dc12b2d-9f62-461e-9c5b-074b5197bb61" class="block-color-default"><mark class="highlight-blue">Do it yourself</mark></h2><p id="338eabf2-ebea-46c9-ada3-b634d9a777d7" class=""><strong>True or False:</strong></p><ol type="1" id="3701e1e8-47c9-4b30-8d1d-a0328e046008" class="numbered-list" start="1"><li>Bubble Sort compares adjacent elements and swaps them if they are not in the correct sequence after the first pass.</li></ol><ol type="1" id="6ff0e442-67fe-4c7e-a142-54f8121f1285" class="numbered-list" start="2"><li>Bubble Sort always starts by comparing the first two elements of the list.</li></ol><ol type="1" id="e30d4338-63cd-4ab2-9712-fa84c2a528a5" class="numbered-list" start="3"><li>Bubble Sort has a worst-case time complexity of O(n^2), regardless of the initial order of the elements.</li></ol><ol type="1" id="010b7c92-67c9-487a-ab3f-59cb9ed88e32" class="numbered-list" start="4"><li>Bubble Sort requires additional space to store temporary variables during the sorting process, proportional to the size of the input list.</li></ol><ol type="1" id="58ff7c65-1069-4d84-886f-7b15595e1e1b" class="numbered-list" start="5"><li>Bubble Sort stops as soon as it finds the largest element in the list and places it in the correct position.</li></ol><ul id="6318caad-3f97-4115-a8da-ddc808ae19a1" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><ol type="1" id="83681cb0-cbd6-430b-ad6b-005e489204fe" class="numbered-list" start="1"><li>False</li></ol><ol type="1" id="7f44a784-095d-4a34-b277-08a6c2016a56" class="numbered-list" start="2"><li>False</li></ol><ol type="1" id="d9da9a8d-6b3b-4590-b8ce-70313506c85a" class="numbered-list" start="3"><li>True</li></ol><ol type="1" id="b87ce800-3af7-4054-9859-8ee677141067" class="numbered-list" start="4"><li>False</li></ol><ol type="1" id="599ef662-5822-4fd3-82a5-2105d9d41385" class="numbered-list" start="5"><li>False</li></ol></details></li></ul><p id="31e52161-e8c2-4a88-bffa-58079eef275d" class="">
</p><h2 id="60101a89-42ff-48d9-b1af-3a1eff03459d" class="block-color-default"><mark class="highlight-red">Introduction to Selection Sort</mark></h2><p id="3c95fd9e-0bd4-4c53-974e-6fb6c565fc23" class="">Selection sort is a simple comparison-based sorting algorithm. It works by dividing the input into a sorted and an unsorted region. The sorted region is initially empty, while the unsorted region contains all the elements. The algorithm repeatedly selects the smallest (or largest, depending on the ordering) element from the unsorted region and moves it into the sorted region. This process continues until the unsorted region is empty and the sorted region contains all the elements.</p><h3 id="4adc0829-3c05-4ff1-b287-dd20f37a7e41" class="block-color-default"><strong>Working of Selection Sort</strong></h3><ol type="1" id="f07f408d-e9fc-43c4-b63e-c5f746afb5b7" class="numbered-list" start="1"><li><strong>Identify the Smallest Element</strong>: Start at the beginning of the list. Identify the smallest element in the list.</li></ol><ol type="1" id="eccebe7f-214a-4dbf-abe6-9fd67df0ba34" class="numbered-list" start="2"><li><strong>Swap the Smallest Element</strong>: Swap the smallest element found with the first element of the list. Now, the first element of the list is the smallest and can be considered as part of the sorted portion of the list.</li></ol><ol type="1" id="d6409ff4-9ecc-4021-b63b-915472c0e32e" class="numbered-list" start="3"><li><strong>Move to the Next Element</strong>: Move one position to the right. This is the first element in the unsorted portion of the list.</li></ol><ol type="1" id="ba1da51b-114b-4b2f-8d20-44911585bd3f" class="numbered-list" start="4"><li><strong>Identify the Smallest Element in the Unsorted Portion</strong>: From this position, identify the smallest element in the unsorted portion of the list.</li></ol><ol type="1" id="2624a990-e367-44d1-ae56-78c3998e7a08" class="numbered-list" start="5"><li><strong>Swap the Smallest Element</strong>: Swap the smallest element found with the first element in the unsorted portion of the list. Now, this element can be considered as part of the sorted portion of the list.</li></ol><ol type="1" id="3d23d6a7-537c-4965-8bf5-973eca6f5d85" class="numbered-list" start="6"><li><strong>Repeat Until the List is Sorted</strong>: Keep repeating this process, each time starting from the next unsorted element, until you reach the end of the list. At this point, the list is fully sorted.</li></ol><figure id="cdeffe1c-f465-4940-aa75-ea509577a86d" class="image"><img style="width:1315px" src="Introduction%20to%20Sorting%20Algorithms%207444ff59428a454d8e3f830c5f0107ce/2023-06-09_12.30.29_www.notion.so_d19e4a11e354.webp"/></a></figure><h3 id="a0626d7c-c88b-40a0-a92e-7e23e435163c" class="block-color-default">Implementation of Selection Sort</h3><p id="16117904-d891-4c69-bbe1-5676bfda8de4" class="">Here&#x27;s a simple implementation of the Selection Sort algorithm in JavaScript:</p><pre id="8bdef64c-2fc9-413b-bbcb-ce3a0d240c45" class="code code-wrap"><code>function selectionSort(arr) {
  let len = arr.length;
  for (let i = 0; i &lt; len; i++) {
    // Assume the first element of the unsorted part is the smallest
    let min = i;
    for (let j = i + 1; j &lt; len; j++) {
      // If any element is smaller, mark its position
      if (arr[min] &gt; arr[j]) {
        min = j;
      }
    }
    // If the current first element isn&#x27;t the smallest then swap it with the smallest
    if (min !== i) {
      let tmp = arr[i];
      arr[i] = arr[min];
      arr[min] = tmp;
    }
  }
  return arr;
}

// Example usage
var arr = [3, 7, 5, 4, 2, 1, 6];
console.log(selectionSort(arr)); // Output: [1, 2, 3, 4, 5, 6, 7]</code></pre><ul id="75635837-69c5-42eb-a397-2c45b60098dd" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="e5bbae1e-86f8-4f04-869d-e9b06724e34f" class="numbered-list" start="1"><li>The outer loop (<code>for (let i = 0; i &lt; len; i++)</code>) iterates over each element in the array. Each iteration represents a single pass through the unsorted portion of the array.</li></ol><ol type="1" id="bb112be0-082f-41bd-8e17-80a11a8ea532" class="numbered-list" start="2"><li>Inside the outer loop, we assume that the first element of the unsorted part of the array is the smallest. We store its index in the variable <code>min</code>.</li></ol><ol type="1" id="7703ea34-f1ff-487d-b85c-c3238de03d4c" class="numbered-list" start="3"><li>The inner loop (<code>for (let j = i + 1; j &lt; len; j++)</code>) iterates over the unsorted portion of the array. If it finds an element smaller than the current <code>min</code>, it updates <code>min</code> to the index of that element.</li></ol><ol type="1" id="16ce6a50-e93a-4e1a-a007-6d5a75d1658a" class="numbered-list" start="4"><li>After the inner loop finishes, we check if <code>min</code> is different from <code>i</code>. If it is, it means we found a smaller element in the unsorted portion of the array. We then swap the element at index <code>i</code> with the element at index <code>min</code>.</li></ol><ol type="1" id="cf982cf2-0c25-45c4-8e37-6eb5e5005cbf" class="numbered-list" start="5"><li>The outer loop continues to the next element (which is the first element of the unsorted portion of the array), and the process repeats until the entire array is sorted.</li></ol><p id="8038e886-32ae-4ab0-be58-c676c562ca8c" class="">
</p></details></li></ul><h3 id="6c56a9eb-be24-449f-8a46-bff2151dc0c5" class="">Time Complexity of Selection Sort</h3><ul id="3a45caf6-9c80-4dd6-9b09-7952f53f1dc3" class="bulleted-list"><li style="list-style-type:disc"><strong>Worst-case time complexity:</strong> <code>O(n^2)</code><p id="cf9c97ef-6320-4dea-a759-91a4270d8330" class="">The worst-case scenario for selection sort occurs when the array is sorted in descending order and we want to sort it in ascending order. In this situation, the algorithm has to perform the maximum number of comparisons and swaps, leading to the highest possible computational complexity.</p></li></ul><ul id="f64c1843-9602-4684-ac7f-d54461f79a3a" class="bulleted-list"><li style="list-style-type:disc"><strong>Average-case time complexity:</strong> <code>O(n^2)</code><p id="44a24387-714a-4460-9c69-64560209512f" class="">This situation arises when the elements within the array are in a jumbled order.</p></li></ul><ul id="b67c9f88-30ba-4323-a211-c3cf347d0f22" class="bulleted-list"><li style="list-style-type:disc"><strong>Best-case time complexity:</strong> <code>O(n^2)</code><p id="c7ff27d5-0f7b-4e3b-a410-355c2b2d3cb7" class="">This happens when the input list is already sorted. In this case, selection sort only needs to pass through the list once to confirm that it is sorted.</p></li></ul><h3 id="142a6009-859d-4618-b1fd-fdc4444e12ec" class="">Space Complexity of Selection Sort</h3><ul id="3ff87125-5380-4f93-901e-28c187ac3702" class="bulleted-list"><li style="list-style-type:disc"><strong>Space complexity of Selection Sort:</strong> <code>O(1)</code><p id="03751e93-d40d-4518-862c-f792d4b40f17" class="">Selection sort is an in-place sorting algorithm that only uses a constant amount of extra space to hold the current minimum element and its index, regardless of the size of the input array.</p></li></ul><p id="3631dec4-ec5c-442c-a3cb-4b773779b9b7" class="">
</p><h2 id="5eb3cd72-bdc7-4c54-9458-21f689500e1c" class="block-color-default"><mark class="highlight-blue">Activity 1</mark></h2><p id="55f0f8c9-32c5-4cd8-b899-a1de2bdb2bac" class=""><strong>Guess the word:</strong></p><ol type="1" id="f18be4d1-f55f-4968-9a11-4f9764572a46" class="numbered-list" start="1"><li>What is the name of the sorting algorithm that repeatedly selects the smallest (or largest) element from the unsorted region and moves it into the sorted region?</li></ol><ol type="1" id="40064e20-dadf-4b0c-b350-b2bb9495dc41" class="numbered-list" start="2"><li>In Selection Sort, the algorithm starts at the beginning of the list and identifies the ______ element. <em>(Hint: The element with the lowest value) </em></li></ol><ol type="1" id="fbb48ceb-c22e-4c81-9bba-b23df3b108f2" class="numbered-list" start="3"><li>After identifying the smallest element in Selection Sort, it is swapped with the ______ element of the list. <em>(Hint: The element at the beginning of the unsorted portion)</em></li></ol><ol type="1" id="11e072cb-fa63-4308-9a6e-06da0ef4e6f4" class="numbered-list" start="4"><li>Selection Sort continues moving to the next element in the unsorted portion and identifies the smallest element in that portion until it reaches the ______ of the list. <em>(Hint: The final element)</em></li></ol><ol type="1" id="6dcc85e6-aeb5-4474-bafe-859a06f071ca" class="numbered-list" start="5"><li>Selection Sort has a worst-case time complexity of ______. <em>(Hint: A mathematical notation for a polynomial function)</em></li></ol><ul id="411fab13-4295-4dcb-bac7-0f2ea48539bb" class="toggle"><li><details close=""><summary><strong>Answer</strong></summary><ol type="1" id="5d7af29f-31cb-43a9-bc7c-7ae3546aa26c" class="numbered-list" start="1"><li>Selection Sort</li></ol><ol type="1" id="776f1933-6a38-40c4-a34e-caf65dfc6eaf" class="numbered-list" start="2"><li>Smallest</li></ol><ol type="1" id="687caf0e-6d6c-4569-baaa-55398907ab14" class="numbered-list" start="3"><li>First</li></ol><ol type="1" id="c7e72d10-c4a7-4a94-a182-ab1a4f71e32c" class="numbered-list" start="4"><li>End</li></ol><ol type="1" id="6ac1729b-5714-41ad-b101-fc51bb1d50f8" class="numbered-list" start="5"><li>O(n^2)</li></ol></details></li></ul><p id="36874339-1cf3-414a-b48c-4fd697790b97" class="">
</p><h2 id="0416257d-6aff-4267-b5fc-2fb538751f68" class="block-color-default"><mark class="highlight-red">Introduction to Insertion Sort</mark></h2><p id="8fa84a8f-e935-48ec-9d51-d83e7c3661bd" class="">Insertion sort is another simple comparison-based sorting algorithm. It works by dividing the input into a sorted and an unsorted region. The sorted region is initially just the first element, while the unsorted region contains all the other elements. The algorithm repeatedly takes the first element from the unsorted region and inserts it into the correct position in the sorted region. This process continues until the unsorted region is empty and the sorted region contains all the elements.</p><p id="d6300788-d7d9-4a9f-b88d-26afb8503ab3" class="">The algorithm maintains two subarrays in a given array.</p><ul id="277859ec-a164-4b8a-9510-c5f1bc3ae822" class="bulleted-list"><li style="list-style-type:disc"><strong>Sorted Subarray :</strong> The subarray which is already sorted.</li></ul><ul id="cbd79ceb-c411-48a4-abd3-02ec01104229" class="bulleted-list"><li style="list-style-type:disc"><strong>Unsorted Subarray :</strong> The remaining subarray which is unsorted.</li></ul><h3 id="b9469eea-8ec6-4880-b569-af32fa6e2798" class=""><strong>Working of Insertion Sort</strong></h3><ol type="1" id="117bed59-69d0-4879-8559-09d3672222d4" class="numbered-list" start="1"><li><strong>Start with the Second Element</strong>: Begin with the second element of the list. Assume that the first element is already sorted.</li></ol><ol type="1" id="5eb15f08-639a-4a5b-9f01-1bcafb1a7dda" class="numbered-list" start="2"><li><strong>Compare and Insert</strong>: Compare the second element with the elements in the sorted portion of the list. Insert the second element at the correct position in the sorted portion, shifting other elements as needed.</li></ol><ol type="1" id="06b8a78d-f2c1-4e6d-ac32-9c9376d92a59" class="numbered-list" start="3"><li><strong>Move to the Next Element</strong>: Move one position to the right and consider it as the next element in the unsorted portion of the list.</li></ol><ol type="1" id="5f9d8984-858d-414c-bd74-8ba02ff684e0" class="numbered-list" start="4"><li><strong>Compare and Insert Again</strong>: Compare the new element with the elements in the sorted portion of the list. Insert the element at its correct position in the sorted portion, shifting other elements if necessary.</li></ol><ol type="1" id="4e19dd26-aebb-4fb5-852d-f4ec1b84ea47" class="numbered-list" start="5"><li><strong>Repeat Until the List is Sorted</strong>: Continue this process, moving to the next unsorted element and inserting it into the correct position within the sorted portion, until all elements are sorted.</li></ol><ol type="1" id="e4058f64-d783-4960-be38-aa91f9aaec34" class="numbered-list" start="6"><li><strong>List is Fully Sorted</strong>: Once all elements have been inserted into their correct positions, the list is fully sorted.</li></ol><figure id="5a0ac0c1-d873-4b2e-bd69-d601c0499b47" class="image"><img style="width:2388px" src="Introduction%20to%20Sorting%20Algorithms%207444ff59428a454d8e3f830c5f0107ce/Screenshot_2023-05-08_at_7.18.19_PM.png"/></a></figure><h3 id="3f4c9dbc-1a84-4ca9-b5f2-c7e766667a4d" class="block-color-default"><strong>Implementation of Insertion Sort</strong></h3><pre id="5dd0c63a-866d-4870-addc-a7bbc8d0101e" class="code"><code>function insertionSort(arr) {
  for (let i = 1; i &lt; arr.length; i++) {
    let key = arr[i];
    let j = i - 1;
    
    while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {
      arr[j + 1] = arr[j];
      j--;
    }
    
    arr[j + 1] = key;
  }
  
  return arr;
}

// Example usage
let arr = [5, 3, 6, 2, 10];
console.log(insertionSort(arr)); // [2, 3, 5, 6, 10]</code></pre><ul id="bf1f08e9-ab31-4568-8f33-4d0f5c5b27a1" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="5b229bf9-a6af-4590-9b63-e9ffe1b19f1d" class="numbered-list" start="1"><li>The <code>insertionSort</code> function takes an array <code>arr</code> as input.</li></ol><ol type="1" id="f67f20d5-ba2a-4270-b5b7-e4eaf386056f" class="numbered-list" start="2"><li>It iterates through the array using a <code>for</code> loop, starting from the second element (<code>i = 1</code>) and continuing until the last element (<code>i &lt; arr.length</code>).</li></ol><ol type="1" id="63fff6a7-2378-43a2-a902-225877860efb" class="numbered-list" start="3"><li>Inside the loop, the current element is stored in the <code>key</code> variable.</li></ol><ol type="1" id="f88facd4-92c9-445b-bf68-f7dc851f5670" class="numbered-list" start="4"><li>Another variable <code>j</code> is initialized to <code>i - 1</code>, representing the index of the previous element.</li></ol><ol type="1" id="f9ae1c1e-1f9b-492e-9ad1-b1b853fe98eb" class="numbered-list" start="5"><li>A <code>while</code> loop is used to compare the <code>key</code> with the elements before it, iterating as long as <code>j</code> is greater than or equal to 0 and the element at <code>arr[j]</code> is greater than the <code>key</code>.</li></ol><ol type="1" id="90508d43-19db-43a0-a8c6-a09ba9db9d2b" class="numbered-list" start="6"><li>If the condition in the <code>while</code> loop is true, it means the previous element needs to be moved one position ahead to make space for the <code>key</code>. The element at <code>arr[j]</code> is shifted to the right by assigning it to <code>arr[j + 1]</code>.</li></ol><ol type="1" id="dc713962-1619-4b54-afa4-dc144fd01f4d" class="numbered-list" start="7"><li>The <code>j</code> index is decremented (<code>j--</code>) to continue comparing the <code>key</code> with the previous elements.</li></ol><ol type="1" id="0e58b95b-b14c-4a07-9ed5-12e29c0beaa5" class="numbered-list" start="8"><li>Once the <code>while</code> loop condition becomes false, the correct position for the <code>key</code> in the sorted portion of the array is found, and it is inserted at <code>arr[j + 1]</code>.</li></ol><ol type="1" id="3d3fae3e-619d-436c-b6b0-82e55d78a61e" class="numbered-list" start="9"><li>The <code>for</code> loop continues with the next element, repeating the process until all elements are sorted.</li></ol><ol type="1" id="adec9dfe-b023-495e-88f5-be745b945f13" class="numbered-list" start="10"><li>Finally, the sorted array <code>arr</code> is returned from the <code>insertionSort</code> function.</li></ol></details></li></ul><h3 id="3f91f3aa-3bf2-49d1-a79b-6e6ae1a5e49f" class=""><strong>Time Complexity of Insertion Sort</strong></h3><ul id="7a0da4e0-dd54-4527-9f3d-05eb69411596" class="bulleted-list"><li style="list-style-type:disc"><strong>Worst-case time complexity:</strong> <code>O(n^2)</code><p id="1eefc593-8a3f-4a87-8d87-84980e72e4ac" class="">The worst-case scenario for insertion sort occurs when the array is sorted in reverse order, and we want to sort it in ascending order. In this case, each element needs to be compared and shifted to its correct position, resulting in a quadratic time complexity.</p></li></ul><ul id="247ffbc5-5287-467c-84d2-f2bff24bd6a3" class="bulleted-list"><li style="list-style-type:disc"><strong>Average-case time complexity:</strong> <code>O(n^2)</code><p id="abbc6800-59ad-4ff1-ad54-c77e48685656" class="">On average, insertion sort also requires quadratic time to sort the elements. This occurs when the input array is randomly shuffled or has no specific pattern.</p></li></ul><ul id="358d2c86-ba37-4c20-b181-684711744ce9" class="bulleted-list"><li style="list-style-type:disc"><strong>Best-case time complexity:</strong> <code>O(n)</code><p id="23029c7a-1b17-4228-9f97-76842c45910b" class="">The best-case scenario for insertion sort occurs when the input array is already sorted in ascending order. In this case, the algorithm makes a single pass through the array, comparing each element to its previous element and making no shifts. This results in a linear time complexity.</p></li></ul><h3 id="345a40d7-8c5a-4d14-85a7-3ffdce01334c" class=""><strong>Space Complexity of Insertion Sort</strong></h3><ul id="5e3031e2-c559-491f-8639-dc9f50078c6b" class="bulleted-list"><li style="list-style-type:disc"><strong>Space complexity of Insertion Sort:</strong> <code>O(1)</code><p id="eb380efd-1b58-4a61-81d8-fea286ef67da" class="">Insertion sort is an in-place sorting algorithm, meaning it does not require additional space proportional to the input size. It performs sorting operations directly on the input array, using a constant amount of extra space for variables and temporary storage, regardless of the size of the input array.</p></li></ul><h2 id="f5871119-2fbd-430e-9aa2-3e348710d9b2" class="block-color-default"><mark class="highlight-red">Introduction to Merge Sort</mark></h2><p id="c8e3b116-4dd2-4fea-b05b-10094f4b91e6" class="">Merge sort is a <strong>divide-and-conquer</strong> algorithm that works by dividing an array into two halves, sorting each half, and then merging the two halves. The algorithm is <strong>recursive</strong>, meaning it continues dividing the sub-arrays until they are small enough to be sorted easily.</p><h3 id="06c3068b-1a5c-4d10-9f5e-63c8fad87ca2" class=""><strong>Working of Merge Sort</strong></h3><ol type="1" id="37c6d9a5-6567-4c37-b2f0-4ff1dcc3a810" class="numbered-list" start="1"><li><strong>Divide</strong>: Divide the unsorted array into two equal-sized subarrays. This step is recursively applied until each subarray contains only one element. This can be done by repeatedly dividing the array in half.</li></ol><ol type="1" id="e3911d44-1ded-4b96-b003-63306bf0935b" class="numbered-list" start="2"><li><strong>Merge</strong>: Merge the subarrays in a sorted manner to produce a new sorted array. This is done by comparing the elements from the two subarrays and selecting the smaller element to place in the merged array. Continue this process until all elements from both subarrays are merged into a single sorted array.</li></ol><ol type="1" id="f42fd186-97d8-4346-bd7b-b33088121e6b" class="numbered-list" start="3"><li><strong>Recursion</strong>: Recursively repeat the divide and merge steps on the subarrays until all subarrays have been sorted and merged into a single sorted array.</li></ol><ol type="1" id="74ba8699-3435-45ff-9605-bc44c240edcc" class="numbered-list" start="4"><li><strong>Complete Merge</strong>: After merging all subarrays, the original unsorted array will be completely sorted.</li></ol><figure id="d64bd8d6-f888-4112-b635-e1f00209240f" class="image"><img style="width:2426px" src="Introduction%20to%20Sorting%20Algorithms%207444ff59428a454d8e3f830c5f0107ce/Screenshot_2023-05-08_at_7.44.17_PM.png"/></a></figure><h3 id="0ad7ac65-3e65-4618-a36d-1a281b581058" class="block-color-default"><strong>Implementation of Merge Sort</strong></h3><p id="a3f51712-2254-4dde-a061-04658fa0c5bf" class="">Here is an example implementation of merge sort in JavaScript:</p><pre id="bfcff8e0-a23a-4eba-8ea3-211571ea38b4" class="code code-wrap"><code>function mergeSort(arr) {
  // Base case: If the array has only one element, it is already sorted
  if (arr.length &lt;= 1) {
    return arr;
  }

  // Split the array into two halves
  const mid = Math.floor(arr.length / 2);
  const leftHalf = arr.slice(0, mid);
  const rightHalf = arr.slice(mid);

  // Recursively sort the left and right halves
  const sortedLeft = mergeSort(leftHalf);
  const sortedRight = mergeSort(rightHalf);

  // Merge the sorted halves
  return merge(sortedLeft, sortedRight);
}

function merge(leftArr, rightArr) {
  const mergedArr = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // Compare elements from the left and right arrays and merge them in sorted order
  while (leftIndex &lt; leftArr.length &amp;&amp; rightIndex &lt; rightArr.length) {
    if (leftArr[leftIndex] &lt; rightArr[rightIndex]) {
      mergedArr.push(leftArr[leftIndex]);
      leftIndex++;
    } else {
      mergedArr.push(rightArr[rightIndex]);
      rightIndex++;
    }
  }

  // Add the remaining elements from the left or right array (if any)
  mergedArr.push(...leftArr.slice(leftIndex));
  mergedArr.push(...rightArr.slice(rightIndex));

  return mergedArr;
}

// Example usage
const arr = [6, 5, 3, 1, 8, 7, 2, 4];
const sortedArr = mergeSort(arr);
console.log(sortedArr); // [1, 2, 3, 4, 5, 6, 7, 8]</code></pre><ul id="383ad561-cbf4-45c5-be48-8c57b883dc74" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="710a3762-28ac-4058-b732-d5fc369c89f5" class="numbered-list" start="1"><li>The <code>mergeSort</code> function takes an array <code>arr</code> as input and recursively divides it into smaller halves until each subarray has only one element or is empty. This is done using the concept of divide and conquer.</li></ol><ol type="1" id="dc66538e-7eab-4eb2-8bf9-66c981a0ca44" class="numbered-list" start="2"><li>The base case checks if the array has only one element or is empty. In such cases, the array is already sorted, so it is returned as is.</li></ol><ol type="1" id="8a88501d-fef7-4d30-b716-493a5e99f3d2" class="numbered-list" start="3"><li>If the array has more than one element, it is split into two halves using the <code>slice</code> method. The midpoint of the array is calculated to determine the split.</li></ol><ol type="1" id="74311807-3e9c-476f-b866-772a204e1c6c" class="numbered-list" start="4"><li>The <code>mergeSort</code> function is then called recursively on the left and right halves to sort them individually.</li></ol><ol type="1" id="0c0f2097-e464-4b3a-9c20-06f8b464b9e7" class="numbered-list" start="5"><li>The <code>merge</code> function is responsible for merging the sorted left and right halves back into a single sorted array. It compares the elements from the two arrays and adds them to a new array, <code>mergedArr</code>, in sorted order.</li></ol><ol type="1" id="fe219167-d786-4c0d-aed8-c365859e90c3" class="numbered-list" start="6"><li>The elements are compared one by one using two index pointers (<code>leftIndex</code> and <code>rightIndex</code>) that iterate through the left and right arrays, respectively. The smaller element is added to <code>mergedArr</code>, and the corresponding index is incremented.</li></ol><ol type="1" id="78c16b3c-316b-4424-adda-f136d40febe7" class="numbered-list" start="7"><li>After the comparison and merging process, any remaining elements in either the left or right array are added to <code>mergedArr</code> using the <code>slice</code> method and the spread operator (<code>...</code>).</li></ol><ol type="1" id="c426e0cd-880d-4baa-8ad7-53837922b08b" class="numbered-list" start="8"><li>Finally, the sorted array is returned from the <code>mergeSort</code> function</li></ol></details></li></ul><h3 id="ae888ffe-aada-45df-b3c6-9254cbd5ceec" class=""><strong>Time Complexity of Merge Sort</strong></h3><ul id="2b6ea526-e69b-45c0-b379-45c3352d41c7" class="bulleted-list"><li style="list-style-type:disc"><strong>Worst-case time complexity:</strong> <code>O(n log n)</code><p id="da9c763f-bdfb-4f85-bb9d-5ee9ec3e4763" class="">The worst-case scenario for merge sort occurs when we have to recursively split the array until we reach individual elements and then merge them back together. In this case, the time complexity is logarithmic due to the recursive nature of the algorithm and the merging step.</p></li></ul><ul id="3ceab765-f66a-4cf5-bbb5-96c4eea14542" class="bulleted-list"><li style="list-style-type:disc"><strong>Average-case time complexity:</strong> <code>O(n log n)</code><p id="8b9d580e-44fc-471a-9c17-0ae5b262d1ba" class="">On average, merge sort also has a time complexity of n log n. It consistently divides the array into halves and performs merging operations. This results in efficient sorting even for large input sizes.</p></li></ul><ul id="82420278-e952-4548-bc23-f093d1ee2214" class="bulleted-list"><li style="list-style-type:disc"><strong>Best-case time complexity:</strong> <code>O(n log n)</code><p id="543f352a-3d11-4d43-a76a-e868debbd798" class="">The best-case scenario for merge sort also has a time complexity of n log n. Regardless of the initial order of the elements, merge sort divides the array into halves until each subarray contains a single element and then merges them back together. This guarantees the time complexity of n log n.</p></li></ul><h3 id="bad87f5f-e9ed-4463-8d20-5f7453182627" class=""><strong>Space Complexity of Merge Sort</strong></h3><ul id="ec59ff16-6273-49db-b82b-80816873d567" class="bulleted-list"><li style="list-style-type:disc"><strong>Space complexity of Merge Sort:</strong> <code>O(n)</code><p id="66e249ea-bc56-405d-b257-2a5209720c9d" class="">Merge sort requires additional space to store temporary arrays during the merging process. The space complexity is directly proportional to the size of the input array. However, the auxiliary space used is not dependent on the order of the elements or the input size. Therefore, the space complexity of merge sort is considered linear.</p></li></ul><p id="4191ab7e-45fd-4d0a-a9fd-7f865d60d175" class="">
</p><h2 id="b843a55f-b433-45f0-a38f-711cf836e6cf" class="block-color-default"><mark class="highlight-blue">Activity 2</mark></h2><ol type="1" id="8f6549b4-45ad-4da9-a550-f0c61d5023a0" class="numbered-list" start="1"><li>Merge sort is a _________ <strong>(Greedy/Divide-and-conquer/Dynamic programming)</strong> algorithm.</li></ol><ol type="1" id="79d7a1e6-e34d-41ab-bcd6-8c21a79f6005" class="numbered-list" start="2"><li>Merge sort has a time complexity of _________ <strong>(O(n)/O(n log n)/O(n^2))</strong>.</li></ol><ol type="1" id="ad46aebc-a6f5-4e63-b25b-98f6fcb13c42" class="numbered-list" start="3"><li>In merge sort, the two sorted subarrays are merged together using the _________<strong> (split/merge/concat) </strong>function.</li></ol><ol type="1" id="6816682c-7c3b-4278-9725-d5880c851504" class="numbered-list" start="4"><li>In insertion sort, the number of swaps required to sort an array is __________<strong> (equal/proportional/less than)</strong> to the number of inversions in the array. </li></ol><ol type="1" id="9c7b920d-8056-4835-9523-dbb243011297" class="numbered-list" start="5"><li>The time complexity of insertion sort is __________ <strong>(O(n)/O(n log n)/O(n^2))</strong>. </li></ol><ul id="e2b56107-788a-4255-9255-4849234db4be" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><ol type="1" id="2f8cae18-5a20-40ca-a9c3-ab7d8d2af73b" class="numbered-list" start="1"><li>Divide-and-conquer</li></ol><ol type="1" id="9ca329fb-ae48-4dbb-a696-4d6b363a6bd9" class="numbered-list" start="2"><li>O(n log n)</li></ol><ol type="1" id="f11757cc-8c4f-44bd-8042-af4eddae06d2" class="numbered-list" start="3"><li>merge</li></ol><ol type="1" id="94a75d79-0e23-4716-bb22-53587a4d499f" class="numbered-list" start="4"><li>equal</li></ol><ol type="1" id="4f70f85a-4064-41e2-b4db-acbc835547b5" class="numbered-list" start="5"><li>O(n^2)</li></ol></details></li></ul><p id="f5a9d33e-db15-4de1-91ce-a03290134dd7" class="">
</p><h2 id="be79f0b8-c152-431c-acae-a6c3584f2a13" class="block-color-default"><mark class="highlight-red">Introduction to Quick Sort</mark></h2><p id="4bf1f716-1fe5-415f-b813-3605c919377f" class="">Quick Sort is a commonly used sorting algorithm that uses a <strong>divide-and-conquer </strong>approach to sort an array of elements. It works by selecting a<strong> &#x27;pivot&#x27; </strong>element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. This can be done in-place, requiring small additional amounts of memory to perform the sorting.</p><h3 id="b755a741-2b12-4e13-9f63-71a47e136f2d" class=""><strong>Working of Quick Sort</strong></h3><ol type="1" id="92aba713-858c-4a08-8190-0d26cb188a6c" class="numbered-list" start="1"><li><strong>Choose a Pivot</strong>: Select a pivot element from the list. The pivot can be any element, but it&#x27;s common to choose the last element or a random element.</li></ol><ol type="1" id="5e2fe21b-bf3b-44bc-8452-becc591fe585" class="numbered-list" start="2"><li><strong>Partitioning</strong>: Reorder the list so that all elements less than the pivot come before it, and all elements greater than the pivot come after it. The pivot should be in its final sorted position.</li></ol><ol type="1" id="df24a203-277a-4af6-99ba-3a6c89867fe9" class="numbered-list" start="3"><li><strong>Recursive Sort</strong>: Recursively apply the above two steps to the sublists formed by the partitioning. That is, select a pivot for each sublist and partition the sublist until all sublists are sorted.</li></ol><ol type="1" id="306a5e69-a77e-4971-babb-5ff7bee3f237" class="numbered-list" start="4"><li><strong>Combine the Sorted Sublists</strong>: Once all sublists are sorted, combine them to obtain the final sorted list.</li></ol><p id="652fee86-967c-45f0-bc39-e3bfffa46da7" class="">Repeat steps 1 to 4 until the entire list is sorted. The pivot selection and partitioning steps play a crucial role in the efficiency of the quicksort algorithm. By selecting a good pivot and efficiently partitioning the list, quicksort achieves a fast average-case time complexity.</p><figure id="cf8dd144-e41a-42f1-949b-afaa33d40b84" class="image"><img style="width:2442px" src="Introduction%20to%20Sorting%20Algorithms%207444ff59428a454d8e3f830c5f0107ce/Screenshot_2023-05-08_at_7.44.50_PM.png"/></a></figure><h3 id="254c5b59-039b-4125-9898-e61e3bee1c1b" class="block-color-default">Implementation of Quick Sort </h3><pre id="015a4ebd-d036-4771-9fe3-9330c1d3e0f8" class="code code-wrap"><code>function quickSort(arr) {
  if (arr.length &lt;= 1) {
    return arr;
  }

  const pivot = arr[arr.length - 1];
  const left = [];
  const right = [];

  for (let i = 0; i &lt; arr.length - 1; i++) {
    if (arr[i] &lt; pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  return [...quickSort(left), pivot, ...quickSort(right)];
}

// Example usage
const arr = [5, 3, 6, 2, 10];
console.log(quickSort(arr)); // [2, 3, 5, 6, 10]</code></pre><ul id="642e90e7-9f79-4abf-bfcc-7737be87a911" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="16dc2d47-58f1-4837-95b8-2032b4cb7e64" class="numbered-list" start="1"><li>The <code>quickSort</code> function takes an array <code>arr</code> as input.</li></ol><ol type="1" id="a2f94e03-73f4-4252-a5c9-104f577e4584" class="numbered-list" start="2"><li>If the array has one or fewer elements, it is already considered sorted and is returned as is.</li></ol><ol type="1" id="68b243ec-934c-498d-840b-233bb9e32d59" class="numbered-list" start="3"><li>Otherwise, a pivot element is chosen. In this implementation, we select the last element of the array as the pivot.</li></ol><ol type="1" id="94ae4fa4-eced-435e-9fe7-c166cc1e7eb3" class="numbered-list" start="4"><li>We create two empty arrays, <code>left</code> and <code>right</code>, to hold elements less than the pivot and elements greater than or equal to the pivot, respectively.</li></ol><ol type="1" id="8c221586-71da-47f1-b0b1-f36deb5aa026" class="numbered-list" start="5"><li>We iterate through the array (excluding the pivot) and compare each element to the pivot. Elements smaller than the pivot are added to the <code>left</code> array, and elements greater than or equal to the pivot are added to the <code>right</code> array.</li></ol><ol type="1" id="0bd1d164-e3bd-4ffc-a381-89575016e4db" class="numbered-list" start="6"><li>We recursively apply the <code>quickSort</code> function to the <code>left</code> and <code>right</code> arrays, which sorts them independently.</li></ol><ol type="1" id="d30dbe65-9781-40f9-a18c-944aa99d2a58" class="numbered-list" start="7"><li>Finally, we combine the sorted <code>left</code> array, pivot, and sorted <code>right</code> array using the spread operator (<code>...</code>) to obtain the final sorted array.</li></ol></details></li></ul><h3 id="f907298d-a252-479c-8d4d-29c5f7a97f51" class=""><strong>Time Complexity of Quick Sort</strong></h3><ul id="6a6248b1-f872-42d4-a1d0-d793101a13b3" class="bulleted-list"><li style="list-style-type:disc"><strong>Worst-case time complexity:</strong> <code>O(n^2)</code><p id="1c056788-205b-4922-afdb-dba3b7d939aa" class="">The worst-case scenario for quicksort occurs when the pivot selection is poor, leading to highly unbalanced partitions. This can happen, for example, when the input array is already sorted or nearly sorted. In this case, the algorithm may make <code>n</code> recursive calls, each dealing with only one fewer element, resulting in a quadratic time complexity.</p></li></ul><ul id="2b11f2f7-a15a-4787-8a1f-dde79825e395" class="bulleted-list"><li style="list-style-type:disc"><strong>Average-case time complexity:</strong> <code>O(n log n)</code><p id="787be434-7a36-4f13-8625-8dde6a1ce96d" class="">On average, quicksort has a time complexity of <code>O(n log n)</code>. This is because, on average, the partitioning process splits the array into two roughly equal halves. Each recursive call deals with approximately half of the elements, leading to a balanced divide-and-conquer approach.</p></li></ul><ul id="17014048-8f66-4e99-9d85-c172042b1f9b" class="bulleted-list"><li style="list-style-type:disc"><strong>Best-case time complexity:</strong> <code>O(n log n)</code><p id="337f6139-c5d2-4313-bf9b-613dbd9794f4" class="">The best-case scenario for quicksort occurs when the pivot selection consistently divides the array into two equal or almost equal halves. This results in an efficient divide-and-conquer strategy, leading to a time complexity of <code>O(n log n)</code>.</p></li></ul><h3 id="c8b23105-574e-43b7-bea4-b86126cfe560" class=""><strong>Space Complexity of Quick Sort</strong></h3><ul id="a28f2701-0d9f-4028-ba7e-51643f57e7b3" class="bulleted-list"><li style="list-style-type:disc"><strong>Space complexity of Quick Sort:</strong> <code>O(log n)</code><p id="b7093865-58ec-4caa-ab79-787395a2895f" class="">Quicksort generally has a space complexity of <code>O(log n)</code> due to the recursive calls and the partitioning process. This represents the maximum amount of space required by the call stack to handle the recursive calls. However, quicksort is an in-place sorting algorithm, meaning it does not require additional space proportional to the input size. It operates directly on the input array, using only a small amount of extra space for variables and temporary storage during the sorting process.</p></li></ul><p id="d47c0648-57c7-4ed0-816b-03929ec3a040" class="">
</p><h2 id="353b8a4c-7e48-4cfc-894b-1595deac9562" class="block-color-default"><mark class="highlight-blue">Explore Further</mark></h2><p id="80fd8dc1-3ebe-4995-bc82-aa6fbb93f0a7" class=""><mark class="highlight-orange"><strong>Uncover and unlock new insights as you dive into the captivating content found in the provided link.</strong></mark></p><p id="a0a64aaa-018b-4b0d-bb17-41ef67c70dbb" class=""><strong>Stability analysis of Sorting Algorithms: </strong><a href="https://trstringer.com/sorting-stability/">https://trstringer.com/sorting-stability/</a></p><p id="c3e5ea70-6dc1-4c03-801a-389950f9f1b5" class="">
</p><p id="90faa7dc-a100-42a7-9c00-2c62f4ec54ab" class=""><mark class="highlight-orange"><strong>Tackle these questions head-on!</strong></mark></p><p id="f2094392-d58c-430b-93de-51ffff6d1791" class=""><strong>Agree/Disagree:</strong></p><ol type="1" id="8c817965-5829-45c3-9c52-e6eda3e08b28" class="numbered-list" start="1"><li>When considering sorting algorithms, stability becomes a significant factor only in the presence of multiple elements sharing the same sorting keys. </li></ol><ol type="1" id="04300a0e-421d-4fa2-983c-f148ca54baff" class="numbered-list" start="2"><li>The relative order of elements with identical keys holds no relevance in the context of sorting algorithms. </li></ol><ol type="1" id="bc53224f-65b2-48b8-9461-7dfd28962303" class="numbered-list" start="3"><li>Stability in sorting algorithms ensures the consistent preservation of the relative order of elements sharing the same key. </li></ol><ol type="1" id="d27a9ac6-9ded-42e3-ac92-7303b96b7db5" class="numbered-list" start="4"><li>Achieving stability in inherently unstable sorting algorithms is an impossible endeavor. </li></ol><ol type="1" id="f1a0e915-dc1f-498f-a6d0-22ecc8172413" class="numbered-list" start="5"><li>The need for preserving the order of elements with identical keys seldom arises in practical, real-world scenarios. </li></ol><ol type="1" id="c0405a50-88e2-4e01-8532-83da1aacec72" class="numbered-list" start="6"><li>The transitional order of elements within sorting algorithms during their execution holds no significance or impact on the final outcome. </li></ol><ul id="da8e787e-e00c-4861-8e27-80c226d44e94" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><ol type="1" id="d3db1f80-bb0a-4844-9255-8d501c2a701a" class="numbered-list" start="1"><li>Disagree</li></ol><ol type="1" id="c532b138-2ec1-462f-a6ab-36f903c8316c" class="numbered-list" start="2"><li>Disagree</li></ol><ol type="1" id="98b775da-d33e-487f-a41c-2a16bf500a8b" class="numbered-list" start="3"><li>Agree</li></ol><ol type="1" id="2908e5ba-8cfe-4389-90a5-84935a5062ee" class="numbered-list" start="4"><li>Agree</li></ol><ol type="1" id="ee93c2b5-1274-4009-9e24-84ecc9822197" class="numbered-list" start="5"><li>Disagree</li></ol><ol type="1" id="a4f98ad0-db14-4d2b-aa72-a37e80eabcd5" class="numbered-list" start="6"><li>Disagree</li></ol></details></li></ul><p id="1be0b5cd-1060-43d5-b346-163ee0732204" class="">
</p><h1 id="aa49b442-91c9-4871-80d1-ba8bd47bcd62" class=""><mark class="highlight-brown">Summary </mark></h1><h2 id="b132b9d5-a12f-49a6-b292-8af79824504a" class="block-color-default"><mark class="highlight-red">What did we learn?</mark></h2><ul id="be67ac90-4e23-43df-9aec-fcb864832193" class="bulleted-list"><li style="list-style-type:disc">Bubble Sort is a simple sorting algorithm that repeatedly compares adjacent elements and swaps them if they are in the wrong order until the list is sorted.</li></ul><ul id="c26c8272-d8a1-489c-90aa-5c44656e2e83" class="bulleted-list"><li style="list-style-type:disc">The time complexity of bubble sort is <code>O(n^2)</code> and space complexity is <code>O(1)</code>.</li></ul><ul id="af370a8e-f5a0-43a6-9349-daf322e0f359" class="bulleted-list"><li style="list-style-type:disc">Selection sort is a simple sorting algorithm that works by selecting the smallest element and swapping it with the first element of the unsorted array.</li></ul><ul id="8748b191-62af-40b8-b45f-e12a1cbabc86" class="bulleted-list"><li style="list-style-type:disc">The time complexity of selection sort is <code>O(n^2)</code>, which makes it inefficient for large data sets.</li></ul><ul id="e5c8577b-ccbc-40da-afed-7546dde00c7b" class="bulleted-list"><li style="list-style-type:disc">Selection sort is stable and adaptable to various data types. It is also an in-place sorting algorithm, which means it has <code>O(1)</code> space complexity.</li></ul><ul id="c323d7c8-2bd8-4932-b7d3-cdb96ae69e83" class="bulleted-list"><li style="list-style-type:disc">Insertion Sort is a simple sorting algorithm that works by repeatedly inserting an element from an unsorted list into its correct position in a sorted list.</li></ul><ul id="daf56137-88f3-4e68-8ed8-2b76c4dbf6ac" class="bulleted-list"><li style="list-style-type:disc">It maintains two subarrays in a given array: Sorted Subarray and Unsorted Subarray.</li></ul><ul id="3c7a7bca-4963-41af-b13d-fa3fd12894f4" class="bulleted-list"><li style="list-style-type:disc">The time complexity of Insertion sort is <code>O(n^2)</code> in average and worst cases, and O(n) in the best case, while its space complexity is <code>O(1)</code>.</li></ul><ul id="4db8138b-3d04-43f6-8a2f-17c040d8d0b9" class="bulleted-list"><li style="list-style-type:disc">Merge sort is a divide-and-conquer algorithm that recursively divides an array into halves until it reaches atomic values, sorts each half, and then merges them back together.</li></ul><ul id="25ba9c77-be9b-45b7-950b-f0fdda67c171" class="bulleted-list"><li style="list-style-type:disc">The algorithm has a time complexity of <code>O(n log n)</code> and a space complexity of <code>O(n)</code>.</li></ul><ul id="f1a6c501-72f6-4d91-8546-e9e34c815aac" class="bulleted-list"><li style="list-style-type:disc">Quick Sort is a sorting algorithm that uses a divide-and-conquer approach to sort an array of elements.</li></ul><ul id="7b83cafa-dbd4-4803-8d0d-9bdbb5c20e84" class="bulleted-list"><li style="list-style-type:disc">Quick Sort has an average time complexity of <code>O(n log n),</code> making it a relatively fast sorting algorithm for large data sets. The worst-case time complexity of quick sort is <code>O(n^2)</code>.</li></ul><h2 id="64e5186c-dcfd-4579-b93b-c74151f45ddc" class="block-color-default"><mark class="highlight-red">Shortcomings &amp; Challenges</mark></h2><ul id="20aa1afb-033e-43c4-b3e6-3353c9160091" class="bulleted-list"><li style="list-style-type:disc">Understanding implementation of Selection sort and how it differs from other sorting algorithms can be challenging, as it performs more swaps and may be less efficient in terms of time complexity.</li></ul><ul id="13804891-3310-48b1-a701-41fc97fcc5b7" class="bulleted-list"><li style="list-style-type:disc">Novice learners may find it challenging to comprehend the nested loop structure and the mechanism of shifting elements to their rightful position within the sorted subarray in Insertion Sort.</li></ul><ul id="a47b8229-310b-44fa-bd51-ee9820d756bf" class="bulleted-list"><li style="list-style-type:disc">Partitioning the input array correctly is a crucial aspect of learning Quicksort, but this can be a challenging task.</li></ul><ul id="c806c3a0-29ff-46a6-b0ca-45ffde5a68db" class="bulleted-list"><li style="list-style-type:disc">Keeping track of the indices and array partitions involved in the sorting algorithms can be confusing, which often leads to errors in their implementation.</li></ul><h2 id="28ebfd98-ec7a-4ccc-a9d3-29a0f9bee85d" class="block-color-default"><mark class="highlight-red">Best Practices</mark></h2><ul id="7a900b9a-e1f4-44c8-a8a6-006549a8600f" class="bulleted-list"><li style="list-style-type:disc">Understand the logic and step-by-step process of sorting algorithms before implementation by reading the pseudocode and comprehending the code flow</li></ul><ul id="c6217364-4d46-411e-972a-e7c406093d44" class="bulleted-list"><li style="list-style-type:disc">Practice implementing the sorting algorithm in code with a simple example to identify potential challenges and pitfalls.</li></ul><ul id="c6367910-0f2f-405f-8f10-3a026250e045" class="bulleted-list"><li style="list-style-type:disc">Analyze time and space complexity to optimize sorting algorithm&#x27;s performance and memory usage.</li></ul><ul id="56416430-f33e-4bbf-a615-eadc6900e707" class="bulleted-list"><li style="list-style-type:disc">Comparing sorting algorithms helps identify their pros and cons, understand their differences, and determine which algorithm is most suitable for a particular use case.</li></ul><ul id="caa412b1-a9cc-49a7-b2a0-f243e4a37109" class="bulleted-list"><li style="list-style-type:disc">Regularly test your code on diverse inputs, including edge cases and extreme values, to identify and address any bugs or issues.</li></ul><h2 id="d905d4fe-6d72-4aad-8e02-822326ce8515" class="block-color-default"><mark class="highlight-red">Enhance Your Knowledge</mark></h2><ul id="bfb50ed1-3053-474c-9303-22fb8dc1280e" class="bulleted-list"><li style="list-style-type:disc"><a href="https://smithspencer817.medium.com/annotated-algorithms-bubble-sort-insertion-sort-and-selection-sort-d9df71eb6609">https://smithspencer817.medium.com/annotated-algorithms-bubble-sort-insertion-sort-and-selection-sort-d9df71eb6609</a></li></ul><ul id="b73da25e-18be-462b-84f8-78850fdca305" class="bulleted-list"><li style="list-style-type:disc"><a href="https://en.wikipedia.org/wiki/Merge_sort#:~:text=In%20computer%20science%2C%20merge%20sort,in%20the%20input%20and%20output">https://en.wikipedia.org/wiki/Merge_sort</a>.</li></ul><ul id="fd02f6af-71cf-4ff1-8883-811be6fff76c" class="bulleted-list"><li style="list-style-type:disc"><a href="https://en.wikipedia.org/wiki/Quicksort">https://en.wikipedia.org/wiki/Quicksort</a></li></ul></div></article></body></html>
