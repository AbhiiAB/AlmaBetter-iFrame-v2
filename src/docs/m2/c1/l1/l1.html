<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Getting Started with Algorithms</title><link rel="stylesheet" href="../../../../../styles.css"></head><body><article id="9f1b62cc-df8b-41bb-baae-271b61f53f82" class="page sans"><header><h1 class="page-title">Getting Started with Algorithms</h1><p class="page-description"></p></header><div class="page-body"><ul id="5c1e550a-805e-4c52-84c7-0b60fd5e1f74" class="toggle"><li><details close=""><summary><strong>Session Flow (5 minutes read)</strong></summary><ul id="4ed1a52a-755d-49ff-848b-5c7c2e66f677" class="bulleted-list"><li style="list-style-type:disc"><strong>Learning Objective (5 minutes read)</strong><ul id="9ace6c76-edf7-49e4-9471-33210a5bb45f" class="bulleted-list"><li style="list-style-type:circle">Introduction</li></ul><ul id="7834952a-4cba-45b7-abc7-7b90de99874f" class="bulleted-list"><li style="list-style-type:circle">Theme</li></ul><ul id="6f9b11d4-1705-400d-b211-d4570fe04cc2" class="bulleted-list"><li style="list-style-type:circle">Primary Goals</li></ul></li></ul><ul id="ccf3c877-cb10-4009-b5e5-cfe7310491de" class="bulleted-list"><li style="list-style-type:disc"><strong>Getting Started with Algorithms</strong> <strong>(120 minutes read)</strong><ul id="83edafab-b250-4eea-8957-4418a006651f" class="bulleted-list"><li style="list-style-type:circle">What is Data Structure?</li></ul><ul id="8480f165-c993-43d2-a16b-6fda3980e256" class="bulleted-list"><li style="list-style-type:circle">Classification of Data Structure<ul id="2b6a196e-1597-4072-919d-e1525b060c28" class="bulleted-list"><li style="list-style-type:square">Primitive Data Structure</li></ul><ul id="197c42da-e6be-4f94-8c0e-d72184f3b167" class="bulleted-list"><li style="list-style-type:square">Non-primitive Data Structure</li></ul></li></ul><ul id="9509f9a7-3867-4521-a565-00c08c23e6f9" class="bulleted-list"><li style="list-style-type:circle"><strong>Try it yourself</strong></li></ul><ul id="e9bc31a3-acec-48e5-95a2-cc7ccce17d51" class="bulleted-list"><li style="list-style-type:circle">What is an Algorithm?</li></ul><ul id="0373f45c-3896-4bb0-8e06-60dfbad08d2d" class="bulleted-list"><li style="list-style-type:circle">Algorithmic Analysis<ul id="6f08b134-31d7-4b47-b889-7bcb4754b799" class="bulleted-list"><li style="list-style-type:square">Space Complexity</li></ul><ul id="674c922e-6207-46ae-834d-760e2bcad564" class="bulleted-list"><li style="list-style-type:square">Time Complexity</li></ul></li></ul><ul id="091f2669-2ced-4a65-a7da-7201aa61b8e3" class="bulleted-list"><li style="list-style-type:circle"><strong>Activity</strong></li></ul><ul id="7c8efcec-2256-4b4d-acdf-5bc7e1077f5f" class="bulleted-list"><li style="list-style-type:circle">Introduction to Asymptotic Analysis<ul id="1aa72903-32fe-4ce7-aeff-924660a7c3a6" class="bulleted-list"><li style="list-style-type:square">Big-Oh/Big-O (O) Notation</li></ul><ul id="f191dce3-d00d-4ac9-91ff-dc4282a3486d" class="bulleted-list"><li style="list-style-type:square">Big Omega (Ω) Notation</li></ul><ul id="4a63346a-06e7-47a7-8c08-51d4ed81b71e" class="bulleted-list"><li style="list-style-type:square">Big Theta (Θ) Notation</li></ul><ul id="82e8828a-2bfd-44cb-9d31-2cdd842ced82" class="bulleted-list"><li style="list-style-type:square">Common Asymptotic Notations</li></ul></li></ul><ul id="a0d31c75-60c6-45af-9dda-33d19d1912a2" class="bulleted-list"><li style="list-style-type:circle">Why learn Data structures and Algorithms?</li></ul><ul id="92aa032e-b7d1-4a86-a527-6392c5ebeb53" class="bulleted-list"><li style="list-style-type:circle"><strong>Enhance Further</strong></li></ul></li></ul><ul id="aec41949-f34f-41f1-b889-95bba2210675" class="bulleted-list"><li style="list-style-type:disc"><strong>Summary (10 minutes read)</strong><ul id="38e92ffa-2ec2-4be4-a2b0-a7657d49cf2a" class="bulleted-list"><li style="list-style-type:circle">What did we learn?</li></ul><ul id="936bfe05-bf85-40ec-849d-b31a717c9c53" class="bulleted-list"><li style="list-style-type:circle">Shortcomings &amp; Challenges</li></ul><ul id="6a80b3ee-720c-46c7-b6d2-feede1bb5606" class="bulleted-list"><li style="list-style-type:circle">Best Practices</li></ul><ul id="66090c79-6b38-442d-b93c-8e1af855d5b2" class="bulleted-list"><li style="list-style-type:circle">Enhance Your Knowledge</li></ul></li></ul></details></li></ul><p id="00244d2e-5f05-4db9-8d9a-2a64888523d6" class="">
</p><h1 id="a0bfd7d5-e501-4ed8-9407-2c2d54934190" class=""><mark class="highlight-brown">Learning Objective</mark></h1><h2 id="de27d1a7-f940-4503-a2cc-6b4b6ec31bb6" class="block-color-default"><mark class="highlight-red">Introduction </mark></h2><p id="c6a0753d-4a2f-49a6-8edc-ae44161e0bfc" class="">Data structures are like the ingredients in a recipe, and algorithms are like the steps you follow to make the recipe. In computer science, data structures organize and store data, while algorithms manipulate and process that data. </p><p id="0913b8eb-5a8b-483c-89c7-91ddeab99cfd" class=""><strong>Duration:</strong> 2<strong> </strong>hours </p><p id="e698f2c8-d248-4214-917a-b7b59eba61ba" class=""><strong>Focus:</strong> What is Data structure, Classification of data structures, What is an algorithm, Algorithmic analysis, Introduction to Asymptotic Analysis,  Why to learn Data structure and algorithms</p><p id="1c212657-4c18-484e-8972-f4f18b3ba0df" class=""><strong>Prerequisites:</strong> JavaScript syntax and programming concepts, including variables, functions, loops, and conditionals.</p><h2 id="760e0922-a0e3-4853-a1ca-cd31ee0c9011" class="block-color-default"><mark class="highlight-red">Theme </mark></h2><p id="c07950f0-e9f5-4a36-82b4-294622017fe5" class="">Imagine you are a software developer working on a new project for a big tech company. You have been tasked with optimizing the code to make it run faster and more efficiently. How do you do that? </p><p id="5d4b112b-0b09-4d88-b9ec-bd3eaf0dc881" class="">By learning <strong>Data Structures and Algorithms</strong>, you can write more efficient code that runs faster and uses fewer resources. This is important for companies because it can save them money and improve the user experience of their products. <em>In fact, a report by </em><strong><em>Amazon</em></strong><em> found that for every 100ms increase in page load time, their revenue decreased by 1%.</em></p><p id="9103e9cb-e690-4362-8995-f4bebba294b1" class="">This emphasizes the crucial role played by data structures and algorithms in developing high-performance software systems. In this lesson, we will learn the fundamental concepts of data structures and algorithms and how to implement them in JavaScript.</p><h2 id="02f64b90-b247-4366-af2c-ba199a6e42f5" class="block-color-default"><mark class="highlight-red">Primary Goals</mark> </h2><ul id="428b3513-94cb-4329-bb38-ac02119b73c6" class="bulleted-list"><li style="list-style-type:disc">Understand the importance of data structures and algorithms in computer science and software development.</li></ul><ul id="c3c3439c-5e70-44fb-ab6a-c9bb9743f769" class="bulleted-list"><li style="list-style-type:disc">Learn the classification of data structures and their uses in organizing and storing data.</li></ul><ul id="148e1251-30e3-40bb-8892-1e38e33561bf" class="bulleted-list"><li style="list-style-type:disc">Understand the basics of algorithms and their role in manipulating and processing data.</li></ul><ul id="bb04e6d6-945d-4f91-b84a-68e31a43eea5" class="bulleted-list"><li style="list-style-type:disc">Learn how to analyze the efficiency of algorithms using time and space complexity.</li></ul><ul id="2a9cab70-122c-465d-976d-2111e9b1ffad" class="bulleted-list"><li style="list-style-type:disc">Understand the need for learning data structures and algorithms and how it can improve code performance and user experience.</li></ul><p id="76847d2a-47e7-4cd8-af56-5a80edaa0faa" class="">
</p><h1 id="5c467244-1232-417e-8262-fdca9ae76649" class=""><mark class="highlight-brown">Getting Started with Algorithms</mark></h1><p id="454f8804-29fd-4356-9790-024b8b9d0a6d" class="">Data structures are used to organize and store information to be easily accessed and manipulated. For example, when you use Google Maps, data structures store information about the roads, landmarks, and other points of interest in your area.</p><p id="70118da8-04cd-4a85-ae86-27d6721a47bf" class="">Algorithms, on the other hand, are a set of instructions that tell a computer how to solve a particular problem. In the case of Google Maps, algorithms are used to calculate the fastest route between two points by analyzing the data stored in its data structures.</p><h2 id="e4e07140-9f00-4d6f-9f5c-14ace48bf2ac" class="block-color-default"><mark class="highlight-red">What is Data structure?</mark></h2><p id="6a49e7aa-f3f4-4bc9-a668-8ae792247c67" class="">Data Structure is a mechanism for gathering and arranging data to enable us to conduct operations on it efficiently. Data Structures involve organizing data elements in a specific relationship for improved storage and organization. </p><p id="8066a919-d114-4060-a99f-f913daa399d1" class="">For example, we can use an object to store a player&#x27;s name and age like this:</p><pre id="c7fe0878-eafa-4b67-8457-a0f484dbef07" class="code"><code>let player = {
  name: &quot;Virat&quot;,
  age: 26
};</code></pre><p id="970efc74-2d9c-420f-a05b-1f19490a6371" class="">Here, <code><strong>name</strong></code><strong> </strong>is a string and <code><strong>age</strong></code> is a number. We can create multiple player objects and store them in an array like this:</p><pre id="5852587b-5614-4377-8118-88c2e352e7d6" class="code"><code>let players = [
  { name: &quot;Dhoni&quot;, age: 30 },
  { name: &quot;Gambhir&quot;, age: 31 },
  { name: &quot;Sehwag&quot;, age: 33 }
];</code></pre><p id="25c32f8a-3cb4-4389-8fe8-ec68f3558996" class="">This is a simple example of how data structures can be used in JavaScript. By organizing data this way, we can easily access and manipulate it using various built-in methods and functions. It&#x27;s important to design and implement data structures that reduce complexity and increase efficiency, especially when dealing with large amounts of data.</p><h2 id="f06b130e-a6de-4327-90c9-25c50f5b0fa7" class="block-color-default"><mark class="highlight-red">Classification of Data structure</mark></h2><p id="0f9714cc-d887-4dbe-aacc-5c970167532a" class="">Data structures can be classified based on various characteristics like their nature, organization, and behavior. </p><p id="7d669f39-b286-4bb6-93d0-2f70db5a8da6" class="">We can classify Data Structures into two categories:</p><ol type="1" id="58637406-fff1-46ad-9882-2552211ccb3b" class="numbered-list" start="1"><li><strong>Primitive Data Structure:</strong> Number, String, Boolean, Null, Undefined, Symbol</li></ol><ol type="1" id="5bcabf97-695a-4a09-9e08-5d93fc944f2e" class="numbered-list" start="2"><li><strong>Non-Primitive Data Structure:</strong> Array, Linked List, Stack, Queue, Tree, Graphs, etc.</li></ol><p id="45a7586f-0334-4178-bf59-19d4706b2b7b" class="">The following figure shows the different classifications of Data Structures.</p><figure id="dec463f3-20ea-445f-be8f-53a78d65a99c" class="image"><img style="width:2470px" src="Getting%20Started%20with%20Algorithms%209f1b62ccdf8b41bbbaae271b61f53f82/Screenshot_2023-05-03_at_4.25.34_PM.png"/></a></figure><ol type="1" id="1dcb9009-929d-4b86-b006-d4c7172f7b01" class="numbered-list" start="1"><li><strong>Primitive Data Structures:</strong>
In JavaScript, primitive data types are basic data types that are not objects and do not have any methods or properties. They are immutable, meaning their values cannot be changed once they are created. They include :<ul id="0cf71835-e5b0-4425-a599-3469add3f6b4" class="bulleted-list"><li style="list-style-type:disc"><strong>Number</strong>: The number data type represents numeric values in JavaScript. It includes integers, floating-point numbers, and special numeric values like <code>NaN</code> (Not a Number) and <code>Infinity</code><strong>.</strong><pre id="e12c1f19-6bf3-4486-8b58-dab9be6420fd" class="code"><code>let age = 25;
let price = 9.99;
let quantity = -3;
let result = 2 + 3.5;
let notANumber = NaN;
let infinityValue = Infinity;</code></pre></li></ul><ul id="758a23bc-f981-48e7-b1e5-74ac1ec709a8" class="bulleted-list"><li style="list-style-type:disc"><strong>String: </strong>The string data type represents a sequence of characters enclosed in single quotes (<code>&#x27;</code>) or double quotes (<code>&quot;</code>). It is used to store and manipulate text in JavaScript.<pre id="9bc9a8bc-5885-47f7-afc1-ab550b5ccd1c" class="code"><code>let name = &#x27;John&#x27;;
let message = &quot;Hello, world!&quot;;</code></pre></li></ul><ul id="7f7e16c3-e562-45a8-ab38-10d279eda7f4" class="bulleted-list"><li style="list-style-type:disc"><strong>Boolean: </strong>The Boolean data type represents logical values, either <code>true</code> or <code>false</code>. It is commonly used for conditional statements and logical operations.<pre id="46c47b84-791f-4270-b4c2-03e9bdd589c0" class="code"><code>let isTrue = true;
let isFalse = false;
let greaterThan = 10 &gt; 5;
let isEqual = 3 === 3;
let logicalAnd = true &amp;&amp; false;</code></pre></li></ul><ul id="aa4a7416-d92d-49f0-a6b8-28e9004ce6ca" class="bulleted-list"><li style="list-style-type:disc"><strong>Null: </strong>The null data type represents the intentional absence of any object value. It is a primitive value that indicates the absence of an object reference.<pre id="2cda398a-a6bc-4aa4-8288-8e0969f9ac31" class="code"><code>let user = &#x27;John&#x27;;
// ... some code ...
user = null;
// Resetting the &#x27;user&#x27; variable to null to indicate that it doesn&#x27;t have a value anymore.</code></pre></li></ul><ul id="a4ee261b-89d6-45d7-b35e-5e934063ea24" class="bulleted-list"><li style="list-style-type:disc"><strong>Undefined: </strong>The undefined data type is a variable that has been declared but has not been assigned a value. It indicates the absence of a value, whether intentional or unintentional.<pre id="276fc727-4b14-4354-894d-7478729e0051" class="code"><code>let age;
console.log(age); // Output: undefined
// The variable &#x27;age&#x27; is declared but not assigned a value, so it has the default value of undefined.</code></pre></li></ul><ul id="b1638237-1a39-4d6d-aa4c-96a80d02fbd2" class="bulleted-list"><li style="list-style-type:disc"><strong>Symbol: </strong>The symbol data type represents a unique and immutable value that can be used as an identifier for object properties. Symbols are often used to define object keys to prevent naming collisions.<pre id="5a93e814-f52c-48e2-ada4-9330878955ee" class="code"><code>let sym1 = Symbol();
let sym2 = Symbol(&#x27;description&#x27;);
let object = {
  [sym1]: &#x27;value&#x27;,
  [sym2]: &#x27;another value&#x27;
};
console.log(object[sym1]);  // Output: value</code></pre></li></ul><p id="dcaf2fba-6175-432b-a848-4679624f155b" class="">
</p></li></ol><ol type="1" id="761a354f-ce27-44be-a1e3-f8bdbdf9796a" class="numbered-list" start="2"><li><strong>Non-primitive Data Structures:</strong>
In JavaScript, non-primitive data types are data structures that can hold multiple values and have methods and properties associated with them. These data structures are implemented as objects in JavaScript. They include:<ul id="ee6d08d6-d77a-4e73-8ac8-f30d0bed8576" class="bulleted-list"><li style="list-style-type:disc"><strong>Array</strong>: An ordered list of values, often of the same type, accessed by their index. Arrays in JavaScript are mutable and have methods for manipulating and accessing elements.<pre id="abd0a20e-201c-4b22-a64d-8023ac83808b" class="code"><code>let numbers = [1, 2, 3, 4, 5];
console.log(numbers.length); // Output: 5
console.log(numbers[2]); // Output: 3</code></pre></li></ul><ul id="dc7d742d-8bb9-440f-9e57-b00e18e831e8" class="bulleted-list"><li style="list-style-type:disc"><strong>Object</strong>: A collection of key-value pairs where the values can be of any data type, including other objects. Objects in JavaScript are mutable and can have properties and methods.<pre id="cd1cc184-816a-4b29-8a4d-6a229b992d17" class="code"><code>let person = {
  name: &#x27;John&#x27;,
  age: 25,
  address: {
    street: &#x27;123 Main St&#x27;,
    city: &#x27;Exampleville&#x27;
  }
};
console.log(person.name); // Output: John</code></pre></li></ul><ul id="3012988a-dd61-41a3-a860-585c6803b797" class="bulleted-list"><li style="list-style-type:disc"><strong>Map</strong>: A collection of key-value pairs where the keys can be of any data type. Maps in JavaScript provide an efficient way to store and retrieve data based on keys and have methods for working with the key-value pairs.<pre id="74cd1c6e-40e5-4dd3-ad61-3cfc6babade2" class="code"><code>let map = new Map();
map.set(&#x27;key1&#x27;, &#x27;value1&#x27;);
map.set(&#x27;key2&#x27;, &#x27;value2&#x27;);
console.log(map.get(&#x27;key1&#x27;)); // Output: value1</code></pre></li></ul><ul id="fc7a094f-678b-4c87-8017-a38e81a9193e" class="bulleted-list"><li style="list-style-type:disc"><strong>Set</strong>: A collection of unique values where each value can only occur once. Sets in JavaScript provide methods for adding, removing, and checking the presence of elements.<pre id="66185fcf-1fe6-446a-bc87-a127b88f1c4a" class="code"><code>let set = new Set();
set.add(1);
set.add(2);
set.add(3);
console.log(set);        // Output: Set(3) { 1, 2, 3 }
console.log(set.has(2)); // Output: true</code></pre></li></ul><p id="72a2ad03-f9e9-4059-a705-e803b49f86af" class="">
</p></li></ol><ol type="1" id="7ddec39b-1dfc-4395-97c8-6395a1ccfd7b" class="numbered-list" start="3"><li><strong>Linear Data Structures:
</strong>These data structures organize data in a linear sequence, where each element has exactly one predecessor and successor. Examples of linear data structures include <code>arrays</code>, <code>linked lists</code>, <code>queues</code>, and <code>stacks</code>.<pre id="d8490831-7048-4569-98e0-10aa108c05e1" class="code"><code>// Linked List in JavaScript
{
  head: {
    data: 1,
    next: {
      data: 2,
      next: {
        data: 3,
        next: null
      }
    }
  }
}</code></pre><p id="0cb84d51-48c2-48c5-827b-f32b40694915" class="">
</p></li></ol><ol type="1" id="eb6443eb-ca7b-49af-8086-43636ded6385" class="numbered-list" start="4"><li><strong>Non-linear Data Structures:</strong>
These data structures organize data in a non-linear sequence, where each data element can have multiple predecessors and successors. Examples of non-linear data structures include <code>trees</code> and <code>graphs</code>.<pre id="51f289c9-5d2a-486b-98e9-cd508c4dbe5c" class="code"><code>// Tree in JavaScript
let tree = {
  value: 1,
  left: {
    value: 2,
    left: null,
    right: null
  },
  right: {
    value: 3,
    left: null,
    right: {
      value: 4,
      left: null,
      right: null
    }
  }
};

// Graph in JavaScript
let graph = {
  1: [2, 3],
  2: [4, 5],
  3: [6],
  4: [],
  5: [6],
  6: []
};</code></pre></li></ol><p id="cb8f805d-9017-4827-9da4-257f53c08a17" class="">
</p><h2 id="d7d73813-4ef3-49f8-bf85-2ab38188ffcb" class=""><mark class="highlight-blue">Try it yourself</mark></h2><p id="d107e0eb-6447-49e1-ad9c-e788311194c4" class=""><strong>Imagine you are on a treasure hunt to find the hidden treasure. To reach the treasure, you must solve a series of riddles. Each riddle will provide clues about a specific primitive data type. </strong></p><p id="d8f16d63-b632-458c-b78a-685f8c9661be" class=""><strong>Your task is to correctly identify the data type and proceed to the next riddle.</strong></p><ol type="1" id="abe36e5a-8286-48e6-b4d0-3c59481105ee" class="numbered-list" start="1"><li>I am often used to represent words, phrases, and sentences.
Concatenation is my specialty, as it can be combined with other values.
<em>What am I?</em><ul id="223a0763-29da-43dc-beb3-28fe534cf34f" class="toggle"><li><details close=""><summary><strong>Answer</strong></summary><p id="0f855de5-9c3a-48eb-a45d-953a89b7d89d" class="">If your answer is &quot;String,&quot; proceed to the next riddle. If not, revise your answer until you find the correct data type.</p></details></li></ul></li></ol><ol type="1" id="dfc60a2b-c820-4604-ad5f-dd92888698dc" class="numbered-list" start="2"><li>I am a complex data structure that represents a network of interconnected elements.
Each element is connected to multiple other elements, forming a web-like structure.
<em>What am I?</em><ul id="5ab19470-a333-4343-8ec2-8608748c7fc2" class="toggle"><li><details close=""><summary><strong>Answer</strong></summary><p id="8f0acc06-cce0-4f83-9a5d-6ebe9156bdb3" class="">If your answer is &quot;Graph,&quot; proceed to the next riddle. If not, revise your answer until you find the correct data type.</p></details></li></ul></li></ol><ol type="1" id="3d4e3e7c-ac8a-4b7d-84be-2dec22ad9e82" class="numbered-list" start="3"><li> am a fixed-size data structure that can store a sequence of elements.
      Once I&#x27;m created, my size cannot be changed.<ul id="4b2ba531-22e2-49c0-a453-63710c7f4e63" class="toggle"><li><details close=""><summary><strong>Answer</strong></summary><p id="651a3b5c-a59b-428f-95ed-4f32b38d2ce9" class="">If your answer is &quot;Array,&quot; proceed to the next riddle. If not, revise your answer until you find the correct data structure.</p></details></li></ul></li></ol><ol type="1" id="99c28b39-ebad-42f7-9d29-15a62d439b0c" class="numbered-list" start="3"><li>I represent a value that intentionally does not exist or is not assigned.
I&#x27;m like a blank canvas waiting for something to fill me.
<em>What am I?</em><ul id="b6ab5ba0-373e-4b72-9abb-d54775ddd006" class="toggle"><li><details close=""><summary><strong>Answer</strong></summary><p id="82ad3fbc-ee92-45d5-ab84-2934b5e32c83" class="">If your answer is &quot;Undefined,&quot; proceed to the next riddle. If not, revise your answer until you find the correct data type.</p></details></li></ul></li></ol><ol type="1" id="1fac54c1-9687-4f63-9867-80a18a6518fc" class="numbered-list" start="4"><li>I represent a collection of elements where each element has a direct connection to the previous and next element.
You can think of me as a train with cars linked together.
<em>What am I?</em><ul id="796234c7-7352-425a-9a94-7c7d6c356f8c" class="toggle"><li><details close=""><summary><strong>Answer</strong></summary><p id="cb738b50-e3f6-4349-9985-b7211e3bb397" class="">If your answer is &quot;Linked List,&quot; proceed to the next riddle. If not, revise your answer until you find the correct data structure.</p></details></li></ul></li></ol><ol type="1" id="ee8eac70-c9fd-4d5b-abda-f14309f28d49" class="numbered-list" start="5"><li>I am a hierarchical data structure with a top-down structure.
I have a root element and child elements branching out from it.
<em>What am I?</em><ul id="f841e763-77ad-4c61-aee0-1be1ee9b2419" class="toggle"><li><details close=""><summary><strong>Answer</strong></summary><p id="8d87e05c-4ccc-4dab-921e-2c23bf9440ce" class="">If your answer is &quot;Tree,&quot; congratulations! You have successfully completed the data structure adventure quest.</p></details></li></ul><p id="a758ef12-ad45-40d8-8731-55c7568acf21" class="">
</p></li></ol><h2 id="1e0842e9-c755-4006-bf43-90fa1e424ac8" class="block-color-default"><mark class="highlight-red"><strong><strong>What is an Algorithm?</strong></strong></mark></h2><p id="e2c13736-02db-4d09-a5ae-c7007e24f43a" class="">An algorithm is a finite set of instructions or logical steps that are written in a specific order to achieve a predetermined task. An algorithm is not the complete code or program; it is the core logic, which can be expressed through<strong> pseudocode</strong> or <strong>flowchart</strong>.</p><p id="df06ba2a-374c-471a-adcb-c974bee35f85" class="">To be considered a valid algorithm, it must meet the following requirements:</p><ul id="b08efb50-fbf2-4610-8c4f-a5dc19f043e1" class="bulleted-list"><li style="list-style-type:disc"><strong>Inputs</strong>: It should have zero or more inputs provided externally to the algorithm.</li></ul><ul id="d563ebea-5811-4fd7-8bea-7ebf46efec65" class="bulleted-list"><li style="list-style-type:disc"><strong>Outputs:</strong> It must have at least one output obtained.</li></ul><ul id="5775bf3e-f018-4d3c-9b6a-ae3901016860" class="bulleted-list"><li style="list-style-type:disc"><strong>Definiteness:</strong> Every step of the algorithm must be clearly and precisely defined.</li></ul><ul id="29a05a3c-c1a5-4a4b-9021-b44cfae06fe8" class="bulleted-list"><li style="list-style-type:disc"><strong>Finiteness</strong>: The algorithm must have a finite number of steps.</li></ul><ul id="058ca7e1-9499-4cf1-8a52-8a00bb7e623c" class="bulleted-list"><li style="list-style-type:disc"><strong>Correctness:</strong> Every step of the algorithm must produce an accurate and correct output.</li></ul><p id="de2d0827-62bf-4067-89ed-ff850b0af549" class="">By following these properties, an algorithm can be written to solve a specific problem effectively and efficiently.<div class="indented"><figure id="6491d056-c05f-44c6-8867-f986fb6f3f2e" class="image"><img style="width:2508px" src="Getting%20Started%20with%20Algorithms%209f1b62ccdf8b41bbbaae271b61f53f82/Screenshot_2023-05-03_at_4.26.07_PM.png"/></a></figure></div></p><h2 id="787cd3b0-efaf-4d55-b65c-144e07d9304f" class="block-color-default"><mark class="highlight-red"><strong><strong>Algorithmic Analysis</strong></strong></mark></h2><p id="bf99fd96-8850-450f-a3ce-f9c6cd164278" class="">Suppose you have to find a particular book in a library. You could look for it by wandering aimlessly through the shelves until you stumble upon it, or you could ask a librarian for help. However, the most efficient way to find the book would be to use the library&#x27;s catalog system.</p><p id="6c0cbc55-f20f-4153-9fbf-ca8e25eb052c" class="">Similarly, in computer science, when solving a problem, there can be multiple algorithms to choose from, each with varying levels of efficiency (for example, <strong>sorting problem</strong> has lot of algorithms like <strong>insertion sort</strong>, <strong>selection sort</strong>, <strong>quick sort</strong> and many more). Algorithm analysis helps us determine which is efficient in terms of time and space consumed.</p><p id="a4486db7-e51b-4e1b-8913-cafd5b20056c" class="">The performance of an algorithm is measured on the basis of the following properties :</p><ul id="3d516a02-fc6d-4303-acbb-d4726e0ce389" class="bulleted-list"><li style="list-style-type:disc">Space Complexity</li></ul><ul id="7d2e7f86-dcd1-4cf9-a3a6-1d14345ac7e0" class="bulleted-list"><li style="list-style-type:disc">Time Complexity</li></ul><h3 id="c823eff7-1b2d-45e2-9e57-509de54858ed" class="">Space Complexity</h3><p id="456711d7-7e23-4c42-af3d-8a91af7e21c7" class="">When an algorithm is running, it needs space to store inputs, variables, and program code. <strong>Space complexity</strong> is the amount of memory that is required to run an algorithm or process.</p><p id="dbd4e6fa-1f35-4e4c-aa5f-e39e9c7a8f46" class="">Let&#x27;s take an example of two different algorithms in JavaScript to illustrate space complexity:</p><ol type="1" id="0d5cc587-eacf-4bda-8c12-e1f36639d3dd" class="numbered-list" start="1"><li><strong>Constant Space Complexity: O(1)</strong><pre id="8c25fe75-7a51-4ef3-b49b-340388d71925" class="code code-wrap"><code>function getFirstElement(array) {
  return array[0];
}

let arr = [1, 2, 3, 4, 5];
console.log(getFirstElement(arr)); // 1
</code></pre><p id="6a1cf444-258c-4fea-99c8-41d6c3722283" class="">In this example, no matter how large the input array is, the function only ever uses one variable (<code><strong>array</strong></code>). Therefore, it has a constant <strong>space complexity of O(1)</strong>.</p></li></ol><ol type="1" id="c3b2c1ce-3716-4f3b-a4c1-c58a3112e153" class="numbered-list" start="2"><li><strong>Linear Space Complexity: O(n)</strong><pre id="ec363fe4-c151-4bf2-a792-387ed10e5a0a" class="code code-wrap"><code>function getAllElements(array) {
  let newArray = [];
  for (let i = 0; i &lt; array.length; i++) {
    newArray[i] = array[i];
  }
  return newArray;
}

let arr = [1, 2, 3, 4, 5];
console.log(getAllElements(arr)); // [1, 2, 3, 4, 5]</code></pre><p id="848ee54c-cf57-4314-8d1c-c864c3d9b33a" class="">In this example, the function creates a new array that is a copy of the input array. Therefore, the amount of memory used by the function (i.e., the space complexity) grows linearly with the size of the input, giving it a <strong>space complexity of O(n)</strong>.</p></li></ol><p id="6eb449e1-34ba-4637-a8c0-43fbf00f4043" class="">
</p><p id="0bc70748-0b90-4a60-979a-72eb14f82178" class="">It is crucial for developers to consider the space complexity of their algorithms because it directly affects the performance of a program. If an algorithm requires too much memory, it may cause the system to slow down or crash due to a lack of memory.</p><h3 id="c07ea4e7-46b8-4e6c-bd54-c851d3c31493" class="">Time Complexity</h3><p id="7292e1ee-5833-4dcb-9b3b-6ba11e0cb56f" class="">Time complexity is the time taken by the algorithm to execute each set of instructions. When solving a problem using an algorithm, it&#x27;s important to choose the most efficient one to save time and computational resources.</p><p id="a94cbeae-cfa3-46b7-b688-56eca4667ec0" class="">The time complexity of an algorithm is closely linked to the size of its input. As the input size grows, so does the algorithm&#x27;s run time.</p><p id="1cacb77b-43ae-4219-ac23-dafa3be801f7" class="">Let&#x27;s take two examples to illustrate time complexity:</p><ol type="1" id="48edf4c2-074c-44b2-bf21-3569edbbffb6" class="numbered-list" start="1"><li><strong>Constant Time Complexity: O(1)</strong><pre id="9bd6dd51-e210-4ecd-a37e-78ee0dd133f1" class="code code-wrap"><code>function getFirstElement(array) {
  return array[0];
}

let arr = [1, 2, 3, 4, 5];
console.log(getFirstElement(arr)); // 1</code></pre><p id="9ffb4b33-8edd-4656-b421-96c96dfb195d" class="">In this example, no matter how large the input array is, the function only needs to perform one operation: returning the first element. Therefore, it has a constant <strong>time complexity of O(1)</strong>.</p></li></ol><ol type="1" id="3cdc9f5f-0193-4ae2-aa24-a1b630082d44" class="numbered-list" start="2"><li><strong>Linear Time Complexity: O(n)</strong><pre id="e7502ee6-0e93-4f3c-988d-dcf215a82ce0" class="code code-wrap"><code>function findElement(array, element) {
  for (let i = 0; i &lt; array.length; i++) {
    if (array[i] === element) {
      return i;
    } }
  return -1;
}

let arr = [1, 2, 3, 4, 5];
console.log(findElement(arr, 3)); // 2</code></pre><p id="bdb63052-adad-4c16-843d-0bc02173df08" class="">In this example, in the worst-case scenario, the function has to look at every element in the array once. Therefore, the time complexity grows linearly with the size of the input, giving it a <strong>time complexity of O(n)</strong>.</p></li></ol><p id="c8869d4a-373f-46eb-82e7-e771f896cd0b" class="">
</p><p id="89371957-f438-41b5-b1dd-97237b7d1978" class="">It&#x27;s important to check if an algorithm is stable before running the analysis and to have a good understanding of the data being analyzed.</p><p id="71f5f610-a1cd-45ce-bda2-d2f6ed27aca9" class="">
</p><h2 id="fa7fb33d-e191-49c8-b78f-297bd4e2abfe" class="block-color-default"><mark class="highlight-blue">Activity </mark></h2><ol type="1" id="ab5339ce-4d0d-49f0-bdf2-1bcc89baff9c" class="numbered-list" start="1"><li><strong>Match the following:</strong><ol type="a" id="48458ff7-d618-4177-9bbf-4c098c43f875" class="numbered-list" start="1"><li>Nested Loops                                                                                       i. best-case time complexity of Ω(1)          </li></ol><ol type="a" id="bb1b8220-c064-40bc-b2a8-955b92f036b3" class="numbered-list" start="2"><li>Sorting Algorithm                                                                                ii. worst-case time complexity of O(n^2)</li></ol><ol type="a" id="9b323028-bce3-46aa-8e16-57f42d60b491" class="numbered-list" start="3"><li>Constant Time Operation                                                                    iii. average-case time complexity of Θ(n log n)</li></ol></li></ol><ol type="1" id="94bbb7d4-314d-4160-920b-f3eafbf3c575" class="numbered-list" start="2"><li><strong>Guess the Data Structure:</strong><p id="ca4a8939-22bb-4284-b1b0-ad43d3e39e4d" class="">a) Linear, static in size, store same data, elements access through the index. __________</p><p id="9bdc0cb0-650a-4a57-9996-f6ffa040f163" class="">b) Linear data structure, First-In-First-Out (FIFO) ordering, implemented as dynamic or static. __________</p><p id="f9998e11-6e10-4618-a72a-899061a6f23b" class="">c) Non-linear, hierarchical, directed acyclic graph, root node with specific branching factor. __________</p></li></ol><ul id="e8550829-96fb-41da-afac-4d42f035c3e7" class="toggle"><li><details close=""><summary><strong>Solution</strong></summary><ol type="1" id="5566ae48-551f-4109-9fc3-d7deed867f4a" class="numbered-list" start="1"><li>a - ii<p id="39dbc0e0-02ad-435b-bb45-174b5c49f3ff" class="">b - iii</p><p id="8854401b-255e-462c-93c3-100817ae8c82" class="">c - i</p></li></ol><ol type="1" id="5ba5e8f3-d9cd-460e-87f6-a13b460181ea" class="numbered-list" start="2"><li>a) Arrays<p id="74634ef0-ca6e-468c-bd5f-bf26cb6ae0ae" class="">b) Queue</p><p id="088bc064-aaa5-4499-aacf-3f2d0c65c55c" class="">c) Trees</p></li></ol><p id="d0f23165-25b8-4fe6-addc-846c75e0fadc" class="">
</p></details></li></ul><p id="de56a441-1a75-46e0-9210-ce6f1f6690c6" class="">
</p><h2 id="0f6d99f5-a9aa-4259-9551-345c1a90f644" class="block-color-default"><mark class="highlight-red">Introduction to Asymptotic Analysis</mark></h2><p id="a2aaeef2-74e4-4388-8a32-12a1fdf37710" class="">Asymptotic notation is a method used to compare the efficiency of different algorithms. It is not feasible to compare two algorithms directly as it heavily depends on the hardware and tools used for the comparison, such as the operating system, CPU model, and processor generation. Even if the time and space complexity of two algorithms are calculated on the same system, their performance may still be affected by subtle changes in the system environment.</p><p id="db0499d0-96d6-4e36-a2a8-78e01f1c0ee7" class="">Asymptotic analysis is used to compare the time and space complexity of two algorithms based on the changes in their performance with the increment or decrement in the input size.</p><p id="ae38bd08-7072-4b8d-93e7-2a95aa561775" class=""> There are three main types of asymptotic notations: </p><ol type="1" id="7dbeed15-57fe-463c-95e5-f28f7291ea6d" class="numbered-list" start="1"><li><strong>Big-Oh (O) notation</strong></li></ol><ol type="1" id="c8744e0b-1c0e-4bb3-852a-8ee3eedf158a" class="numbered-list" start="2"><li><strong>Big Omega (Ω) notation</strong></li></ol><ol type="1" id="bd82470e-614d-4445-a5fb-44038ae49bf5" class="numbered-list" start="3"><li><strong>Big Theta (Θ) notation</strong></li></ol><h3 id="065b2f97-e6a6-4e99-acba-0fc5d63271a3" class=""><strong><strong>Big-Oh/Big-O (O) Notation</strong></strong></h3><p id="6db30ff6-ad12-4dc9-8284-1b8cdc56f1db" class="">Big O notation is used to describe the performance or complexity of an algorithm in terms of its input size. It provides an upper bound on the growth rate of an algorithm&#x27;s time or space requirements.</p><p id="ed5183d3-44ab-46e2-b5d8-89fb26b3f674" class="">In simple terms, Big O notation tells you how the runtime or memory usage of an algorithm increases as the input size grows.</p><p id="0da843b3-af08-42f4-998f-e86a318fa27c" class="">Here&#x27;s an easy example to illustrate the concept:</p><pre id="2ecd6d38-e92b-4f1c-b5b4-48a4d0a9fa16" class="code"><code>function sum(numbers) {
  let total = 0;
  for (let i = 0; i &lt; numbers.length; i++) {
    total += numbers[i];
  }
  return total;
}</code></pre><p id="2e9ff597-e3b1-419a-96be-06bb6524ee9a" class=""><strong>Explanation</strong>:</p><ul id="fd82353c-f6df-4379-aa6b-2ec2f914c808" class="bulleted-list"><li style="list-style-type:disc">In this example, we have a function called <code><strong>sum</strong></code> that takes an array of numbers as input and returns their sum.</li></ul><ul id="6c89c626-1007-4faf-b97f-f122ad7848eb" class="bulleted-list"><li style="list-style-type:disc">To analyze the time complexity of this function using Big O notation, we consider the worst-case scenario, which is when the array has <code><strong>n</strong></code> elements.</li></ul><ul id="ab1a52f9-ffaa-4d82-925a-747cc0bc12fe" class="bulleted-list"><li style="list-style-type:disc">In this case, the function iterates over each element in the array once using a <code><strong>for</strong></code> loop. Therefore, the runtime of the function is directly proportional to the number of elements in the input array, <code><strong>n</strong></code>.</li></ul><ul id="35bbd007-4e31-4d26-850b-dbd8498e15e4" class="bulleted-list"><li style="list-style-type:disc">Using Big O notation, we can express the time complexity of this function as O(n), which reads as &quot;order of n&quot; or &quot;linear time complexity.&quot; It indicates that the runtime of the function grows linearly with the input size.</li></ul><p id="b006dab2-f851-4ff4-8d6f-047bb1524bce" class="">In simpler terms, it means that if we double the number of elements in the array, the time it takes to run the function will also roughly double.</p><p id="f5f8afb0-1cb0-4760-b1df-4efe5667269b" class="">It&#x27;s important to note that Big O notation focuses on the dominant factor that affects the algorithm&#x27;s performance as the input size grows. It abstracts away constant factors, lower-order terms, and specific details of the algorithm.</p><p id="ffe300a2-f0c5-4934-9a88-7ccfe987bdf9" class="">Big O notation provides a standardized way to compare the efficiency of different algorithms. It helps in making informed decisions when choosing the most appropriate algorithm for a given problem based on its scalability.</p><figure id="ffb97f93-f0dc-43c4-a738-b361701eca73" class="image"><img style="width:1752px" src="Getting%20Started%20with%20Algorithms%209f1b62ccdf8b41bbbaae271b61f53f82/2023-05-18_18.38.13_www.bigocheatsheet.com_5627ae7896bb.png"/></a><figcaption>                                                                                                             <strong><strong>Big-O Complexity Chart</strong></strong></figcaption></figure><h3 id="1704a673-598c-4757-8147-d48c59651675" class=""><strong><strong>Big Omega (Ω) Notation</strong></strong></h3><p id="85f20e23-d0e2-4a3c-b379-97864afeda81" class="">Big Omega notation, represented by Ω (omega), is used to describe the best-case scenario or lower bound of the runtime complexity of an algorithm. It provides a lower bound on the growth rate of an algorithm&#x27;s time or space requirements.</p><p id="d8307a00-ffeb-43c6-abb6-fa154f41f36f" class="">In simple terms, Big Omega notation tells you the minimum amount of time an algorithm will take to run for a given input size.</p><p id="dd85bd88-b5fa-401a-a662-949f1be600bd" class="">Here&#x27;s an easy example to illustrate the concept:</p><pre id="5b2aea87-6b30-47ce-9c45-08a3bd42bdcd" class="code"><code>function findMin(numbers) {
  let min = numbers[0];
  for (let i = 1; i &lt; numbers.length; i++) {
    if (numbers[i] &lt; min) {
      min = numbers[i];
    }
  }
  return min;
}</code></pre><p id="a631eefb-41b6-4125-92c0-5b9f3384c17d" class=""><strong>Explanation</strong>:</p><ul id="6b19135a-9d34-4986-81c0-b89186251adf" class="bulleted-list"><li style="list-style-type:disc">In this example, we have a function called <code><strong>findMin</strong></code> that takes an array of numbers as input and returns the smallest number in the array.</li></ul><ul id="8d076ca9-57cd-40fb-ac68-b673dbd9fdaf" class="bulleted-list"><li style="list-style-type:disc">To analyze the time complexity of this function using Big Omega notation, we consider the best-case scenario, which is when the smallest number is at the beginning of the array.</li></ul><ul id="d99fe098-c96b-4df4-ae2e-539755a30794" class="bulleted-list"><li style="list-style-type:disc">In this case, the function only needs to compare the first element with the remaining elements once. Therefore, the runtime of the function is directly proportional to the number of elements in the input array, <code><strong>n</strong></code>.</li></ul><ul id="c49e344d-e6bf-46ad-ad24-aefa99fea9eb" class="bulleted-list"><li style="list-style-type:disc">Using Big Omega notation, we can express the time complexity of this function as Ω(1), which reads as &quot;omega of 1&quot; or &quot;constant time complexity.&quot; It indicates that the runtime of the function is constant, regardless of the input size.</li></ul><p id="b9f61b71-55f7-4493-b049-5e8e1da156cd" class="">In simpler terms, it means that even if we double or triple the number of elements in the array, the time it takes to run the function will remain relatively the same, as long as the smallest number is at the beginning.</p><p id="a963bbab-16c8-48b0-86cd-fcd82a64988f" class="">Similar to Big O notation, Big Omega notation abstracts away constant factors and lower-order terms. It focuses on the best-case performance of an algorithm and provides a lower bound on its runtime complexity.</p><p id="2dee864f-8981-4e14-ad85-40047e4512e4" class="">Big Omega notation helps in understanding the minimum amount of time an algorithm will take to run, which can be useful in scenarios where the best-case performance is critical for optimizing certain applications or algorithms.</p><h3 id="7e331f13-d3fb-4449-8217-c772f591009c" class="">Big Theta (<strong>Θ) Notation</strong></h3><p id="75fd24f9-c5a8-49a5-be11-3cca6492e9ad" class="">Big Theta notation, represented by Θ (theta), is used to describe the average-case or tight bound of the runtime complexity of an algorithm. It provides both the lower and upper bounds on the growth rate of an algorithm&#x27;s time or space requirements.</p><p id="f0747859-5f7e-4ad4-8069-6f94a420112c" class="">In simple terms, Big Theta notation tells you both the best-case and worst-case scenarios of an algorithm and gives a tight estimate of its runtime complexity.</p><p id="78d327cd-2aba-499f-8bf4-2c36f8441a3e" class="">Here&#x27;s an easy example to illustrate the concept:</p><pre id="95f00346-0828-4eeb-850d-d33032b2951b" class="code"><code>function containsValue(arr, value) {
  for (let i = 0; i &lt; arr.length; i++) {
    if (arr[i] === value) {
      return true;
    }
  }
  return false;
}</code></pre><p id="c5f4ba5a-834e-4525-9c4b-49af44ead3b3" class="">In this example, we have a function called <code><strong>containsValue</strong></code> that takes an array <code><strong>arr</strong></code> and a value to search for, and it returns <code><strong>true</strong></code> if the value is found in the array, or <code><strong>false</strong></code> otherwise.</p><p id="c9891fd6-dfa2-4c04-9c5c-3f0f0fcef72f" class="">To analyze the time complexity of this function using Big Theta notation, we consider both the best-case and worst-case scenarios.</p><ul id="2ccc9d2a-410b-4278-a100-307969a2ac2d" class="bulleted-list"><li style="list-style-type:disc"><strong>Best-case scenario: </strong>The value is found at the beginning of the array. In this case, the function only needs to compare the first element with the target value, resulting in a constant-time operation. The best-case time complexity is Θ(1).</li></ul><ul id="d4d12f36-ea49-49f1-9fa5-3c44db2bd0b3" class="bulleted-list"><li style="list-style-type:disc"><strong>Worst-case scenario:</strong> The value is not present in the array, or it is located at the end of the array. In this case, the function needs to compare the target value with every element in the array until the end, resulting in a linear-time operation. The worst-case time complexity is Θ(n), where <code><strong>n</strong></code> represents the number of elements in the array.</li></ul><p id="3bbc7204-f4e9-4c45-8162-a6220ce51b64" class="">The Big Theta notation, in this case, expresses that the average-case time complexity of the function is also Θ(n). It indicates that the function&#x27;s runtime grows linearly with the input size on average, considering both the best and worst-case scenarios.</p><p id="cffdcf06-efbf-4bb9-8dfe-d41c186ab35c" class="">In simpler terms, it means that as the input size increases, the time it takes to run the function will increase proportionally on average. However, there will be cases where the runtime can be better (best-case scenario) or worse (worst-case scenario) than the average.</p><p id="b5d2269e-9ca4-403b-be02-79fc81095fcb" class="">Big Theta notation helps in providing a tighter estimate of an algorithm&#x27;s performance by considering both the lower and upper bounds. It gives a more comprehensive understanding of how an algorithm behaves under different input scenarios.</p><h3 id="361b2f1f-3f8a-4090-98cd-873bfb5b81d1" class="">Common Asymptotic Notations</h3><p id="4fc3bbb7-f0a0-4f16-bfeb-e64de69c12a2" class="">Following is a list of some common asymptotic notations:</p><div id="1810eb66-5fa8-4b2e-b0f4-79fb702b2202" class="column-list"><div id="fa8c228e-9e5c-4588-8f9a-2011d3a2dd31" style="width:41.666666666666664%" class="column"><p id="0e81db61-0ae2-421e-9ee6-7487a3e2c3aa" class="">
</p></div><div id="686801a0-b7a7-4302-9351-be2d0ca7f5c7" style="width:87.5%" class="column"><table id="a7fce4d9-5b66-4456-8184-434ffd069c98" class="simple-table"><thead class="simple-table-header"><tr id="87806cc2-478d-470d-92d1-04cecf2d5be4"><th id="BV?:" class="simple-table-header-color simple-table-header" style="width:193px"><strong>NOTATION</strong></th><th id="Rt&lt;u" class="simple-table-header-color simple-table-header" style="width:262px"><strong>NAME</strong></th></tr></thead><tbody><tr id="663d87f7-8615-4609-82b3-2d3ad6034c68"><td id="BV?:" class="" style="width:193px">O(1)</td><td id="Rt&lt;u" class="" style="width:262px">constant</td></tr><tr id="6fdee6fa-171e-4ec5-9530-722b08ddaa54"><td id="BV?:" class="" style="width:193px">O(log n)</td><td id="Rt&lt;u" class="" style="width:262px">logarithmic</td></tr><tr id="739415c7-a045-4ef4-a5d5-508832b843bd"><td id="BV?:" class="" style="width:193px">O(n)</td><td id="Rt&lt;u" class="" style="width:262px">linear</td></tr><tr id="0ca4e800-0fb5-40cb-9252-110d65e2aa12"><td id="BV?:" class="" style="width:193px">O(n log n) = O(log n!)</td><td id="Rt&lt;u" class="" style="width:262px">linearithmic, log-linear, or quasilinear</td></tr><tr id="aeef71cc-9e3b-4a5a-8b7b-102e451a9194"><td id="BV?:" class="" style="width:193px">O(n^2)</td><td id="Rt&lt;u" class="" style="width:262px">quadratic</td></tr><tr id="708116f3-68a4-4498-83fd-b8b67259b48a"><td id="BV?:" class="" style="width:193px">O(n^c)</td><td id="Rt&lt;u" class="" style="width:262px">polynomial or algebraic</td></tr><tr id="7318c678-7d31-4ab8-9f3f-20063a519155"><td id="BV?:" class="" style="width:193px">O(c^n); where c&gt;1</td><td id="Rt&lt;u" class="" style="width:262px">exponential</td></tr><tr id="8fdc2f90-f533-4af4-b9ee-eed01782916a"><td id="BV?:" class="" style="width:193px">O(n!)</td><td id="Rt&lt;u" class="" style="width:262px">factorial</td></tr></tbody></table></div><div id="b3bdb72b-f112-4b29-a6bc-62598a6597bf" style="width:24.999999999999993%" class="column"><p id="d635e6ed-9a2d-4cae-9b63-f6626ee199d4" class="">
</p></div></div><p id="6d66ff92-8e19-40f6-b8a1-0914f75d54a7" class="">When analyzing the efficiency of an algorithm, we consider three cases:<strong> best case, average case, and worst case.</strong></p><ul id="fed265ad-e9c6-4fc9-9738-a96e56ad59c6" class="bulleted-list"><li style="list-style-type:disc">The <strong>best case scenario</strong> is when the algorithm completes its task in the shortest possible time, and this time acts as a lower bound for the algorithm&#x27;s time complexity.</li></ul><ul id="0a0818da-c28c-4f70-8ccd-0687057c0004" class="bulleted-list"><li style="list-style-type:disc">In the<strong> average case</strong>, the sum of the running times for every possible input combination is calculated, and the average is taken. This average time serves as both the lower and upper bound for the algorithm&#x27;s time complexity.</li></ul><ul id="e57ec73d-44a8-4f53-8144-4e28f27c810e" class="bulleted-list"><li style="list-style-type:disc">The <strong>worst-case scenario </strong>is when the algorithm takes the longest time to complete its task, and this time serves as the upper bound for the algorithm&#x27;s time complexity. </li></ul><p id="ac506980-e8e0-4b0b-a5d1-7d6e5d3bedb1" class="">Considering these different cases helps us determine the efficiency of an algorithm in different scenarios, allowing us to choose the best algorithm for a given problem.</p><h2 id="479d2e3a-0a73-471b-afc4-c4b723af386f" class="block-color-default"><mark class="highlight-red">Why learn Data structures and Algorithms?</mark></h2><p id="1e63f16f-8192-4d01-a347-0c0b5579fed8" class="">Data Structures are vital for overcoming challenges posed by increasing data. They offer benefits such as efficiency, abstraction, and reusability, making it easier to organize and manage data effectively.</p><p id="152c6444-eaa8-48c4-bafe-17f2ca5b3b2d" class="">Mastering data structures and algorithms is essential for optimal data organization and processing, leading to valuable insights in real-world scenarios such as financial analysis, weather prediction, and product recommendations.</p><p id="e0eae9eb-060d-47fb-b1d6-624e30ed09f8" class="">Mastering Data Structures and Algorithms is crucial for producing high-quality, efficient code that can handle large amounts of data. It&#x27;s a valuable asset for anyone looking to excel in computer science.</p><p id="eae5a789-cd8b-415b-91ad-d72e34827406" class="">
</p><h2 id="f6ec541d-f540-4b43-ba67-d3ae3cbee2bf" class=""><mark class="highlight-blue">Explore Further</mark></h2><p id="c88781f6-10cc-406f-b42b-c66da43271fc" class=""><mark class="highlight-orange"><strong>Uncover and unlock new insights as you dive into the captivating content found in the provided link.</strong></mark></p><p id="caea7f44-68fa-444c-b19c-5cd3996fc9c4" class=""><strong>Amortized analysis:</strong> <a href="https://www.cs.cornell.edu/courses/cs3110/2011fa/supplemental/lec20-amortized/amortized.htm">https://www.cs.cornell.edu/courses/cs3110/2011fa/supplemental/lec20-amortized/amortized.htm</a></p><p id="97453558-11e3-47b8-a94f-8be39c676975" class="">
</p><p id="3ecc6202-fe1f-4fec-bd84-2284cf69cb06" class=""><mark class="highlight-orange"><strong>Tackle these questions head-on!</strong></mark></p><p id="9c8a1162-06c3-4917-bbe5-f62faf930207" class=""><strong>To simulate and analyze the amortized cost of a sequence of coin flips:</strong> You are given a function <code><strong>performCoinFlips(numFlips)</strong></code> that simulates a sequence of coin flips. The function takes an integer <code><strong>numFlips</strong></code> as an argument, representing the number of times you will flip the coin. The function returns the total time taken to perform the entire sequence of flips.</p><p id="8c026aa4-83e0-4044-804e-744e68672bd9" class="">Each coin flip takes one unit of time, regardless of the outcome (Heads or Tails). Additionally, if the result of a flip is Heads, you add another coin to your hand before the next flip. When flipping all the coins in your hand, it takes an additional unit of time for each coin to present.</p><p id="a9f0075e-4780-451d-b37c-7e2198cfb7bf" class="">Write a JavaScript program that utilizes the <code><strong>performCoinFlips</strong></code> function to solve the following problem:</p><p id="94209b93-4a7c-44e3-a335-5ee72957b24e" class="">Given a specific number of coin flips, find the total time taken to perform the flips.</p><p id="54a80252-fed8-4acb-bcf9-4d5123ddebd4" class="">Implement the function <code><strong>findTotalTime(numFlips)</strong></code> that takes an integer <code><strong>numFlips</strong></code> as an argument and returns the total time taken.</p><p id="1bd2d35b-b1e6-4562-9d0e-fe9d1882f08c" class="">Example:</p><pre id="1b9340bc-7bbf-4a4f-bd46-3672120c040c" class="code code-wrap"><code>
console.log(findTotalTime(10)); // Output: Total time taken for 10 flips: 53
console.log(findTotalTime(5)); // Output: Total time taken for 5 flips: 20
</code></pre><p id="fde40d86-1b8a-4173-874b-bbfd1f210f8b" class=""><em>(This question provides a hands-on experience to understand amortized analysis using a familiar scenario of coin flipping. It highlights the concept of spreading the cost of expensive operations over multiple operations, resulting in a more efficient average-case performance).</em></p><p id="33dc44f9-d0ce-4923-8e4a-434933ba291b" class="">Note:</p><ul id="f972170c-c1cb-4e22-b0c1-23b99bfdfb95" class="bulleted-list"><li style="list-style-type:disc">The <code><strong>performCoinFlips</strong></code> function should be utilized to calculate the total time taken for the given number of flips.</li></ul><ul id="9ef37d52-2dfc-4320-b842-89796bd74934" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><pre id="81d5bbed-e50a-44d2-b6fa-b2652bc7ae12" class="code"><code>function flipCoin() {
  return Math.random() &lt; 0.5 ? &#x27;Heads&#x27; : &#x27;Tails&#x27;;
}

function performCoinFlips(numFlips) {
  let coins = 1;
  let totalTime = 0;
  
  for (let i = 0; i &lt; numFlips; i++) {
    const result = flipCoin();
    totalTime++; // Cost of flipping the coin
    
    if (result === &#x27;Heads&#x27;) {
      coins++;
    }
    
    totalTime += coins; // Cost of flipping all the coins in hand
  }
  
  return totalTime;
}

// Testing the function with 10 flips
const numFlips = 10;
const timeTaken = performCoinFlips(numFlips);
console.log(`Total time taken for ${numFlips} flips: ${timeTaken}`);</code></pre><p id="631731c3-928a-4155-b4b0-eb6a5e2facca" class="">In this JavaScript solution, the <code><strong>flipCoin</strong></code> function randomly returns either &#x27;Heads&#x27; or &#x27;Tails&#x27;. The <code><strong>performCoinFlips</strong></code> function takes the number of flips as an argument and simulates the sequence of coin flips. It keeps track of the total time taken by incrementing the <code><strong>totalTime</strong></code> variable. The number of coins in hand is represented by the <code><strong>coins</strong></code> variable. For each flip, the time taken for flipping the coin is added to <code><strong>totalTime</strong></code>, and if the result is &#x27;Heads&#x27;, an additional coin is added to the hand. Finally, the time taken for flipping all the coins in hand is added to <code><strong>totalTime</strong></code>.</p><p id="d563da1a-a7b9-4c06-ada7-7af71e08765f" class="">You can test the function by running the code and observing the total time taken for the specified number of flips. Feel free to adjust the <code><strong>numFlips</strong></code> variable to perform the experiment with different numbers of flips.</p></details></li></ul><p id="18e28c53-e9a1-4873-9610-73e209e44fef" class="">
</p><h1 id="65031041-16e6-4a56-9600-8d94b059aee5" class=""><strong><mark class="highlight-brown">Summary</mark></strong></h1><h2 id="9639d7e7-4a2f-4543-823b-d3d3841fa697" class="block-color-default"><mark class="highlight-red">What did we learn?</mark></h2><ul id="068bfe3a-a937-4aeb-a632-191f0011e4be" class="bulleted-list"><li style="list-style-type:disc">Data structures are a mechanism for organizing and storing data in a specific relationship for improved storage and organization.</li></ul><ul id="e60b9bc0-d04a-460f-b2e6-f44c5ad7562f" class="bulleted-list"><li style="list-style-type:disc">Data structures can be classified into two categories: <strong>primitive</strong> and<em> </em><strong>non-primitive</strong>. Primitive data structures include <code>number</code>, <code>string</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, and <code>symbol</code>. Non-primitive data structures include <code>arrays</code>, <code>maps</code>, <code>linked list</code>, <code>stack</code> , <code>trees</code>etc.</li></ul><ul id="4443c3d6-0883-41e1-98b4-a62d48d767dd" class="bulleted-list"><li style="list-style-type:disc">Linear data structures arrange data sequentially with one predecessor and successor. In contrast, non-linear data structures arrange data in a non-linear sequence with multiple predecessors and successors.</li></ul><ul id="eeb38228-31c5-4ee5-9d3e-ef047202659c" class="bulleted-list"><li style="list-style-type:disc">Static data structures have a fixed size, and their memory is allocated at compile time. In contrast, dynamic data structures can grow or shrink dynamically at runtime, and their memory is allocated at runtime.</li></ul><ul id="83bb8433-fc52-4a05-a860-68360057e877" class="bulleted-list"><li style="list-style-type:disc">Understanding data structures is important for designing and implementing efficient algorithms, especially when dealing with large amounts of data.</li></ul><ul id="d9b9f02e-c78c-49cc-b581-fec884b6bb61" class="bulleted-list"><li style="list-style-type:disc">An algorithm is a set of instructions or logical steps written in a specific order to achieve a predetermined task. It must have inputs, at least one output, definiteness, finiteness, and correctness.</li></ul><ul id="7fa9b16b-e105-439e-a3bf-692aade236ef" class="bulleted-list"><li style="list-style-type:disc">Algorithmic analysis helps determine the efficiency of an algorithm in terms of space and time complexity. Space complexity is the amount of memory required to run an algorithm, while time complexity is the time the algorithm takes to execute each set of instructions.</li></ul><ul id="18b15d54-d341-445a-9546-d129c1bdffba" class="bulleted-list"><li style="list-style-type:disc">The performance of an algorithm is closely linked to its data structures and operations, and it&#x27;s important to choose the most efficient algorithm for a given task to save time and computational resources.</li></ul><ul id="d3bcfb21-0115-47bf-8701-454da461daeb" class="bulleted-list"><li style="list-style-type:disc">Asymptotic analysis is a technique to compare the efficiency of algorithms using asymptotic notation. It compares time and space complexity using three notations: O, Ω, and Θ.</li></ul><ul id="96866f8e-0dc6-4335-98f4-6446a9297e1f" class="bulleted-list"><li style="list-style-type:disc"><code>Big-O(O)</code> provides an upper bound for worst-case runtime, <code>Big-Omega(Ω)</code> provides a lower bound for best-case runtime, and <code>Big-Theta(Θ)</code> represents both upper and lower bounds on the runtime growth rate.</li></ul><ul id="aa7fef42-7fc0-4e8e-b9f9-d65dce3e75c2" class="bulleted-list"><li style="list-style-type:disc">Algorithm efficiency analysis includes best, average, and worst-case scenarios to choose the most efficient algorithm for a given problem. The best case is the shortest, the worst case is the longest, and the average is the meantime for all possible inputs.</li></ul><h2 id="7e51756c-b3bf-4f1b-8067-ee3bdc1471c8" class="block-color-default"><mark class="highlight-red">Shortcomings &amp; Challenges</mark></h2><ul id="0e9cc72d-4a8b-4d32-a6d1-931c09183d6e" class="bulleted-list"><li style="list-style-type:disc">Choosing the right data structure for a problem can be challenging, especially when similar options, such as stacks and queues, have different behaviors in adding and removing elements.</li></ul><ul id="98b75d79-8725-4ca9-a91e-3537777daf87" class="bulleted-list"><li style="list-style-type:disc">Learning about algorithms and their complexity can be difficult for beginners due to technical requirements and an overwhelming number of variations available.</li></ul><ul id="4ffcb352-e398-48e7-a544-42ae0cb4eb4c" class="bulleted-list"><li style="list-style-type:disc">Identifying the best and worst algorithm scenarios is easy, but comparing their efficiency based on varying growth rates and complexity is tricky.</li></ul><h2 id="e8c5bc25-cb6d-416c-8df4-3136ba83c7be" class="block-color-default"><mark class="highlight-red">Best Practices</mark></h2><ul id="429ac4fc-0de4-457d-8883-f00aa019b07d" class="bulleted-list"><li style="list-style-type:disc">Experimenting with various data structures through coding exercises and real-world applications is a best practice for mastering them and improving skills and confidence in selecting the right structure for any problem.</li></ul><ul id="d6e36a4c-37e3-4caf-a35e-a35ae141b9e7" class="bulleted-list"><li style="list-style-type:disc">Develop a good understanding of algorithms and their analysis; start with the fundamentals, focus on comprehending the underlying principles, and practice coding to reinforce your understanding.</li></ul><ul id="b7fdbae4-7b6f-443c-b6ca-363b41dfbb27" class="bulleted-list"><li style="list-style-type:disc">Analyze different types of algorithms, compare and contrast their performance, and use visualization tools like flowcharts and diagrams.</li></ul><ul id="340156b8-a2f9-45e4-968c-0b3d0f0f8c9d" class="bulleted-list"><li style="list-style-type:disc">To determine the most optimized way to solve a problem is to start by understanding the problem requirements and constraints, analyzing the possible approaches, and comparing their time and space complexities.</li></ul><h2 id="f92ccb4a-ff50-4b85-b320-67944de84480" class="block-color-default"><mark class="highlight-red">Enhance Your Knowledge</mark></h2><ul id="6bd35951-d2f4-438d-8cb7-3fa8e5d7a225" class="bulleted-list"><li style="list-style-type:disc"><a href="https://developerinsider.co/introduction-to-data-structures-and-algorithms/">https://developerinsider.co/introduction-to-data-structures-and-algorithms/</a></li></ul><ul id="d274d7dd-971d-47ca-8eff-27bc640f1c85" class="bulleted-list"><li style="list-style-type:disc"><a href="https://towardsdatascience.com/space-and-time-complexity-in-computer-algorithms-a7fffe9e4683">https://towardsdatascience.com/space-and-time-complexity-in-computer-algorithms-a7fffe9e4683</a></li></ul><ul id="e182c81a-3ba6-4833-b668-fdc8cb2959a3" class="bulleted-list"><li style="list-style-type:disc"><a href="https://medium.com/smelly-code/an-ode-to-asymptotic-notations-64753506bbf1">https://medium.com/smelly-code/an-ode-to-asymptotic-notations-64753506bbf1</a></li></ul><p id="4fe3020f-47cc-4990-a8a8-ccff70ce4952" class="">
</p></div></article></body></html>
