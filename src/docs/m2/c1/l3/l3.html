<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Introduction to Pattern Matching</title><link rel="stylesheet" href="../../../../../styles.css"></head><body><article id="9786b0b7-e905-402b-b93a-80307df45e09" class="page sans"><header><h1 class="page-title">Introduction to Pattern Matching</h1><p class="page-description"></p></header><div class="page-body"><ul id="29215880-b8a1-4b61-add2-edcfeed13708" class="toggle"><li><details close=""><summary><strong>Session Flow (5 minutes read)</strong></summary><ul id="04385b35-8c77-4ace-b618-58ee461d7848" class="bulleted-list"><li style="list-style-type:disc"><strong>Learning Objective (5 minutes read)</strong><ul id="11899f87-13ea-436d-a59e-deef1497f070" class="bulleted-list"><li style="list-style-type:circle">Introduction</li></ul><ul id="6dc29740-bfe2-4db0-9122-2c0198c95365" class="bulleted-list"><li style="list-style-type:circle">Theme</li></ul><ul id="3729bbdb-1292-4aeb-b94b-37573fbdd0e4" class="bulleted-list"><li style="list-style-type:circle">Primary Goals</li></ul></li></ul><ul id="57556c28-2d02-4b86-8023-b4d1b9a7bc0c" class="bulleted-list"><li style="list-style-type:disc"><strong>Getting Started with Pattern Matching (120 minutes read)</strong><ul id="180b176e-bd0d-4562-8b8a-54a9b7ae09f3" class="bulleted-list"><li style="list-style-type:circle">Introduction to pattern matching</li></ul><ul id="44541094-0c5a-4c95-b993-3b8ad2572feb" class="bulleted-list"><li style="list-style-type:circle">How does pattern matching work?</li></ul><ul id="fe7c2397-02d0-4f01-adb4-26589235496f" class="bulleted-list"><li style="list-style-type:circle">Example of the matching Email address pattern</li></ul><ul id="b29af370-7603-4afc-ab8f-792951c0822e" class="bulleted-list"><li style="list-style-type:circle"><strong>Do it yourself</strong></li></ul><ul id="a1e32d0f-d968-440e-a475-9011ee80212f" class="bulleted-list"><li style="list-style-type:circle">Pattern matching use cases</li></ul><ul id="5315b5c8-aca3-42cc-a817-ca39c2392359" class="bulleted-list"><li style="list-style-type:circle">Regular Expressions</li></ul><ul id="002bfd09-8752-4089-98f1-8efe73e2c32d" class="bulleted-list"><li style="list-style-type:circle"><strong>Activity 1</strong></li></ul><ul id="82d683aa-c6f5-4146-9f86-577984b7dcfa" class="bulleted-list"><li style="list-style-type:circle">Assertions</li></ul><ul id="d1bb778a-d819-40f3-8d44-fd18c7e0deef" class="bulleted-list"><li style="list-style-type:circle">Bracket Expressions</li></ul><ul id="6d4a7012-1a9c-4c47-8257-63144f83be2d" class="bulleted-list"><li style="list-style-type:circle">Flags</li></ul><ul id="617fde88-74f9-4cec-b83c-17e3a51887af" class="bulleted-list"><li style="list-style-type:circle">Quantifiers</li></ul><ul id="6ab23bd5-476f-4364-92cc-789ff60a0bea" class="bulleted-list"><li style="list-style-type:circle"><strong>Explore Further</strong></li></ul><ul id="e05db94b-8ba2-4b69-a20a-c7722121f8f9" class="bulleted-list"><li style="list-style-type:circle">Regex Functions</li></ul><ul id="5fe74562-e5e1-4c51-a516-4febbe1376c1" class="bulleted-list"><li style="list-style-type:circle">Pattern Matching Algorithm</li></ul><ul id="9c0eb824-7813-444e-861d-9bf529c86fe6" class="bulleted-list"><li style="list-style-type:circle">Real-Life Applications  of Pattern Matching</li></ul><ul id="e7a565fd-9ff1-4bf8-b5eb-63f47bd850b7" class="bulleted-list"><li style="list-style-type:circle"><strong>Activity 2</strong></li></ul><ul id="34365d87-af32-45e3-a224-e59d4101acd3" class="bulleted-list"><li style="list-style-type:circle">Foundations of Pattern Matching Algorithms<ul id="ce554717-6c0c-4fc4-899e-c0b5ffde4fd5" class="bulleted-list"><li style="list-style-type:square">String Matching Algorithms</li></ul><ul id="bee556cd-0c50-4501-b941-9ec69330f167" class="bulleted-list"><li style="list-style-type:square">Finite Automata</li></ul><ul id="f5954352-697a-41e3-afd8-530ce0506108" class="bulleted-list"><li style="list-style-type:square">Index-based string matching</li></ul><ul id="b8a2aea4-5c9b-431a-8cb0-44e8289595b4" class="bulleted-list"><li style="list-style-type:square">Burrows-Wheeler transform</li></ul></li></ul><ul id="5864248a-bdca-4732-9f55-f7832744dc86" class="bulleted-list"><li style="list-style-type:circle"><strong>Activity 3</strong></li></ul></li></ul><ul id="9a2ab6cf-1c63-4725-bc5b-afd3e0f4efe0" class="bulleted-list"><li style="list-style-type:disc"><strong>Summary (10 minutes read)</strong><ul id="ad0bd2ad-9090-46b1-a822-197fc5a18e6c" class="bulleted-list"><li style="list-style-type:circle">What did we learn?</li></ul><ul id="8eb04281-25d1-4f24-874a-23ea31d409c7" class="bulleted-list"><li style="list-style-type:circle">Shortcomings &amp; Challenges</li></ul><ul id="a44cdfcd-7662-4fa6-bbec-acec04b5f12c" class="bulleted-list"><li style="list-style-type:circle">Best Practices</li></ul><ul id="5ed752ca-b44c-4318-aa21-635818ab8f0d" class="bulleted-list"><li style="list-style-type:circle">Enhance Your Knowledge</li></ul></li></ul></details></li></ul><p id="cac61b9a-58d6-4a91-b10f-44d17ebd8f27" class="">
</p><h1 id="9ce3f7ad-0dec-4881-8781-a21c85df9a5d" class=""><mark class="highlight-brown">Learning Objective</mark></h1><h2 id="d87865b2-002f-40be-abb5-d57880845f0e" class="block-color-default"><mark class="highlight-red"><strong>Introduction</strong></mark></h2><p id="815de9c2-6d81-4704-b128-77c864c36e6d" class="">Pattern matching in JavaScript is a powerful technique developers use to efficiently search, validate, and manipulate text within strings or data sets. With pattern-matching algorithms, we can uncover hidden connections, solve complex problems, and discover new possibilities.</p><p id="b3520a9e-c420-48bd-bf08-c00135293917" class=""><strong>Duration</strong>: 2 hours </p><p id="8b0ae7bc-a7c2-4cda-8760-693af74c34d2" class=""><strong>Focus</strong>: Basics of pattern-matching, Regular expressions, Pattern matching algorithms, and their applications</p><p id="04801a7d-0fb6-4183-b0ac-4224501deee9" class=""><strong>Prerequisites</strong>: JavaScript</p><h2 id="a6fce3b6-1738-4b8b-996d-cbe51e841a84" class="block-color-default"><mark class="highlight-red">Theme </mark></h2><p id="fcc15916-b8f9-466e-af97-c94d3e821f27" class="">Imagine you&#x27;re a detective trying to solve a case. You have a bunch of clues in front of you - footprints, fingerprints, witness statements, and more. But how do you make sense of all this information and find the culprit? The answer is pattern matching.</p><p id="96e77ec4-eb33-4995-b5d4-d2cec9cb03f2" class=""><strong>Pattern matching</strong> is like being a detective for data. It&#x27;s a powerful tool for identifying meaningful relationships and uncovering hidden insights that might not be apparent at first glance. From finding the right words in a text document to detecting anomalies in a large dataset, pattern matching can help you make sense of complex information and make more informed decisions.</p><p id="3026f50d-99fc-4c21-b0f7-71183fbeb144" class="">But just like being a detective, pattern matching takes practice and skill. With the right training and tools, however, anyone can learn to harness the power of pattern matching and unlock new possibilities for innovation and problem-solving.</p><h2 id="620e2853-a014-4e47-ad99-a68d7e389c48" class="block-color-default"><mark class="highlight-red">Primary Goals </mark></h2><ul id="bfdbe609-52ab-4b59-b8bb-2ff951e90565" class="bulleted-list"><li style="list-style-type:disc">Understand the basic concepts of pattern matching and its relevance to various fields such as computer science, statistics, and machine learning.</li></ul><ul id="eeefba9c-2124-4647-b205-2ea55eabb8b2" class="bulleted-list"><li style="list-style-type:disc">Learn how to write code using pattern-matching techniques to solve problems and extract useful information from data sources such as text, images, and numerical data.</li></ul><ul id="224aad36-b82a-4b45-9ca7-a782147b380e" class="bulleted-list"><li style="list-style-type:disc">Become familiar with pattern-matching algorithms and techniques, such as regular expressions, decision trees, and neural networks.</li></ul><ul id="807b4f3b-300d-4d81-b394-857f9604d5d1" class="bulleted-list"><li style="list-style-type:disc">Develop a practical understanding of how pattern matching can be applied in real-world scenarios, such as natural language processing, computer vision, and fraud detection.</li></ul><ul id="7be21abf-87cf-49b3-9615-649124892e0e" class="bulleted-list"><li style="list-style-type:disc">Gain practical experience by implementing and testing pattern-matching algorithms in real-world scenarios.</li></ul><p id="1e0dba44-34b5-40ad-8174-ab9afe5a08da" class="">
</p><h1 id="3c09de0c-a74f-414f-8681-b66b3918715e" class=""><mark class="highlight-brown">Getting Started with Pattern Matching</mark></h1><h2 id="21216c2e-ba26-4eb4-a0f3-85c6ccbf1aa3" class="block-color-default"><mark class="highlight-red">Introduction to pattern matching</mark></h2><p id="063c479f-6801-4d48-a169-c8ff70534bd7" class="">Google&#x27;s search engine and advertising platforms rely on pattern-matching algorithms to deliver accurate search results and targeted advertisements to users. When a user enters a search query, the search engine analyzes the query&#x27;s patterns, keywords, and contextual information to provide the most appropriate and helpful search results. By identifying patterns in the query and comparing them to patterns found on web pages, Google ensures that users receive the most relevant information.</p><h3 id="fc03fe4c-3696-47d5-863e-a639bce47097" class="block-color-default">What is pattern matching?</h3><p id="f13f1f74-441e-4ae5-8a7d-9e93f2a56ce9" class="">Pattern matching is a fundamental aspect of computer science and programming. It plays a crucial role in data validation, text parsing, and data extraction. Its main objective is to verify if a provided data sets, such as a string, list, or structure, aligns with a predetermined pattern.</p><p id="bb81591d-372a-4e09-9096-2b87eefd5d57" class="">Therefore, pattern matching can be defined as <strong>The process of searching for a specific sequence or placement of characters in a given set of data.</strong></p><p id="c1c2c80e-165d-4e12-af40-d3c7d5a0c426" class="">Pattern matching produces <strong>definitive results</strong>: the input string either contains the pattern (is valid) or doesn’t (is invalid).</p><h3 id="bf039d87-c1e8-40d6-bc0f-8ba8dd5c19ac" class="block-color-default">Pattern matching vs String matching</h3><p id="6f2f581c-3af2-4a2f-aa29-b9bbcdd1d869" class="">Before we discuss how pattern-matching algorithms work, it is important to understand their relation with string-matching algorithms. Both these concepts are often treated as the same thing, but they are quite different in their purpose and use. The table below highlights some of the key differences:</p><div id="f7aeb20c-1de7-4131-87a1-4befd9f41c97" class="column-list"><div id="10c2f568-0646-4d7a-b5ba-d90dd6a0eabe" style="width:37.5%" class="column"><p id="6663c9ab-8905-4548-915a-4391767ae77c" class="">
</p></div><div id="450dfd6f-1749-48d5-99d4-88aab6ec6be7" style="width:87.5%" class="column"><table id="121ce385-845c-40dd-8e0e-af05c40813c3" class="simple-table"><thead class="simple-table-header"><tr id="4ee72406-6945-43b8-b24a-065f734551e4"><th id="|k@z" class="simple-table-header-color simple-table-header" style="width:265.5px"><strong>Pattern matching</strong></th><th id="Q\P\" class="simple-table-header-color simple-table-header" style="width:291.5px"><strong>String matching</strong></th></tr></thead><tbody><tr id="b736e6cf-81a5-4d78-b2ea-c1a323fcbf2f"><td id="|k@z" class="" style="width:265.5px">Compares a given input to a set of predefined patterns or rules.</td><td id="Q\P\" class="" style="width:291.5px">Compares a target string with a search string to find matching substrings.</td></tr><tr id="e65fc3d3-e88a-48ff-93af-97f6e97fa0bf"><td id="|k@z" class="" style="width:265.5px">Used for tasks such as natural language processing, image recognition, and data analysis.</td><td id="Q\P\" class="" style="width:291.5px">Primarily used for searching for occurrences of a specific string in a larger text.</td></tr><tr id="87d9174a-8c58-4432-a397-80588076f548"><td id="|k@z" class="" style="width:265.5px">Can handle more complex structures and patterns beyond simple strings, such as regular expressions and semantic graphs.</td><td id="Q\P\" class="" style="width:291.5px">Limited to finding exact matches of a given search string, without accounting for variations or patterns.</td></tr><tr id="e0f22f35-a96b-4d95-99c2-d2563f4c44e9"><td id="|k@z" class="" style="width:265.5px">Can be used to identify and extract specific entities and relationships from unstructured data.</td><td id="Q\P\" class="" style="width:291.5px">Generally used to perform text searches, such as searching for a keyword in a document or searching for a URL in a web page.</td></tr><tr id="4a42e57c-00a7-438c-bc9b-1e64b8d5234a"><td id="|k@z" class="" style="width:265.5px">Can involve techniques such as fuzzy matching, which accounts for variations or discrepancies in patterns.</td><td id="Q\P\" class="" style="width:291.5px">Does not typically involve fuzzy matching or other techniques beyond exact string matching.</td></tr></tbody></table></div></div><h2 id="96c71148-0942-4dbd-ba54-da0a90a837d1" class=""><mark class="highlight-red">How does pattern matching work?</mark></h2><p id="1f059df1-9677-4312-85f6-c5a535ca08c9" class="">Regular expressions tell computer programs which pattern to look for in testing data. Sometimes, the program is intelligent enough to pick patterns from a set of data values and automatically generate a regex. Some programs or tools have a built-in regex library that contains commonly used patterns, such as credit card numbers, U.S. phone numbers, date time formats, email addresses, etc.</p><p id="51ec6fe6-702c-4a25-b4cc-8aae1275ee2f" class="">Here&#x27;s a basic explanation of how it works:</p><ol type="1" id="4c0d5664-303c-444c-a5ce-c77b594d5a59" class="numbered-list" start="1"><li><strong>Defining a Pattern</strong>: The first step in pattern matching is to define a pattern. This pattern can be a simple string, a complex regular expression, or a data structure with placeholders.</li></ol><ol type="1" id="e1a992c1-953b-487e-9d68-dbe5ef6067b1" class="numbered-list" start="2"><li><strong>Matching the Pattern</strong>: Once the pattern is defined, the pattern matching algorithm will try to match this pattern against the input data. The algorithm will check if the input data follows the structure of the pattern, and if the elements of the data fit the constraints of the pattern.</li></ol><ol type="1" id="651de0dc-a1e3-491c-b337-5e95d31a0d4d" class="numbered-list" start="3"><li><strong>Extracting Information</strong>: If the pattern matches, the algorithm can extract the parts of the data that correspond to the placeholders in the pattern. This is useful for parsing complex data structures or extracting specific pieces of information from a text.</li></ol><h3 id="93e17b27-fef6-4c39-9ac1-1ef7c09ffbeb" class=""><strong><strong>Example of the matching Email address pattern</strong></strong></h3><p id="3fd340fb-f9de-4ecb-b826-1f5862bb1443" class="">For example, in the case of text processing, you might define a pattern to extract email addresses from a text. The pattern could be a regular expression that describes the structure of an email address (something like <code>^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$</code>). The pattern matching algorithm would then scan the text, find all sequences of characters that match this pattern, and extract them.</p><p id="dc283629-1091-4bee-8ce2-c77ee564ca28" class="">To figure out what a pattern-matching algorithm is, let’s take the example of validating the pattern of email addresses. The first step is to <strong>define the regex</strong> that communicates the pattern of a valid email address. </p><p id="a9f2f7bf-f191-4da3-8aa0-26ae6453b5fd" class="">A sample pattern of a valid email address may look like this: <code>[name]@[domain].[domain-extension]</code></p><p id="170ea42c-64cd-4407-b8ef-935f57411267" class="">In the regex language, this pattern will be translated as: <code>^[^\s@]+@[^\s@]+\.[^\s@]+$</code> where,</p><ul id="de7ac3ee-dfef-412d-a373-c781cfab33cf" class="bulleted-list"><li style="list-style-type:disc"><code><strong>^</strong></code> : matches the beginning of the string</li></ul><ul id="995bdeb0-2ac7-479b-bd2d-7feba9830f67" class="bulleted-list"><li style="list-style-type:disc"><code><strong>[^\s@]+</strong></code> : matches one or more characters that are not whitespace or &quot;@&quot; symbol (i.e., the username)</li></ul><ul id="e6df7e87-4292-435b-9c89-ca6f40521e5e" class="bulleted-list"><li style="list-style-type:disc"><code><strong>@</strong></code> : matches the &quot;@&quot; symbol</li></ul><ul id="80c691a3-95a5-4d15-bb12-7de99a83cdaf" class="bulleted-list"><li style="list-style-type:disc"><code><strong>[^\s@]+</strong></code> : matches one or more characters that are not whitespace or &quot;@&quot; symbol (i.e., the domain)</li></ul><ul id="52fc51b9-314a-49f0-8f3f-82d41ecf950d" class="bulleted-list"><li style="list-style-type:disc"><code><strong>\.</strong></code> : matches a literal &quot;.&quot; symbol</li></ul><ul id="1a0f6138-313d-446a-b4e5-3cf75c3f2379" class="bulleted-list"><li style="list-style-type:disc"><code><strong>[^\s@]+</strong></code> : matches one or more characters that are not whitespace or &quot;@&quot; symbol (i.e., domain-extension)</li></ul><ul id="db6694d7-351d-47e4-a57d-7121c745c892" class="bulleted-list"><li style="list-style-type:disc"><code><strong>$</strong></code> : matches the end of the string</li></ul><p id="e82dd93d-080a-46b4-8ad5-13efcec4b2d4" class="">
</p><p id="8ad04a5c-343a-4492-9ed0-e46327b62431" class="">Here are some examples of implementing the same pattern in JavaScript:</p><p id="5be715f6-8b1c-4c28-ab6e-f424e02792d6" class=""><strong>In JavaScript the Email Address Regex Pattern will look like:</strong></p><pre id="cb2831c8-7e2b-46e5-9969-da08d66edad0" class="code"><code>function isValidEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

// Example usage
const email1 = &quot;michael.scott@gmail.com&quot;;
const email2 = &quot;pam.beesly_gmail.com&quot;;
console.log(isValidEmail(email1)); // Output: true
console.log(isValidEmail(email2)); // Output: false</code></pre><p id="273f738d-088c-4350-ae40-f9b46d9d9096" class="">In the above code the email string regular expression pattern i.e. <code>emailRegex</code> will be matched with the input string <code>email1</code>, <code>email2</code> and based on that Email will be validated if that email is valid or not.</p><div id="7d81892b-a7d0-4b52-a118-835b17c8dd1d" class="column-list"><div id="e7449318-2279-453e-9d0d-9d232142a280" style="width:18.75%" class="column"><p id="08195d28-0fb5-403f-ac36-44ed96d192d0" class="">
</p></div><div id="42de92b5-5c22-478d-a158-420da9a0118e" style="width:112.5%" class="column"><table id="e9a11c3e-6c3c-4968-a870-3be637b3e26a" class="simple-table"><thead class="simple-table-header"><tr id="24ab6edb-6c3d-4f18-98ac-4408c7d1aee7"><th id="eCgg" class="simple-table-header-color simple-table-header" style="width:174.5px"><strong>No.</strong></th><th id="gYUh" class="simple-table-header-color simple-table-header" style="width:174.5px"><strong>Test</strong></th><th id="?plC" class="simple-table-header-color simple-table-header" style="width:174.5px"><strong>Result</strong></th><th id="wESa" class="simple-table-header-color simple-table-header" style="width:113.5px"><strong>Reason for failure</strong></th></tr></thead><tbody><tr id="9a9c54b4-7c36-4570-ae76-a5d5b013be07"><td id="eCgg" class="" style="width:174.5px">1.</td><td id="gYUh" class="" style="width:174.5px">michael.scott@gmail.com</td><td id="?plC" class="" style="width:174.5px">Valid</td><td id="wESa" class="" style="width:113.5px"></td></tr><tr id="9e07a181-2729-413b-9fa8-c7a42c41c866"><td id="eCgg" class="" style="width:174.5px">2.</td><td id="gYUh" class="" style="width:174.5px">pam.beesly_gmail.com</td><td id="?plC" class="" style="width:174.5px">Invalid</td><td id="wESa" class="" style="width:113.5px">Missing @ symbol.</td></tr></tbody></table></div></div><h2 id="6bef8666-e28f-4c1d-af71-12e91f348864" class="block-color-default"><mark class="highlight-red"><strong>Pattern matching use cases</strong></mark></h2><p id="73c928fe-8de6-4580-86ce-66ddd7436d92" class="">Pattern matching is one of the most fundamental concepts across different fields, such as computer programming, data science and analysis, natural language processing, and more.</p><p id="62e47e4d-e29a-4359-8c1d-c5774ed64aba" class="">If we specifically talk about pattern matching and validation in the data field, here are some of its most common applications:</p><ol type="1" id="165ae43e-bf08-4bbf-bc5e-d84059e36092" class="numbered-list" start="1"><li><strong> Validating form submissions: </strong>As data pattern matching differentiates between valid and invalid information, it is mostly used to validate forms submitted on websites or other software applications. The regex is applied on the form fields as needed to identify correct information.</li></ol><ol type="1" id="4c0bd4f7-f72b-4657-a22a-1de30f623ce1" class="numbered-list" start="2"><li><strong>Performing search and replace operations: </strong>Pattern matching is also useful in applications that have to find and replace features for textual information. Some basic applications only offer character-by-character matching (or string matching). At the same time, others also provide regex search and replace functionality – that allows you to search patterns in text documents and not just exact string matches.</li></ol><ol type="1" id="6a826d7e-970b-4075-a3fe-060b070664b2" class="numbered-list" start="3"><li><strong>Cleaning and standardizing datasets: </strong>You can try to validate information at data entry – such as form submissions. However, due to the various limitations and restrictions encountered across systems, your organizational datasets can still end up with multiple representations of the same information. </li></ol><ol type="1" id="444d723d-df38-4626-89a8-99287737f942" class="numbered-list" start="4"><li><strong>Parsing and extracting values: </strong>Since pattern matching looks for a specific sequence of characters in a given value, this process is also useful to match and extract value tokens that reside in extended forms of information. For example, you can extract the domains from a list of business email addresses to find out which company the person works at.</li></ol><ol type="1" id="e16acbcb-97b1-489c-b754-31e1b30c76aa" class="numbered-list" start="5"><li><strong>Pattern Recognition: </strong>Pattern matching can be used in machine learning and artificial intelligence applications to recognize patterns within data. For example, pattern matching can be used to recognize speech patterns in audio data or to recognize image patterns in visual data.</li></ol><p id="3b1972df-fa36-4641-83b1-4a74cc8a77ce" class="">
</p><h2 id="684f406e-5ea5-48ad-b048-aabdcfd50fe2" class="block-color-default"><mark class="highlight-blue">Do it yourself</mark></h2><ol type="1" id="d495197a-1a32-4d82-9797-23b5f328d4d8" class="numbered-list" start="1"><li>In computer vision, pattern matching is used to recognize and classify ________ <strong>(textures/objects/facial expressions)</strong> based on their visual characteristics.</li></ol><ol type="1" id="86374549-ee8a-4da9-b780-9d876c42cac5" class="numbered-list" start="2"><li>Pattern matching involves comparing a given input to a set of predefined _______ <strong>(edges/shapes/patterns)</strong> or rules.</li></ol><ol type="1" id="a80b9ff2-781c-4d4f-8b56-98dabec9f44d" class="numbered-list" start="3"><li>One of the most exciting aspects of pattern matching is its __________ <strong>(versatility/autonomous nature/surveillance system).</strong></li></ol><ul id="cb1476c9-9482-40d9-9999-00b324931277" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><ol type="1" id="33b971f5-3216-4c52-9310-68829f70246c" class="numbered-list" start="1"><li>Objects</li></ol><ol type="1" id="726497e6-f6a3-45b8-806b-1f7e7891fde7" class="numbered-list" start="2"><li>Patterns</li></ol><ol type="1" id="3733921e-1282-467c-89c9-13713e9ef22e" class="numbered-list" start="3"><li>Versatility</li></ol></details></li></ul><p id="a87f7048-723c-4f34-b415-71feb273d0e9" class="">
</p><h2 id="9d419c06-73cd-4c00-b22e-119270219aa0" class="block-color-default"><mark class="highlight-red">Regular Expressions</mark></h2><p id="7037ba77-35c9-44ca-82bd-473ee5c2ae38" class="">Regex, or regular expressions, are special sequences used to find or match patterns in strings. These sequences use <strong>metacharacters</strong> and other syntax to represent sets, ranges, or specific characters. </p><p id="2e4ce249-9d7e-48e5-bdc1-1efa482bef88" class="">For example, the expression <code>[0-9]</code> matches the range of numbers between 0 and 9, and <code>humor | humour</code> matches both the strings <strong>humor</strong> and <strong>humour</strong>.</p><p id="8345c4e4-4824-48b3-9fee-0f1afc022d83" class="">They may look complicated and intimidating to new users.</p><p id="e77647de-d88f-4367-8848-1425c3305357" class="">Take a look at this example:</p><p id="e2d9bb39-6242-4618-9798-b849aa9cb556" class=""><code>/^[a-zA-Z0-9.!#$%&amp;’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/</code> This is a type of Regular Expression for certain pattern matching.</p><p id="79ce03aa-50f6-4435-9940-d2f221a2a49a" class="">The terminology used in Regex:</p><ul id="1ba802fd-1304-44e0-97b5-cb55d5ff8cd7" class="bulleted-list"><li style="list-style-type:disc"><strong>pattern</strong>: regular expression pattern</li></ul><ul id="1f9aec6f-8ea2-4e38-bfdf-ace59a6027fa" class="bulleted-list"><li style="list-style-type:disc"><strong>string</strong>: test string used to match the pattern</li></ul><ul id="a39b7c54-d9a4-4185-b892-c710012a5073" class="bulleted-list"><li style="list-style-type:disc"><strong>digit</strong>: 0-9</li></ul><ul id="32dbfe62-dc91-4324-953a-bd58ab03c275" class="bulleted-list"><li style="list-style-type:disc"><strong>letter</strong>: a-z, A-Z</li></ul><ul id="2ede630f-d401-4977-9045-4e741f6f8797" class="bulleted-list"><li style="list-style-type:disc"><strong>symbol</strong>: !$%^&amp;*()_+|~-=`{}[]:”;&#x27;&lt;&gt;?,./</li></ul><ul id="5e31e2b5-cbb9-49a7-a853-b6bd54b423cb" class="bulleted-list"><li style="list-style-type:disc"><strong>space</strong>: single white space, tab</li></ul><ul id="a28c8ba7-a399-421b-9232-f226c884b131" class="bulleted-list"><li style="list-style-type:disc"><strong>character</strong>: refers to a letter, digit or symbol</li></ul><h3 id="c7d0fc1c-8b41-49c0-99ac-2b4ca7c0aaee" class=""><strong>Basics of Regex</strong></h3><p id="55026f58-44f1-475c-843a-134a753ac8b8" class="">To learn regex quickly with this guide, visit <a href="https://regex101.com/"><strong>Regex101</strong></a>, where you can build regex patterns and test them against strings (text) that you supply.</p><p id="ba22dcf8-1ade-467f-8757-8464c900d586" class="">When you open the site, you’ll need to select the <strong>JavaScript</strong> flavor, as that’s what we’ll be using for this guide. (Regex syntax is mostly the same for all languages, but there are some minor differences.)</p><ul id="37eaa0fd-48bf-4f5f-86ef-88f0ebf09ca4" class="bulleted-list"><li style="list-style-type:disc"><strong>regex input field</strong>: cat</li></ul><ul id="b950d597-f4b4-4171-9438-3983ebe20c0d" class="bulleted-list"><li style="list-style-type:disc"><strong>test string</strong>: rat bat cat sat fat cats eat tat cat mat CAT</li></ul><figure id="7b9510c9-daf3-4ccc-904f-6efc3edecad3" class="image"><img style="width:1877px" src="Introduction%20to%20Pattern%20Matching%209786b0b7e905402bb93a80307df45e09/2023-06-02_15.23.49_regex101.com_89d6221b899c.png"/></a></figure><p id="50ae2c2e-5087-4055-8dca-37af57b38c5c" class="">Take note that regular expressions in JavaScript start and end with <code>/</code>. If you were to write a regular expression in JavaScript code, it would look like this:</p><pre id="ef99a876-04e1-464b-ba18-5b8db37ad0fe" class="code"><code>const matchregex = /cat/;           //This is the regex for matching cat word</code></pre><p id="3e2567c5-60d0-4678-b70d-9c8da7593f22" class="">There is one more way of creating Regex in JavaScript i.e. using <code>RegExp()</code> object. In this way there is no need to add slashes like in above example.</p><pre id="a4ca6fac-57a0-4f14-88e5-cce055b88e21" class="code"><code>const matchregex = new RegExp(&quot;cat&quot;);</code></pre><h3 id="d467fc60-13f8-464f-ac1b-e8c2eb0fd06e" class="block-color-default"><strong>Global and Case-Insensitive Regex Flags</strong></h3><p id="40152818-4f8d-4f2e-819a-57b0884d0100" class="">By default, a regex pattern will only return the first match it finds. If you’d like to return additional matches, you need to enable the <strong>global</strong> flag, denoted as <code>g</code>. </p><p id="0aac94a2-15de-4fe7-85cc-388644a4bb80" class="">Regex patterns are also case-sensitive by default. You can override this behavior by enabling the <strong>insensitive</strong> flag, denoted by <code>i</code>. The updated regex pattern is now fully expressed as <code>/cat/gi</code>. As you can see below, all “cat” strings have been matched including the one with a different case.</p><figure id="0d047460-af2c-4308-a57a-5b3a725a0f54" class="image"><img style="width:1877px" src="Introduction%20to%20Pattern%20Matching%209786b0b7e905402bb93a80307df45e09/2023-06-06_18.26.45_regex101.com_acb696c0f3bd.png"/></a></figure><p id="4b931e25-ea52-412e-9589-a2f2eab6b6ad" class="">We need to add these flags in the end of regex defined. In JavaScript for both Global and Case Insensitive Search the regex pattern will look like:</p><h3 id="9a690de2-5ea5-4bba-813a-e5b2dddacb6b" class=""><strong>Character Sets</strong></h3><p id="1edc2cee-52cb-4040-bb02-598e62a07f7f" class="">In the previous example, we learned how to perform exact case-sensitive matches. What if we wanted to match “bat”, “cat”, and “fat”. We can do this by using <strong>character sets</strong>, denoted with <code>[]</code> . Basically, you put in multiple characters that you want to get matched. </p><p id="faba10e7-25ec-4550-b2e0-09ce481d9196" class="">For example, <code>[bcf]at</code> will match multiple strings as follows:</p><figure id="a2e0f82f-22ab-4f92-a2f2-d8157777a5c8" class="image"><img style="width:1877px" src="Introduction%20to%20Pattern%20Matching%209786b0b7e905402bb93a80307df45e09/2023-06-06_18.44.42_regex101.com_a30f8ee2ba3b.png"/></a></figure><p id="c24ed8e6-5386-46dc-8f93-e71e9e3aa545" class="">In JavaScript It Will Look Like:</p><pre id="fcf14f54-5ab5-4422-a573-a2b609da2010" class="code"><code>const matchregex=/[bcf]at/ 
//or
const matchregex=new RegExp(&quot;[bcf]at&quot;)</code></pre><h3 id="14d94d73-41cc-4078-9ae2-9a9d715d3069" class=""><strong>Ranges</strong></h3><p id="6ab46028-e2b8-44c0-a701-e33f1f881ea3" class="">Let’s assume we want to match all words that end with <code>at</code>. We could supply the full alphabet inside the character set, but that would be tedious. The solution is to use ranges like this <code>[a-z]at</code>:</p><figure id="e3228d02-ff8c-4e22-9753-f1d2b6c4aaf8" class="image"><img style="width:1877px" src="Introduction%20to%20Pattern%20Matching%209786b0b7e905402bb93a80307df45e09/2023-06-06_18.45.44_regex101.com_e2380d2a4f76.png"/></a></figure><p id="097faf13-bf32-412a-8957-b4bc6fbcba5a" class="">In JavaScript It Will Look Like:</p><pre id="43a82a8d-7811-48d9-9a3f-8dda7b263147" class="code"><code>const matchregex=/[a-z]at/
//or 
const matchregex=new RegExp(&quot;[a-z]at&quot;)</code></pre><h3 id="6d46977f-3358-4322-8c13-bfdeed5fa6f9" class="">Character Classes</h3><p id="0f3e87b7-44c1-489a-a914-8426aabe27ba" class="">Character Classes allow you to write regular expression patterns that are even more compact. Let’s go through them one by one:</p><ul id="da71eeab-009d-4152-962c-e7e54e0e95cd" class="bulleted-list"><li style="list-style-type:disc"><code>\d</code> matches any digit that is the same as <code>[0-9]</code></li></ul><ul id="0f2220a6-c799-43b7-964c-5c51c63cc9c9" class="bulleted-list"><li style="list-style-type:disc"><code>\D</code> Matches any character that is not a digit (Arabic numeral). equivalent to  <code>[^0-9]</code></li></ul><ul id="4a7ba5c7-1eb2-4874-818c-b92e1e9c3010" class="bulleted-list"><li style="list-style-type:disc"><code>\w</code> matches any letter, digit and underscore character</li></ul><ul id="1a44b8a7-4164-4664-a19d-7a12a936aa88" class="bulleted-list"><li style="list-style-type:disc"><code>\s</code> matches a whitespace character — that is, a space or tab</li></ul><ul id="195eb17b-6cca-4845-bf28-f6dda44cfde3" class="bulleted-list"><li style="list-style-type:disc"><code>\t</code> matches a tab character only</li></ul><p id="9d7ab75d-5a70-40ce-b221-a1fb06a557e6" class="">From what we’ve learned so far, we can write regular expressions like this:</p><ul id="13b7d0d5-0486-4832-af9c-fc7b73e73e7d" class="bulleted-list"><li style="list-style-type:disc"><code>\w{5}</code> matches any five-letter word or a five-digit number</li></ul><ul id="e436a742-d043-4a9e-b3ae-3e50c1cfdc1d" class="bulleted-list"><li style="list-style-type:disc"><code>\d{11}</code> matches an 11-digit number such as a phone number</li></ul><h3 id="4d131161-95b9-4db2-a435-98a3677786a4" class=""><strong>Groups</strong></h3><p id="189b1e0d-8903-43a2-bd87-039d356cc5ab" class="">All the special characters we just mentioned only affect a single character or a range set. What if we wanted the effect to apply to a <em>section</em> of the expression?</p><p id="e5fd44fb-3fdf-4171-882b-edaecdf01347" class="">We can do this by creating groups using round brackets — <code>()</code>. For example, the pattern <code>book(.com)?</code> will match both “book” and “book.com”, since we’ve made the “.com” part optional.</p><p id="8f18c41a-ca3c-478b-8687-067ce33ef538" class="">Here’s a more complex example that would be used in a realistic scenario such as email validation:</p><ul id="32567f72-609d-4ab7-a848-6e2404670a9a" class="bulleted-list"><li style="list-style-type:disc">pattern: <code>@\w+\.\w{2,3}(\.\w{2,3})?</code></li></ul><ul id="5623d744-dc41-4a9d-a8e5-1061d886ac38" class="bulleted-list"><li style="list-style-type:disc">test string: <code>abc.com abc@mail @mail.com @mail.co.ke</code></li></ul><figure id="ed46187c-f5d2-4929-9268-e37c353d0dd9" class="image"><img style="width:1877px" src="Introduction%20to%20Pattern%20Matching%209786b0b7e905402bb93a80307df45e09/2023-06-06_18.47.11_regex101.com_88d22cac9d51.png"/></a></figure><h2 id="11c001e5-eb6d-4be7-ab90-60e19948effd" class="block-color-default"><mark class="highlight-blue">Activity 1</mark></h2><p id="488b8c03-139f-4e5e-bb58-173ed7ba0be8" class=""><strong>Fill in the blanks:</strong></p><ol type="1" id="0284246c-6f37-4544-b4f6-b8cd3fca3dc4" class="numbered-list" start="1"><li>Regular expressions are patterns of characters used to search for and match specific _______ <strong>(words/strings/characters) </strong>of text.</li></ol><ol type="1" id="375454fe-036e-4798-a1ed-70ce127a786e" class="numbered-list" start="2"><li>Regular expressions can be used to perform a wide range of text processing tasks, such as finding and extracting data from web pages, validating user input in forms, and parsing _______ <strong>(HTML/Log/XML)</strong> files.</li></ol><ol type="1" id="600535b1-81c5-4f6b-a165-3b7858b69886" class="numbered-list" start="3"><li>Regular expressions are highly _______ <strong>(efficient/portable/flexible) </strong>and customizable.</li></ol><ol type="1" id="91c0451c-4dd5-4eb0-8bfe-3652ff6993ae" class="numbered-list" start="4"><li>Special characters and syntax can be used to match any combination of characters, from simple strings to complex _______<strong>(URL/patterns/phone numbers)</strong> .</li></ol><ul id="f950c2c1-e1a5-4ace-a7f9-75b56500f248" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><ol type="1" id="3a2a329e-6e7c-4a2f-97aa-ecf329133563" class="numbered-list" start="1"><li>Strings</li></ol><ol type="1" id="ed96c477-198d-47d8-99b8-e395355466e8" class="numbered-list" start="2"><li>Log</li></ol><ol type="1" id="f9733d3d-9f15-4d5d-b3a2-e116673a675d" class="numbered-list" start="3"><li>Flexible</li></ol><ol type="1" id="af937620-4a3d-46b1-b4c5-38ab8622ec97" class="numbered-list" start="4"><li>Patterns</li></ol></details></li></ul><h2 id="9b1bd51e-9235-42ee-b39b-f916a55501e8" class=""><mark class="highlight-red">Assertions</mark></h2><p id="45e641ff-7def-4d3b-ac96-4e58902e456f" class="">Assertions, also known as zero-width assertions or look around, are special regex characters that allow you to make sure that a pattern is (or is not) followed by another pattern without including the second pattern in the match. </p><p id="6f11df67-59f7-4b46-8ce1-ec4b11b7b24b" class="">Assertions don&#x27;t consume any characters, which means that they don&#x27;t match any actual characters in the string you&#x27;re searching.</p><p id="435e312b-3413-46ce-917b-d1a0c10003f4" class="">Assertions include boundaries, which indicate the beginnings and endings of lines and words, and other patterns indicating in some way that a match is possible.</p><p id="fef57a96-4835-49e4-9a9e-aa579b48aea4" class="">There are 3 types of Assertions:</p><ul id="f1bcccec-4ee8-4e1e-9df9-becd9a420608" class="bulleted-list"><li style="list-style-type:disc">Boundary Assertion</li></ul><ul id="6196b2e7-2dcc-425f-9a03-f75712c18a2c" class="bulleted-list"><li style="list-style-type:disc">Positive Assertion</li></ul><ul id="42cb40e3-5f9f-46bb-ba62-2a8cd472f8fc" class="bulleted-list"><li style="list-style-type:disc">Negative Assertion</li></ul><p id="19090d44-0294-48b9-a430-2b547da6f957" class=""><strong>Boundary Assertion: </strong></p><div id="9bca4daa-790f-4d92-bcef-a8eabc8d708d" class="column-list"><div id="75d489c5-ab88-4c98-a13b-f606bfb6a9ca" style="width:31.25%" class="column"><p id="f5269c22-632a-4364-8a47-4e1e217e7881" class="">
</p></div><div id="ea1421c2-1c0b-4e67-b61b-a7736c77e667" style="width:100%" class="column"><table id="943b921d-e99f-4a93-bcf1-02ed9fad4b65" class="simple-table"><thead class="simple-table-header"><tr id="6a0f65db-d8ba-40b1-ae37-6667461b2e4a"><th id="mi&gt;G" class="simple-table-header-color simple-table-header" style="width:124.5px">Characters</th><th id="OoCr" class="simple-table-header-color simple-table-header" style="width:465.5px">Meaning</th></tr></thead><tbody><tr id="45011aa6-29b7-4d61-8411-3f048bddcd97"><td id="mi&gt;G" class="" style="width:124.5px"><code>^</code></td><td id="OoCr" class="" style="width:465.5px">Matches the beginning of input. If the multiline flag is set to true, also matches immediately after a line break character. For example, <code>/^A/</code> does not match the &quot;A&quot; in &quot;an A&quot;, but does match the first &quot;A&quot; in &quot;An A&quot;.</td></tr><tr id="649e7e3b-0c0c-469c-876a-37784c3933d0"><td id="mi&gt;G" class="" style="width:124.5px"><code>$</code></td><td id="OoCr" class="" style="width:465.5px">Matches the end of input. If the multiline flag is set to true, also matches immediately before a line break character. For example, <code>/t$/</code> does not match the &quot;t&quot; in &quot;eater&quot;, but does match it in &quot;eat&quot;.</td></tr><tr id="4d324d36-116b-4daf-a5f5-f1375cc51563"><td id="mi&gt;G" class="" style="width:124.5px"><code>\b</code></td><td id="OoCr" class="" style="width:465.5px">Matches a word boundary. This is the position where a word character is not followed or preceded by another word-character, such as between a letter and a space.
For Example:  <code>/\bm/</code> matches the &quot;m&quot; in &quot;moon&quot;.</td></tr><tr id="eaadcf3c-434a-43d6-8294-3554161f99f2"><td id="mi&gt;G" class="" style="width:124.5px"><code>\B</code></td><td id="OoCr" class="" style="width:465.5px">Matches a non-word boundary. This is a position where the previous and next character are of the same type: Either both must be words, or both must be non-words, for example between two letters or between two spaces. For example, <code>/\Bon/</code> matches &quot;on&quot; in &quot;at noon&quot;, and <code>/ye\B/</code> matches &quot;ye&quot; in &quot;possibly yesterday&quot;.</td></tr></tbody></table></div></div><p id="0f8ada4f-b677-4b89-ae60-cec0494e8f9d" class=""><strong>Positive Assertions</strong>:</p><ul id="0c744245-5e4c-4ddb-b606-373d2ca60ad1" class="bulleted-list"><li style="list-style-type:disc"><code><strong>(?=pattern)</strong></code> - positive lookahead assertion. Matches the pattern only if it&#x27;s followed by another pattern.</li></ul><ul id="466e7bc7-996b-418a-8a4c-19a8f07cb167" class="bulleted-list"><li style="list-style-type:disc"><code><strong>(?&lt;=pattern)</strong></code> - positive lookbehind assertion. Matches the pattern only if it&#x27;s preceded by another pattern.</li></ul><p id="866f6bb6-9a7b-4cca-9db3-d061b1486634" class=""><strong>Negative assertions</strong>:</p><ul id="cadb38fa-af09-48e5-9ae6-ebcd49b59b40" class="bulleted-list"><li style="list-style-type:disc"><code><strong>(?!pattern)</strong></code> - negative lookahead assertion. Matches the pattern only if it&#x27;s not followed by another pattern.</li></ul><ul id="4ec7f27f-cea1-4e50-a364-4a60f3a322d3" class="bulleted-list"><li style="list-style-type:disc"><code><strong>(?&lt;!pattern)</strong></code> - negative lookbehind assertion. Matches the pattern only if it&#x27;s not preceded by another pattern.</li></ul><h3 id="c36b4266-009a-48be-86dd-4303c0a127eb" class="block-color-default"><strong>Alternate Characters</strong></h3><p id="33a4e5fe-6675-41fb-b25d-5aeab5f2c442" class="">In regex, we can specify alternate characters using the “pipe” symbol — <code>|</code>. This is different from the special characters we showed earlier as it affects all the characters on each side of the pipe symbol. For example, the pattern <code>sat|sit</code> will match both “sat” and “sit” strings. </p><p id="4e96f663-acba-423b-91ab-6b195e51a645" class="">The above pattern can be expressed as <code>s(a|i)t</code> by using <code>()</code> parentheses.</p><h2 id="c4942a79-c5fe-49bd-9871-fc2bdb059a19" class="block-color-default"><mark class="highlight-red"><strong>Bracket Expressions</strong></mark></h2><p id="f2868b2a-7780-4756-887b-ec67dde45629" class="">Inside the bracket expressions, you can place any special characters you want to use to specify the character sets.</p><p id="fa002afe-eeef-4d5d-97a9-c87b5660b067" class="">For example,</p><p id="5c5bdbbc-b163-4e12-94a9-715737b8d09e" class=""><code>const regex = /[A-Z]/</code>. Notice that A-Z is inside the square brackets so this will search for all uppercase letters in the alphabet.</p><ul id="164c5c3c-605e-4e61-b7da-b7d1683c8316" class="bulleted-list"><li style="list-style-type:disc">[a-z] matches a string that has all lowercase letters in the entire alphabet</li></ul><ul id="ccd41083-d46e-42ad-b78f-fe6614b2361c" class="bulleted-list"><li style="list-style-type:disc">[A-Z] matches a string that has all the uppercase letters in the entire alphabet</li></ul><ul id="4416194b-3d64-41f1-a9bf-9a111dc441a7" class="bulleted-list"><li style="list-style-type:disc">[abcd] matches a string that has a, b, c, d</li></ul><ul id="ba16f7ae-ec18-4fdf-ac84-5f938423c8bc" class="bulleted-list"><li style="list-style-type:disc">[a-d] exactly the same as the previous example so you can either specify each character or group them</li></ul><ul id="ee90263b-c9d0-41be-b6b4-176c9a520f58" class="bulleted-list"><li style="list-style-type:disc">[a-gA-C0-7] matches string that has lowercase letters a-g, uppercase letters A-C, or numbers 0-7</li></ul><ul id="aa6caabb-2660-4ed6-9f2b-7daa12225c60" class="bulleted-list"><li style="list-style-type:disc">[^a-zA-Z] matches a string that DOES NOT have all lowercase or uppercase letters</li></ul><p id="8b52ff95-67b0-44f3-ac2d-e974ca5e01a3" class="">Inside a character set, the ^ character means all the characters that are NOT in the a-z or A-Z.</p><h2 id="19e3edb9-7760-4eee-990e-db122f5a0e08" class=""><mark class="highlight-red">Flags</mark></h2><p id="1d587d37-470d-4cf7-870e-5284267b0a67" class="">After we end with a slash character, we can either choose one specific flag or combine them. Regex uses flags to be more specific on how to properly find and match the defined custom characters.</p><p id="43ef9613-268d-4394-bc7d-58ea657c29b3" class="">Before we go into the specific flags, you should keep in mind that flags are optional, like the example below:</p><ul id="528b7f19-af1f-4c00-ab5a-1a95340218af" class="toggle"><li><details close=""><summary><strong>Examples</strong></summary><pre id="76c29a75-382e-4dc6-a3f8-379ef8fad5e5" class="code"><code>const sentence = &#x27;The Cat in the Hat is not a cat.&#x27;
const regex = /[A-Z]/;
const found = sentence.match(regex);
console.log(found);
// Expected Output: [&#x27;T&#x27;]</code></pre><p id="85dfda9b-9414-4f08-bfb8-1fae8de57b0e" class="">Without flags, Regex will find the first character that returns true in an array within the slashes. So, in this case, our code will return: [‘T’] because it found the first uppercase letter in the sentence.</p><p id="8cf5c35a-f6f5-4582-9530-0c018b16d14a" class="">The g flag stands for global, which means it will return what is true within the entire regular expression. In other words, it will return not only after the first match but ALL the occurrences that matched.</p><p id="69c07863-6739-466b-b84e-23d7325feab6" class="">If we added the g flag at the end of our slash, it will return all the characters from the regular expression that is upper case.</p><pre id="7ea946a6-d92d-4457-808a-286e01acb647" class="code"><code>const sentence = &#x27;The Cat in the Hat is not a cat.&#x27;
const regex = /[TheCatInTheHatIsNotACat]/ig;
const found = sentence.match(regex);
console.log(found);
// Expected Output: [
// &#x27;T&#x27;, &#x27;h&#x27;, &#x27;e&#x27;,
// &#x27;C&#x27;, &#x27;a&#x27;, &#x27;t&#x27;,
// &#x27;i&#x27;, &#x27;n&#x27;,
// &#x27;t&#x27;, &#x27;h&#x27;, &#x27;e,
// &#x27;H&#x27;, &#x27;a&#x27;, &#x27;t&#x27;
// &#x27;i&#x27;, &#x27;s&#x27;,
// &#x27;n&#x27;, &#x27;o&#x27;, &#x27;t&#x27;,
// &#x27;a&#x27;,
// &#x27;c&#x27;, &#x27;a&#x27;, &#x27;t&#x27;
]</code></pre><p id="826ccc0a-5e90-46ce-ab57-0c34648f0244" class="">Let’s say we changed const variable to be <code>const regex = /[a-z]/m</code>.</p><p id="06118bd9-afa0-4eec-8a9f-a0808426493c" class="">The m flag will be checked to see the first instance of a lowercase letter from a-z so it will return [‘h’].</p><pre id="fe57dba1-56ee-4280-bd70-009934e0c05f" class="code"><code>const sentence = &#x27;The Cat in the Hat is not a cat.&#x27;
const regex = /[A-Z]/m;
const found = sentence.match(regex);
console.log(found);
// Expected Output: [&#x27;h&#x27;]</code></pre><p id="8ec0232f-8df5-4f63-88de-af5d4088424f" class="">As an additional side note, there are three other character classes that can help when using multiple character sets to match.</p><pre id="346e2893-c98f-49b0-9806-561406132f56" class="code"><code>const sentence = &#x27;There are 350 dogs and 17 cats in the house.&#x27;
const regex = /\d/;
const found = sentence.match(regex);
console.log(found);
// Expected Output: [&#x27;3&#x27;]</code></pre><pre id="350f19dd-7ed9-4893-b08e-4dc0c90fb9c3" class="code"><code>const sentence = &#x27;There are 350 dogs and 17 cats in the house.&#x27;
const regex = /\w/;
const found = sentence.match(regex);
console.log(found);
// Expected Output: [&#x27;T&#x27;]</code></pre><pre id="e5e1d286-f2c5-45a9-8e0f-242a78600ef6" class="code"><code>const sentence = &#x27;There are 350 dogs and 17 cats in the house.&#x27;
const regex = /\s/;
const found = sentence.match(regex);
console.log(found);
// Expected Output: [&#x27; &#x27;]</code></pre><pre id="18a453ed-f054-473a-a891-dba49f4f3573" class="code"><code>const sentence = &#x27;There are 350 dogs and 17 cats in the house.&#x27;
const regex = /\w\s/;
const found = sentence.match(regex);
console.log(found);
// Expected Output: [&#x27;e &#x27;]</code></pre><p id="6aadd1ee-f99d-4cc8-8fe0-3834d52e1c19" class="">The negations of \d, \w, and \s will be \D, \W, and \S. It will find the following:</p><p id="1e9f5b2b-6541-49c2-9457-a805b1122420" class="">\D matches any non digit character (same as [^0-9])\W matches any non word character (same as [^a-zA-Z0-9_])\S matches a non whitespace character</p></details></li></ul><h2 id="20e96670-491a-4841-b35b-31ee343b97fa" class=""><mark class="highlight-red">Quantifiers</mark></h2><p id="3d5ad204-2e63-4368-b084-29930f03567b" class="">Quantifiers indicate numbers of characters or expressions to match. Quantifiers take us a step further into writing more advanced pattern expressions:</p><ul id="0b6c74e1-6046-43ba-8c8f-23ed277e8e77" class="bulleted-list"><li style="list-style-type:disc"><code>+</code>: One or more quantifiers (preceding characters must exist and can be optionally duplicated). For example, the expression <code>c+at</code> will match “cat”, “ccat” and “ccccccccat”. </li></ul><ul id="eade5c3b-c096-40d5-938f-9e9a5f643859" class="bulleted-list"><li style="list-style-type:disc"><code>?</code>: Zero or one quantifier (preceding character is optional). For example, the expression <code>c?at</code> will only match “cat” or “at”.</li></ul><ul id="f26de12a-a2af-4f69-8f22-9be57ef953d5" class="bulleted-list"><li style="list-style-type:disc"><code>*</code>: Zero or more quantifiers (preceding character is optional and can be optionally duplicated). For example, the expression <code>c*at</code> will match “at”, “cat” and “ccccccat”. It’s like the combination of <code>+</code> and <code>?</code>.</li></ul><ul id="5d651a22-6d22-40de-8c06-7afae3d4f5cd" class="bulleted-list"><li style="list-style-type:disc"><code>\</code>: this “escape character” is used when we want to use a special character literally. For example, <code>c\*</code> will exactly match “c*” and not “ccccccc”.</li></ul><ul id="f5a75057-547b-471a-9dd5-039a15bbedae" class="bulleted-list"><li style="list-style-type:disc"><code>[^]</code>: this “negate” notation is used to indicate a character that should not be matched within a range. For example, the expression <code>b[^a-c]ld</code> will not match “bald” or “bbld” because the second letters a to c are negative.</li></ul><ul id="d8f89127-f915-4ac5-92ca-a3a3d133ae97" class="bulleted-list"><li style="list-style-type:disc"><code>{</code><code><em>n</em></code><code>}</code>: Where &quot;n&quot; is a positive integer, matches exactly &quot;n&quot; occurrences of the preceding item &quot;x&quot;. For example, <code>/a{2}/</code> doesn&#x27;t match the &quot;a&quot; in &quot;candy&quot;, but it matches all of the &quot;a&quot; s in &quot;caandy&quot;,</li></ul><ul id="f45df003-bc40-4fdd-b645-2095e6f9575d" class="bulleted-list"><li style="list-style-type:disc"><code>{</code><code><em>n</em></code><code>,</code><code><code><em>m</em></code></code><code>}</code>: Where &quot;n&quot; is 0 or a positive integer, &quot;m&quot; is a positive integer, and <code><em>m</em></code><code> &gt; </code><code><em>n</em></code>, matches at least &quot;n&quot; and at most &quot;m&quot; occurrences of the preceding item &quot;x&quot;. For example, <code>/a{1,3}/</code> matches nothing in &quot;cndy&quot;, the &quot;a&quot; in &quot;candy&quot;, the two &quot;a&quot;&#x27;s in &quot;caandy&quot;,</li></ul><ul id="60b8cc82-82e1-4965-8fb9-b8de885ed663" class="bulleted-list"><li style="list-style-type:disc"><code>.</code>: this “do” notation will match any digit, letter, or symbol except the newline. For example, <code>.{8}</code> will match an eight-character password consisting of letters, numbers, and symbols.</li></ul><p id="0e07c1ad-cd16-4e4a-9afb-43243ff46231" class="">Let’s go through this example to demonstrate our understanding of quantifiers.</p><ul id="81be6aac-2eba-4d17-b0ce-779f7f1fdc4b" class="toggle"><li><details close=""><summary><strong>Examples</strong></summary><pre id="033ca508-2697-4e40-8cd6-0e705e8beb69" class="code"><code>const str = &#x27;for__if__rof__fi&#x27;
const regex = /[a-z]+/g;
const found = str.match(regex);
console.log(found);
// Expected Output: [ &#x27;for&#x27;, &#x27;if&#x27;, &#x27;rof&#x27;, &#x27;fi&#x27; ]</code></pre><p id="41eefb0b-c79c-4902-890b-a46db7bbdc58" class="">You can see that the regular expression is checking all the lowercase letters from a-z and using the + symbol to match up all the previous items. So when your console log found, it will return [ &#x27;for&#x27;, &#x27;if&#x27;, &#x27;rof&#x27;, &#x27;fi&#x27; ].</p><p id="55c890ec-35bc-498a-a1d0-ba8e2cffd437" class="">Let’s say that + symbol was not there and the Regex was only:</p><pre id="8b4044e3-ee02-4203-b08d-042a89ae7bb2" class="code"><code>const regex = /[a-z]/g;</code></pre><p id="a4b9f2f6-48a0-42ee-b3f9-49385bc215e3" class="">Then it will return [ &#x27;f&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;i&#x27;, &#x27;f&#x27;, &#x27;r&#x27;, &#x27;o&#x27;, &#x27;f&#x27;, &#x27;f&#x27;, &#x27;i&#x27; ].</p><p id="4eb609a4-80e6-44df-8979-381b2fae9162" class="">PUTTING IT ALL TOGETHER</p><p id="805f7266-cbf3-4842-a73f-b9b8c3f35590" class="">Remember this long string of characters we saw at the beginning of this article? </p><p id="bed654ee-d55c-4e11-aa29-2d6ac49fe70d" class=""><code>/^\w+([\.-]?\w)+@\w+([\.]?\w)+(\.[a-zA-Z]{2,3})+$/</code></p><p id="74587c3f-6382-4f22-9011-7465b5c64abe" class="">This is actually a very common use case where the regular expression is applied for email address formatting. Now that we have learned the basic methods and terminologies used in Regex, let’s break down this once daunting but now understandable string of characters one step at a time.</p><pre id="937c2f12-ffed-454f-a1d9-ef3354e077db" class="code"><code>const email = &#x27;student-id@alumni.school.edu&#x27;
const regex = /^\w+([\.-]?\w)+@\w+([\.]?\w)+(\.[a-zA-Z]{2,3})+$/
const found = regex.test(email);
console.log(found);
// Expected Output: true</code></pre></details></li></ul><p id="1072a93c-f868-42cb-8a99-510754fe2730" class="">
</p><h2 id="df0d42b6-81dd-472d-8bc1-0b674f807b54" class=""><strong><mark class="highlight-blue">Explore Further</mark></strong></h2><p id="ed84db28-8e75-4407-97c2-99cf1ac15b29" class=""><mark class="highlight-orange"><strong>Uncover and unlock new insights as you dive into the captivating content found in the provided link.</strong></mark></p><p id="a1adf373-4a2e-4d9e-8e11-bd1c6a6ea9ab" class=""><strong>Z-Algorithm:</strong> <a href="https://stackdiary.com/glossary/z-algorithm/">https://stackdiary.com/glossary/z-algorithm/</a></p><p id="fc1e54ac-6b7a-4930-a38a-6630185f792d" class="">
</p><p id="6f42b50c-0831-40d2-917f-0f39f0ce398b" class=""><mark class="highlight-orange"><strong>Tackle these questions head-on!</strong></mark></p><ol type="1" id="47d1bc60-700e-4c56-9a4f-4fa5fb87df72" class="numbered-list" start="1"><li>The Z Algorithm is a linear time algorithm for pattern matching in strings. <strong>(Agree/Disagree)</strong></li></ol><ol type="1" id="9f049073-9217-4595-ab90-7465b015f95e" class="numbered-list" start="2"><li>The Z Algorithm can be used to find the longest repeated substring in a given string. <strong>(Agree/Disagree)</strong></li></ol><ol type="1" id="f0c19297-e785-4edf-affb-d10f2ee3b3d5" class="numbered-list" start="3"><li>The Z Algorithm constructs a Z-array to store the length of the longest substring matching the pattern at each position in the text. <strong>(Agree/Disagree)</strong></li></ol><ol type="1" id="bde73f95-338c-404c-8365-f629e2b1d45c" class="numbered-list" start="4"><li>The Z Algorithm is primarily used for approximate string matching rather than exact pattern matching. <strong>(Agree/Disagree)</strong></li></ol><ol type="1" id="850b9aea-aa7a-4ae8-a589-87c64a137913" class="numbered-list" start="5"><li>The Z Algorithm has a time complexity of O(n + m), where n is the length of the text and m is the length of the pattern. <strong>(Agree/Disagree)</strong></li></ol><ul id="f08d4a42-4bba-4839-92df-d9b07da616fb" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><ol type="1" id="b84893b0-a97e-4fd7-a2bc-5c23cde636bc" class="numbered-list" start="1"><li>Agree</li></ol><ol type="1" id="486f0938-8cbb-4d99-b764-c19dd60ffa6a" class="numbered-list" start="2"><li>Agree</li></ol><ol type="1" id="49f3c183-ea06-470c-b8ec-cfaad5b493df" class="numbered-list" start="3"><li>Agree</li></ol><ol type="1" id="6abbe9f4-5ca0-4980-9f34-80d73801882c" class="numbered-list" start="4"><li>Disagree</li></ol><ol type="1" id="71bb256a-3df9-47b5-ab52-fbff76ff19f3" class="numbered-list" start="5"><li>Agree</li></ol></details></li></ul><p id="063ae01d-28a5-4f19-8f2e-f8782eca0371" class="">
</p><h2 id="3712c6db-b757-4f0a-ac68-53a6f4df8dab" class=""><mark class="highlight-red">Regex Functions</mark></h2><p id="b5cd2fa5-015a-4afb-a75d-48232319749a" class="">In Java Script Regular expressions are used with the <code>RegExp</code> methods <code>test()</code> and <code>exec()</code> and with the <code>String</code> methods <code>match()</code>, <code>replace()</code>, <code>search()</code>, and <code>split()</code>.</p><div id="ab86ba12-d508-475e-a8fb-f72088c147ed" class="column-list"><div id="6f74c9e9-92d1-493f-afff-1049b6a857f2" style="width:25%" class="column"><p id="078e68b6-39b4-489c-80b6-1b2c661f8ec8" class="">
</p></div><div id="6b88f623-521b-4288-881a-3208284888ad" style="width:100%" class="column"><table id="bea49344-2eec-4d70-8e70-4c1a8aef8711" class="simple-table"><thead class="simple-table-header"><tr id="3fd965b9-0583-4430-896d-bf4c786250fd"><th id="&gt;RHv" class="simple-table-header-color simple-table-header" style="width:265.5px"><strong>Method</strong></th><th id="pswD" class="simple-table-header-color simple-table-header" style="width:513.5px"><strong>Description</strong></th></tr></thead><tbody><tr id="6d99fc73-21d3-4d39-9f97-0f5c3c00eeee"><td id="&gt;RHv" class="" style="width:265.5px"><code>exec()</code></td><td id="pswD" class="" style="width:513.5px">Performs a string search for a match. On a mismatch, it returns an array of information or null.</td></tr><tr id="b9b1ee9a-d441-43b2-b26d-e7c66a8ae82a"><td id="&gt;RHv" class="" style="width:265.5px"><code>test()</code></td><td id="pswD" class="" style="width:513.5px">Tests for a match in a string. It returns <code>true</code> or <code>false</code>.</td></tr><tr id="ba65cf30-9f1b-4e65-8d3c-96e8bba95f97"><td id="&gt;RHv" class="" style="width:265.5px"><code>match()</code></td><td id="pswD" class="" style="width:513.5px">Returns an array of all matches, including capturing groups, or null if no matches are found.</td></tr><tr id="fe6d5144-7c6c-4e69-98fa-9bcb69fc0775"><td id="&gt;RHv" class="" style="width:265.5px"><code>matchAll()</code></td><td id="pswD" class="" style="width:513.5px">Returns an iterator containing all of the matches, including capturing groups.</td></tr><tr id="2aa02ad8-80e7-4878-af73-934adb0422ee"><td id="&gt;RHv" class="" style="width:265.5px"><code>search()</code></td><td id="pswD" class="" style="width:513.5px">Tests for a match in a string. It returns the index of the match, or <code>-1</code> if the search fails.</td></tr><tr id="e68d561f-ef71-46f7-b599-5089848881ba"><td id="&gt;RHv" class="" style="width:265.5px"><code>replace()</code></td><td id="pswD" class="" style="width:513.5px">Executes a search for a match in a string, and replaces the matched substring with a replacement substring.</td></tr><tr id="030b51d4-f7ee-4efc-b99e-e62df7231e18"><td id="&gt;RHv" class="" style="width:265.5px"><code>replaceAll()</code></td><td id="pswD" class="" style="width:513.5px">Executes a search for all matches in a string, and replaces the matched substrings with a replacement substring.</td></tr><tr id="9d159161-ab3f-4128-8bf8-db44f9e58d77"><td id="&gt;RHv" class="" style="width:265.5px"><code>split()</code></td><td id="pswD" class="" style="width:513.5px">To split a string into an array of substrings, use a regular expression or a fixed string.</td></tr></tbody></table></div></div><h2 id="a3dcdfe5-e38d-4e41-86c4-3b9ed57beb57" class="block-color-default"><mark class="highlight-red">Real-Life Applications  of Pattern Matching</mark></h2><ul id="abad33a3-a3fa-40ca-a732-380959f6e9df" class="bulleted-list"><li style="list-style-type:disc"><strong>Text editors and word processors:</strong> String matching algorithms help in finding specific words, phrases, or patterns in text, making tasks like replacing words and formatting easier.</li></ul><ul id="fde08c4e-0375-413f-bd25-b7a8104c655c" class="bulleted-list"><li style="list-style-type:disc"><strong>Search engines:</strong> String matching algorithms enable search engines to find relevant web pages based on user queries, considering factors like word frequency, context, and synonyms to generate accurate results.</li></ul><ul id="59af13e7-23c4-4778-b0f2-5ef6604a9dcc" class="bulleted-list"><li style="list-style-type:disc"><strong>Virus detection:</strong> String matching algorithms search for virus signatures in files or memory by comparing known patterns, helping antivirus software detect and handle infected files.</li></ul><ul id="47fc5ca9-9852-404d-835f-44f959c814a7" class="bulleted-list"><li style="list-style-type:disc"><strong>Genetics:</strong> String matching algorithms compare DNA or RNA sequences, aiding in identifying genetic mutations and establishing evolutionary relationships between organisms.</li></ul><ul id="88170c27-70fe-4279-96b4-db2a21aa0586" class="bulleted-list"><li style="list-style-type:disc"><strong>Plagiarism detection:</strong> String matching algorithms check for similarities between texts, assisting in identifying instances of plagiarism and maintaining academic integrity.</li></ul><ul id="95f0fd37-9ff0-4d23-8648-c9d537b26141" class="bulleted-list"><li style="list-style-type:disc"><strong>Natural language processing:</strong> String matching algorithms analyze text for tasks like named entity recognition, part-of-speech tagging, and sentiment analysis, extracting relevant information and classifying text efficiently.</li></ul><h2 id="f5647574-89a4-4922-86a6-4ce28e822135" class="block-color-default"><mark class="highlight-blue">Activity 2</mark></h2><p id="8b98111c-c31c-4e0b-a252-d726984aec58" class=""><strong>True or False:</strong></p><ol type="1" id="d432bc58-4913-4b58-881e-ac17e8e416ff" class="numbered-list" start="1"><li>The Naive pattern-matching algorithm is highly efficient for large inputs with long patterns. </li></ol><ol type="1" id="d960089d-7e41-40eb-89cd-3c71544f8221" class="numbered-list" start="2"><li>Pattern-matching algorithms are commonly used in fields such as finance, healthcare, and cybersecurity to detect fraud, predict disease outbreaks, and prevent security breaches. </li></ol><ol type="1" id="5a78ae35-4084-49f5-b796-0febf6527eb6" class="numbered-list" start="3"><li>The Finite Automata algorithm is particularly efficient for long patterns with small alphabets. </li></ol><ol type="1" id="7157528c-8875-474a-bb1b-1a5353b074ab" class="numbered-list" start="4"><li>The time complexity of the Naive pattern-matching algorithm is O(n). </li></ol><ul id="edf52193-d3c8-4310-9a1e-e7be6a09b19c" class="toggle"><li><details close=""><summary><strong>Solution</strong></summary><ol type="1" id="b02b494f-0fb3-4faa-900e-dd7fe79ab6fb" class="numbered-list" start="1"><li>False</li></ol><ol type="1" id="b8a36f5b-0759-460d-97a0-9a04f781ed8e" class="numbered-list" start="2"><li>True</li></ol><ol type="1" id="81696c63-9724-4353-b858-90ef72becf42" class="numbered-list" start="3"><li>True</li></ol><ol type="1" id="b83208a5-e556-4402-a03a-cd7320c12d09" class="numbered-list" start="4"><li>False</li></ol></details></li></ul><p id="60068b7a-6639-4770-b13b-6aa65d3c1b0e" class="">
</p><h2 id="77a67291-64a7-4d57-b473-ac50024015a4" class=""><mark class="highlight-red">Foundations of Pattern Matching Algorithms</mark></h2><p id="9f74240e-9ab8-4271-b1d3-66aed454946a" class="">In a small village nestled among the mountains, there lived a young shepherd named Jack. Jack spent most of his days tending to his sheep and exploring the nearby woods. One day, while wandering through the forest, Jack stumbled upon an old book lying on the ground. Curious, he picked it up and began to flip through its pages.</p><p id="f793532d-8ea7-4ac3-b538-44670f5b4fd9" class="">As he read, Jack came across a section on pattern matching. Intrigued, he began to experiment with the techniques described in the book, using them to search for patterns in the world around him. He quickly realized that these methods could be used to solve many of the problems he encountered as a shepherd.</p><h3 id="87fb91ac-bf5c-4c1c-b1e5-b1605afbc8ab" class="block-color-default"><strong>String Matching Algorithms</strong></h3><p id="cf64782f-cc5d-4c48-b7dc-cd56d76342fd" class="">String matching operation is a core part of many text processing applications. The objective of this algorithm is to find pattern P from given text T. Typically the length of P&lt;&lt; length of  T. In the design of compilers and text editors, string matching operation is crucial. So locating P in T efficiently is very important.</p><p id="5aa9434b-29fe-40a0-9871-bab03d884ac8" class="">The problem is defined as follows: “Given some text string T[1….n] of size n, find all occurrences of pattern P[1…m] of size m in T.”</p><p id="19036d27-0eb0-45aa-a48a-ec3311733e56" class="">We say that P occurs in text T with a number of shifts s if 0 ≤ s ≤ n – m and T[ (s + 1) … (s + m) ] = P[1…m].</p><p id="4f546086-264c-4b3d-aa09-bd73695054ec" class=""><strong>Consider the following example:</strong></p><figure id="2dac996b-faa2-49d2-b361-730c5d34b180" class="image"><img style="width:2488px" src="Introduction%20to%20Pattern%20Matching%209786b0b7e905402bb93a80307df45e09/Screenshot_2023-05-08_at_1.08.32_PM.png"/></a></figure><ul id="6ff363b9-24e5-4918-b215-cd4acec689ee" class="bulleted-list"><li style="list-style-type:disc">In this example, pattern P = ARE is found in text T after four shifts.</li></ul><ul id="beda0d86-2e1a-4aad-9838-dd5e50f88a3c" class="bulleted-list"><li style="list-style-type:disc">The classical application of such algorithms is to find particular protein patterns in DNA sequences.</li></ul><ul id="b75f3586-176c-40ef-9666-e00dc025c405" class="bulleted-list"><li style="list-style-type:disc">Strings may be encoded using set of character alphabets {a, b, …, z}, binary alphabets {0, 1}, decimal alphabets {0, 1, 2, …, 9}, DNA alphabets {A, C, G, T}. The encoding of the string directly affects the efficiency of searching.</li></ul><ul id="1ee03690-888a-4743-ba44-0fb47d1d3d9b" class="bulleted-list"><li style="list-style-type:disc">In the next sections, we will discuss and analyze a few string-matching algorithms.</li></ul><h3 id="6b14e16b-b36a-497f-856e-4abed831befc" class="block-color-default">Finite Automata</h3><p id="f8589b39-70a8-4476-b19d-2c5cfce6209e" class=""><em><strong>Finite automata</strong></em>, when used in pattern matching, are powerful tools for recognizing and searching for patterns within strings. In JavaScript, you can implement finite automata-based pattern-matching algorithms to find matches in a text efficiently. Let&#x27;s delve into how to implement a finite automaton pattern-matching algorithm in JavaScript.</p><p id="08b48672-67ed-45c4-a3d0-ab6df49661a0" class="">
</p><figure id="95bb638d-6698-4ac5-a343-2fd9da888990" class="image"><img style="width:2464px" src="Introduction%20to%20Pattern%20Matching%209786b0b7e905402bb93a80307df45e09/Screenshot_2023-05-08_at_1.08.55_PM.png"/></a></figure><p id="3ee8e8f3-486b-44de-a6d1-3fee3e064cd8" class="">Suppose we want to search for occurrences of a specific pattern, such as <strong><code>abab</code></strong><strong>,</strong> within a given text. We can build a finite automaton that recognizes this pattern and uses it to perform pattern matching.</p><ul id="67fc6863-4a09-4bd4-b33f-d154266c17eb" class="toggle"><li><details close=""><summary><strong>Algorithm</strong></summary><pre id="ea0f0828-bbd6-4482-bf91-e1bf8333ee1f" class="code"><code>// Algorithm: Finite Automaton Pattern Matching

1. Initialize the PatternMatcher class with the desired pattern.
2. Build the transition table using the buildTransitionTable(pattern) method:
   a. Create an empty transition table, table, of size (pattern.length + 1).
   b. Create a set, alphabet, containing unique characters from the pattern.
   c. Iterate over each state, state, from 0 to pattern.length:
      - Iterate over each character, char, in the alphabet:
        - Initialize nextState as the minimum of (pattern.length + 1, state + 1).
        - While nextState &gt; 0 and char is not equal to pattern[nextState - 1]:
          - Set nextState as table[nextState - 1][pattern[nextState - 1]].nextState.
        - Set table[state][char] as an object with the property nextState set to nextState.
   d. Return the transition table, table.
3. Perform pattern matching using the match(text) method:
   a. Initialize currentState as 0.
   b. Create an empty array, matches, to store the indices of pattern matches.
   c. Iterate over each character, char, in the text:
      - If the transition table has an entry for currentState and char:
        - Update currentState as the nextState from the transition table entry.
        - If currentState equals pattern.length:
          - Calculate matchStartIndex as (current index - pattern.length + 1).
          - Add matchStartIndex to the matches array.
      - Else, reset currentState to 0.
   d. Return the matches array.</code></pre></details></li></ul><ul id="d579d1c2-ece7-4613-8b6f-b56075ff9a75" class="toggle"><li><details close=""><summary><strong>Code Implementation</strong></summary><pre id="3b641c0a-c86b-42f2-a481-bbfd4e1eb9a9" class="code"><code>class PatternMatcher {
  constructor(pattern) {
    this.pattern = pattern;
    this.transitionTable = this.buildTransitionTable(pattern);
  }

  buildTransitionTable(pattern) {
    const table = Array(pattern.length + 1).fill({});
    const alphabet = new Set(pattern);

    for (let state = 0; state &lt;= pattern.length; state++) {
      for (const char of alphabet) {
        const nextState = Math.min(pattern.length + 1, state + 1);

        while (
          nextState &gt; 0 &amp;&amp;
          char !== pattern[nextState - 1]
        ) {
          nextState = table[nextState - 1][pattern[nextState - 1]].nextState;
        }

        table[state][char] = { nextState };
      }
    }

    return table;
  }

  match(text) {
    let currentState = 0;
    const matches = [];

    for (let i = 0; i &lt; text.length; i++) {
      const char = text[i];

      if (this.transitionTable[currentState][char]) {
        currentState = this.transitionTable[currentState][char].nextState;

        if (currentState === this.pattern.length) {
          const matchStartIndex = i - this.pattern.length + 1;
          matches.push(matchStartIndex);
        }
      } else {
        currentState = 0;
      }
    }

    return matches;
  }
}

// Usage
const text = &quot;ababababcdababc&quot;;
const pattern = &quot;abab&quot;;

const matcher = new PatternMatcher(pattern);
const matches = matcher.match(text);

console.log(matches); // [0, 2, 4, 11]</code></pre></details></li></ul><h3 id="32571468-45d2-4517-a3eb-365fe0ee144b" class="block-color-default">Index-based string matching</h3><p id="dae386a1-bb37-4e2b-8cac-9d1f0a4a7d73" class="">Index-based string matching is a technique used to efficiently search for occurrences of a pattern within a larger text by utilizing pre-processing tables or indexes. The goal is to avoid unnecessary character comparisons and shift the pattern intelligently, reducing the overall number of comparisons required.</p><p id="3491dd8e-4a99-4943-ba67-bee830995a4e" class="">The basic idea behind index-based string matching is to compare characters between the pattern and the text from right to left, starting from the end of the pattern. By doing so, we can leverage pre-processing tables or indexes to determine the maximum shift allowed when a mismatch occurs.</p><p id="5bc1b3da-de1a-44ee-822c-6c93014d9bb9" class="">There are two main pre-processing tables commonly used in index-based string-matching algorithms:</p><ol type="1" id="92063dbe-bc29-4e8b-93b7-cae551a9120b" class="numbered-list" start="1"><li><strong>Bad Character Table (BCT):</strong> The BCT maps each character in the pattern to its rightmost occurrence index in the pattern. When a mismatch occurs, this table is consulted to determine the maximum shift allowed based on the mismatched character. By using the rightmost occurrence of the character, we shift the pattern to align it with the mismatched character in the text.</li></ol><ol type="1" id="c4021943-da01-45b4-8760-40d7bbf98d6b" class="numbered-list" start="2"><li><strong>Good Suffix Table (GST) or Suffix Table:</strong> The GST helps determine the maximum shift allowed when a mismatch occurs by considering the suffixes of the pattern. It identifies the longest suffixes that match the pattern&#x27;s suffix and stores the corresponding shift values. When a mismatch occurs, the GST is consulted to determine the maximum shift allowed based on the matching suffix. This enables shifting the pattern to align with a potential match in the text.</li></ol><p id="ca0c5358-5e12-4791-b140-fe75d641b0cb" class="">
</p><figure id="71f6d7d9-eec6-4c1e-83b9-540ebc788e8f" class="image"><img style="width:2380px" src="Introduction%20to%20Pattern%20Matching%209786b0b7e905402bb93a80307df45e09/Screenshot_2023-05-08_at_1.09.51_PM.png"/></a></figure><p id="0af9acb0-18e5-458b-8b4e-7b1def8e3663" class="">The process of index-based string matching typically involves the following steps:</p><ol type="1" id="b294806f-58b7-4406-83b8-d884c5236de3" class="numbered-list" start="1"><li><strong>Pre-processing: </strong>Generate the necessary tables or indexes (e.g., BCT, GST) based on the pattern.</li></ol><ol type="1" id="bc70ff5c-b548-404b-8a92-ac072ca1d545" class="numbered-list" start="2"><li><strong>Matching</strong>: Iterate through the text, comparing characters from right to left with the pattern.</li></ol><ol type="1" id="275da3f1-6a95-4487-8bf5-ca2bd1a37c8e" class="numbered-list" start="3"><li><strong>Mismatch</strong> <strong>Handling</strong>: When a mismatch occurs, consult the pre-processing tables to determine the maximum shift allowed.</li></ol><ol type="1" id="d55de74a-6df0-48d4-bc36-d9391d6ff347" class="numbered-list" start="4"><li><strong>Shifting</strong>: Move the pattern by the calculated shift value and continue the comparison process.</li></ol><ol type="1" id="73e589a9-6e44-49af-afff-2991fc1196d1" class="numbered-list" start="5"><li><strong>Repeat</strong>: Continue the matching process until either a complete match is found or all positions in the text are exhausted.</li></ol><p id="ddb5eafc-94c1-42f7-b390-2d701e3f2594" class="">By utilizing the pre-processing tables or indexes, index-based string matching algorithms can achieve significant improvements in performance compared to naive approaches that involve comparing characters sequentially without any pre-processing.</p><p id="f94b5fab-7015-4ff8-898a-c71db044de4c" class="">One well-known example of an index-based string-matching algorithm is the Boyer-Moore algorithm, which uses both the Bad Character Table (BCT) and the Good Suffix Table (GST) to search for a pattern in a text efficiently.</p><p id="25c2bcb3-2076-42fc-919c-cfe788e50b4d" class=""><strong>Example:</strong></p><p id="c3ddc6d9-19b8-4974-902e-a18e6f366666" class="">Let&#x27;s consider the following pattern and text:</p><pre id="6ace64c9-e617-4691-9201-87f1d6457c15" class="code"><code>Pattern: &quot;ABABCABAB&quot;
Text: &quot;ABABDABACDABABCABAB&quot;</code></pre><ul id="4313d305-7cde-493a-ab80-408cebb85b59" class="toggle"><li><details close=""><summary><strong>Code Implementation</strong></summary><pre id="c268303d-5596-48d7-bf0a-7798efaffbb5" class="code"><code>	function indexBasedStringMatching(pattern, text) {
  const patternLength = pattern.length;
  const textLength = text.length;
  const indexes = [];

  // Pre-process the pattern to create a bad character table
  const badCharacterTable = createBadCharacterTable(pattern);

  let i = 0;
  while (i &lt;= textLength - patternLength) {
    let j = patternLength - 1;

    // Compare characters from right to left
    while (j &gt;= 0 &amp;&amp; pattern[j] === text[i + j]) {
      j--;
    }

    if (j &lt; 0) {
      // Match found, add the index to the results
      indexes.push(i);
      i += 1; // Shift pattern by 1 position
    } else {
      // Mismatch occurred
      const badCharacterShift = badCharacterTable[text[i + j]] || -1;
      const suffixShift = calculateSuffixShift(j, pattern);
      i += Math.max(badCharacterShift, suffixShift);
    }
  }

  return indexes;
}

// Function to create the bad character table
function createBadCharacterTable(pattern) {
  const table = {};
  const length = pattern.length;

  for (let i = 0; i &lt; length - 1; i++) {
    table[pattern[i]] = length - 1 - i;
  }

  return table;
}

// Function to calculate the suffix shift
function calculateSuffixShift(mismatchIndex, pattern) {
  const length = pattern.length;
  let shift = 0;

  // Check if a suffix of the pattern matches the substring
  for (let i = 1; i &lt;= mismatchIndex; i++) {
    const suffix = pattern.substring(0, mismatchIndex - i + 1);
    const prefix = pattern.substring(length - i);
    if (suffix === prefix) {
      shift = i;
    }
  }

  return shift;
}

// Usage example
const pattern = &quot;ABABCABAB&quot;;
const text = &quot;ABABDABACDABABCABAB&quot;;
const indexes = indexBasedStringMatching(pattern, text);
console.log(&quot;Pattern occurs at indexes:&quot;, indexes);</code></pre><p id="e555c47a-1886-416c-af8f-90befadfcb66" class=""><strong>Explanation</strong>:</p><p id="6b0c8072-e5fb-47d0-9786-66ff8db646d9" class="">The <code><strong>indexBasedStringMatching</strong></code> function implements the Boyer-Moore algorithm, which is an index-based string matching algorithm. Here&#x27;s a breakdown of the code:</p><ol type="1" id="fd1c264a-2c5d-4c47-a983-8d278fa2ac59" class="numbered-list" start="1"><li>The <code><strong>createBadCharacterTable</strong></code> function creates a bad character table, which maps each character in the pattern to its rightmost occurrence index.</li></ol><ol type="1" id="d049934c-30b5-4652-9b40-bd39bcd2c479" class="numbered-list" start="2"><li>The <code><strong>calculateSuffixShift</strong></code> function calculates the maximum shift allowed based on the suffixes of the pattern that match the pattern&#x27;s suffix.</li></ol><ol type="1" id="e80b6dfb-37e1-4491-94d4-450f7d71bfe5" class="numbered-list" start="3"><li>In the <code><strong>indexBasedStringMatching</strong></code> function, we iterate over the text using the outer loop, starting from position 0.</li></ol><ol type="1" id="e4e43e4c-1b2d-4e00-a521-ea98f41f45a1" class="numbered-list" start="4"><li>The inner loop compares characters from right to left, starting from the end of the pattern. If a mismatch occurs, we calculate the maximum shift allowed using the bad character table and suffix shift.</li></ol><ol type="1" id="343778b6-2119-40fc-bb75-39f77e3d9ab3" class="numbered-list" start="5"><li>If a complete match is found (i.e., <code><strong>j</strong></code> becomes -1), we add the current index <code><strong>i</strong></code> to the results and shift the pattern by 1 position.</li></ol><ol type="1" id="edd231d3-0cd7-4594-95ef-3157273d6d10" class="numbered-list" start="6"><li>Finally, the function returns an array of indexes where the pattern occurs in the text.</li></ol><p id="0fdf6207-1c57-4e59-b277-40f4ab00afdd" class="">Using this index-based approach, the Boyer-Moore algorithm reduces the number of character comparisons and shifts the pattern intelligently, resulting in efficient string matching.</p></details></li></ul><h3 id="8d23871d-0a4f-4280-aec3-800b0724334e" class="block-color-default">Burrows-Wheeler transform</h3><p id="90b6d454-1465-4727-8e34-9c5898c7ab42" class="">The Burrows-Wheeler Transform (BWT) is a text compression algorithm that rearranges the characters in a string to make it more compressible. It is commonly used in pattern-matching algorithms, such as the BWT-Matching algorithm. Here&#x27;s an explanation of how it works and some examples in JavaScript:</p><p id="209546ea-149f-4438-b305-bef9ba171e76" class=""><strong>BWT Algorithm:</strong></p><ul id="393a1582-73fc-4474-9c9d-12fb51ba496a" class="bulleted-list"><li style="list-style-type:disc">Given a string, we create a table of all cyclic rotations of the string, sorted lexicographically.</li></ul><ul id="e98ad515-c3e0-437a-8e44-3a519d5f7443" class="bulleted-list"><li style="list-style-type:disc">The last column of the table contains the transformed string, which is the BWT of the original string.</li></ul><p id="cb2e3d2b-bef6-4fc4-bd01-b1ae458e084c" class=""><strong>Example</strong>: Transforming &quot;banana&quot;</p><ul id="6791e441-6b60-43cf-8ad7-d95503e6001e" class="bulleted-list"><li style="list-style-type:disc">Cyclic rotations: &quot;banana&quot;, &quot;ananaB&quot;, &quot;nanaBa&quot;, &quot;anaBan&quot;, &quot;naBana&quot;, &quot;aBanan&quot;.</li></ul><ul id="c2df8b79-38a4-43bd-abe2-7b1678e4ae42" class="bulleted-list"><li style="list-style-type:disc">Sorted rotations: &quot;aBanan&quot;, &quot;anaBan&quot;, &quot;ananaB&quot;, &quot;banana&quot;, &quot;naBana&quot;, &quot;nanaBa&quot;.</li></ul><ul id="ba9968d9-d372-4a73-93b0-aedb1be8e15c" class="bulleted-list"><li style="list-style-type:disc">BWT: &quot;annBaa&quot;.</li></ul><ul id="51fcbf5e-4722-4b96-8603-bc7aaa49810b" class="toggle"><li><details close=""><summary><strong>Code Implementation</strong></summary><pre id="c4e3b917-a1dc-4522-a585-91520fbe5bc8" class="code"><code>function burrowsWheelerTransform(text) {
  let rotations = [];
  for (let i = 0; i &lt; text.length; i++) {
    rotations.push(text.slice(i) + text.slice(0, i));
  }
  rotations.sort();
  let bwt = rotations.map((rotation) =&gt; rotation.slice(-1)).join(&quot;&quot;);
  return bwt;
}

let originalString = &quot;hello world&quot;;
let transformedString = burrowsWheelerTransform(originalString);
console.log(transformedString);
// Output: &quot;dlroheollw  &quot;</code></pre><p id="de2bbf0f-9046-4cea-9b40-055f1b94a395" class=""><strong>Explanation</strong>:</p><ol type="1" id="15251dc1-8720-4ffc-b9b9-4e3bf521394f" class="numbered-list" start="1"><li>The <code><strong>burrowsWheelerTransform</strong></code> function takes a string <code><strong>text</strong></code> as input and performs the BWT on it.</li></ol><ol type="1" id="57e66e2e-7875-4e29-89fd-d3cec9deb07c" class="numbered-list" start="2"><li>It initializes an empty array <code><strong>rotations</strong></code> to store all the cyclic rotations of the input string.</li></ol><ol type="1" id="4f7a8d5a-7eda-40c0-b170-f3c941fcc62e" class="numbered-list" start="3"><li>The <code><strong>for</strong></code> loop iterates over the characters of the input string. For each iteration, it slices the input string from the current index to the end (<code><strong>text.slice(i)</strong></code>) and appends the sliced portion with the part of the input string from the beginning to the current index (<code><strong>text.slice(0, i)</strong></code>). This creates all the cyclic rotations of the input string, which are then pushed into the <code><strong>rotations</strong></code> array.</li></ol><ol type="1" id="a6556545-c56c-4ea0-9bb0-c78e0c590224" class="numbered-list" start="4"><li>After obtaining all the cyclic rotations, the <code><strong>rotations</strong></code> array is sorted lexicographically using the <code><strong>sort</strong></code> method. This step is crucial as it aligns similar characters, making the transformed string more compressible.</li></ol><ol type="1" id="5b9e3f90-5d40-4d7a-b356-d4048323b834" class="numbered-list" start="5"><li>The next step is to extract the last character from each sorted rotation. This is accomplished using the <code><strong>map</strong></code> method on the <code><strong>rotations</strong></code> array, where each rotation is sliced to retrieve the last character (<code><strong>rotation.slice(-1)</strong></code>). The resulting array of last characters is then joined together using the <code><strong>join</strong></code> method, forming the Burrows-Wheeler transformed string, which is stored in the <code><strong>bwt</strong></code> variable.</li></ol><ol type="1" id="409cfbee-c855-4ef7-8fa8-0580886a3ea8" class="numbered-list" start="6"><li>Finally, the transformed string (<code><strong>bwt</strong></code>) is returned as the output of the <code><strong>burrowsWheelerTransform</strong></code> function.</li></ol><ol type="1" id="60fd57ad-3879-4b6a-b165-ae6b19d180be" class="numbered-list" start="7"><li>In the provided example, the <code><strong>originalString</strong></code> is set to &quot;hello world&quot;. The <code><strong>burrowsWheelerTransform</strong></code> function is called with <code><strong>originalString</strong></code> as the input, and the transformed string is stored in the <code><strong>transformedString</strong></code> variable.</li></ol><ol type="1" id="bf4a8a70-f6b9-41bd-8b63-1519f924ebea" class="numbered-list" start="8"><li>The transformed string is then printed to the console using <code><strong>console.log</strong></code>. In this case, the output will be &quot;dlroheollw &quot;.</li></ol></details></li></ul><p id="0b451138-af0f-456f-adf1-7d2f41895f54" class=""><strong>Real-World Implementation</strong></p><p id="d3766094-6248-42c5-b3c3-38d4081f35e5" class="">Burrows-Wheeler transform has so many applications, which include:</p><ul id="ac2f2bee-1bb8-4403-925b-d3328bd9142e" class="bulleted-list"><li style="list-style-type:disc">In DNA sequencing, the BWT can identify repeated regions in a sequence and the relative frequencies of nucleotides, which can be used to detect genetic variations and compare sequences between organisms.</li></ul><ul id="d78ffe74-cf22-4174-a498-727805768b41" class="bulleted-list"><li style="list-style-type:disc">In file compression, the BWT can be combined with other compression techniques to reduce the size of files without losing any information, making it useful for reducing storage and bandwidth requirements.</li></ul><ul id="a6b13212-a54e-4b53-af93-ac7bee7c7c08" class="bulleted-list"><li style="list-style-type:disc">In text processing and search engines, the BWT can compress and index text documents, allowing for fast search and retrieval of specific words or phrases.</li></ul><ul id="353301f6-45d8-4a01-ad79-8839e9878037" class="bulleted-list"><li style="list-style-type:disc">In machine learning and data analysis, the BWT can preprocess data and reduce its dimensionality, which can improve the accuracy and efficiency of machine learning algorithms, particularly for tasks such as text classification and sentiment analysis.</li></ul><p id="9445a609-d173-43e6-ab17-657bd227dc4c" class="">
</p><h2 id="c52219fb-2f0f-4f78-9b86-afba1e9ca101" class="block-color-default"><mark class="highlight-blue">Activity 3</mark></h2><p id="04fb5337-a1bc-402f-b578-e9c216193f49" class=""><strong>True or False:</strong></p><ol type="1" id="e2b9ed19-273e-4d72-b6c5-8cd0fdaa90ff" class="numbered-list" start="1"><li>A finite automaton is a mathematical model that recognizes patterns within pictures.</li></ol><ol type="1" id="f241d670-1109-456a-93d6-59037b4aba8f" class="numbered-list" start="2"><li>A finite automaton consists of a set of states, a set of input symbols, a transition function, a start state, and one or more accepting states.</li></ol><p id="847f260e-fead-48e4-ada9-d47d93654f90" class="">
</p><p id="f9f22d88-7fbc-4307-a37d-59c2ed59c8dc" class=""><strong>Fill in the blanks:</strong></p><ol type="1" id="fe9ff0bc-e390-4028-9ad1-65f56ed9186a" class="numbered-list" start="1"><li>The Burrows-Wheeler transform is a reversible transformation, which means that the original string can be reconstructed from the transformed string using an inverse transform called the __________<strong> (Huffman/Lempel-Ziv/Inverse Burrows-Wheeler)</strong> transform.</li></ol><ol type="1" id="1bebc5de-9243-4a5f-9501-44c55ef0df75" class="numbered-list" start="3"><li>The Burrows-Wheeler transform is often used as a preprocessing step for data compression algorithms such as __________<strong>(Run-length/Arithmetic/Burrows-Wheeler-Rice)</strong> coding, which exploit the similarity between adjacent characters in the transformed string to achieve high compression ratios.</li></ol><ul id="1c2ac6d4-c056-4e22-9a13-2a0e2b0b21ee" class="toggle"><li><details close=""><summary><strong>Solution</strong></summary><p id="f4bd7ab9-b046-4320-9ec7-e1be01bfe509" class="">True or False:</p><ol type="1" id="c6b773d2-77e3-4ea6-ad70-3f9c5d72fff0" class="numbered-list" start="1"><li>False</li></ol><ol type="1" id="956d9630-b3eb-4ad7-bc8d-c21ffb94aece" class="numbered-list" start="2"><li>True</li></ol><p id="43e71ea7-16a1-4114-a019-a12b3c3b925c" class=""><strong>Fill in the blanks:</strong></p><ol type="1" id="cc7dffbb-8cf9-47dc-8079-e2d9d0d81b2b" class="numbered-list" start="1"><li>Inverse Burrows-Wheeler</li></ol><ol type="1" id="711431d6-656c-4250-8530-6674714e222d" class="numbered-list" start="2"><li>Arithmetic</li></ol></details></li></ul><p id="6e0a01f6-7a7a-40b8-abbb-a05ce958172a" class="">
</p><h1 id="4d935cfa-a654-46e1-b715-cce10ee502ea" class=""><mark class="highlight-brown">Summary</mark></h1><h2 id="2d7acd98-8447-411d-abad-e38facb22f82" class="block-color-default"><mark class="highlight-red">What did we learn?</mark></h2><ul id="85a6b6b7-3021-4889-850e-39fff8805ff9" class="bulleted-list"><li style="list-style-type:disc">Pattern matching is a process of searching for specific sequences or placement of characters in a given set of data. It produces definitive results by determining whether the input string contains the pattern or not.</li></ul><ul id="ec25514d-390c-48fd-b57e-6d0f7a59539c" class="bulleted-list"><li style="list-style-type:disc">Pattern matching algorithms often utilize regular expressions (regex) to define patterns and identify them in the data. Regular expressions provide a language for specifying patterns and can handle complex structures beyond simple strings.</li></ul><ul id="127cc3cf-0442-4aa9-9ec9-1f7a859dc199" class="bulleted-list"><li style="list-style-type:disc">Regex basics include understanding the use of character sets, ranges, character classes, groups, assertions, alternate characters, and bracket expressions to define patterns.</li></ul><ul id="455e51fd-835d-4606-ae07-4920539e689e" class="bulleted-list"><li style="list-style-type:disc">Pattern matching has various use cases, including validating form submissions, performing search and replace operations, cleaning and standardizing datasets, parsing and extracting values, and pattern recognition in machine learning and artificial intelligence applications.</li></ul><ul id="aa74895b-62c0-4413-897e-c9b861ac3c75" class="bulleted-list"><li style="list-style-type:disc">Finite automata can be implemented for pattern matching and pattern recognition in strings.</li></ul><ul id="ee7000a4-8b44-4037-9792-60e85355fae7" class="bulleted-list"><li style="list-style-type:disc">Index-based string matching involves pre-processing, matching, mismatch handling, shifting, and repetition.</li></ul><ul id="38429198-f1d8-42db-a5e4-bce5c7d3cc75" class="bulleted-list"><li style="list-style-type:disc">A Bad Character Table (BCT) maps each character in the pattern to its rightmost occurrence index. A good Suffix Table (GST) helps determine the maximum shift allowed based on matching suffixes.</li></ul><ul id="30545ebd-b4cf-40f6-a720-c92c39c406fb" class="bulleted-list"><li style="list-style-type:disc">The Burrows-Wheeler Transform (BWT) rearranges characters in a string for compression and pattern matching.</li></ul><ul id="31e25d6d-867e-4b7a-940f-4dcccf282883" class="bulleted-list"><li style="list-style-type:disc">BWT-Matching algorithm uses BWT for pattern matching by creating cyclic rotations and sorting them.</li></ul><h2 id="03e12c91-95de-402e-95a4-373278acc1d0" class="block-color-default"><mark class="highlight-red">Shortcomings &amp; Challenges</mark></h2><ul id="145e8260-9054-4d96-b6b0-32539eaf91cd" class="bulleted-list"><li style="list-style-type:disc">Pattern matching can be a complex and challenging topic to learn, requiring a solid understanding of programming concepts, mathematics, and logic.</li></ul><ul id="6726f917-1109-4d16-8ec5-2696750ef57e" class="bulleted-list"><li style="list-style-type:disc">Different pattern-matching techniques and algorithms have different strengths and weaknesses, and choosing the right one for a given task can be tricky.</li></ul><ul id="b6a43b87-a868-45b3-86ba-ff168378f79f" class="bulleted-list"><li style="list-style-type:disc">Pattern matching can be computationally intensive, especially when dealing with large datasets or complex patterns.</li></ul><ul id="f0100aa3-d6f5-43d1-ab21-ead23b34e6e9" class="bulleted-list"><li style="list-style-type:disc">Over-reliance on pattern matching can lead to a lack of critical thinking and creativity when working with data, as it may limit the exploration of other possibilities.</li></ul><h2 id="69f3109c-fed4-48d2-9395-9b38038fffa8" class="block-color-default"><mark class="highlight-red">Best Practices</mark></h2><ul id="837ce0ad-fd1a-41e9-a855-39739b860971" class="bulleted-list"><li style="list-style-type:disc"><strong>Start with the basics: </strong>Before diving into complex pattern-matching techniques, ensure you have a solid understanding of the underlying programming concepts and the basics of pattern matching.</li></ul><ul id="a6763b2d-5215-44c7-a40d-22b842b69b6f" class="bulleted-list"><li style="list-style-type:disc"><strong>Choose the right tool for the job:</strong> Different pattern-matching algorithms and techniques are suitable for different tasks, so be sure to choose the right tool for the job.</li></ul><ul id="ed6068a9-acd4-4a9a-9c31-5eb7a56bac58" class="bulleted-list"><li style="list-style-type:disc"><strong>Break down complex patterns:</strong> If you&#x27;re dealing with a complex pattern, break it down into smaller, more manageable pieces to make it easier to work with.</li></ul><ul id="fd125f51-073b-4413-9381-c208fdb01d70" class="bulleted-list"><li style="list-style-type:disc"><strong>Test your code thoroughly:</strong> Be sure to test your pattern-matching code thoroughly to ensure that it&#x27;s working correctly and that it&#x27;s not introducing any unintended side effects.</li></ul><h2 id="75b3e720-c4b0-4416-bd14-cb9eda52fd93" class="block-color-default">Enhance Your Knowledge</h2><ul id="29d6649f-334b-4123-a0a0-d728a31568ec" class="bulleted-list"><li style="list-style-type:disc"><a href="https://dataladder.com/guide-to-pattern-matching-what-it-means-and-how-to-do-it/">Guide to pattern matching</a></li></ul><ul id="d077b6a0-efca-47f1-8754-36f975d9bd71" class="bulleted-list"><li style="list-style-type:disc"><a href="https://github.com/foo123/PatternMatchingAlgorithms">Github for Pattern Matching</a></li></ul><p id="1571382f-7ac5-4ed3-8e19-e92f8c369698" class="">
</p></div></article></body></html>
