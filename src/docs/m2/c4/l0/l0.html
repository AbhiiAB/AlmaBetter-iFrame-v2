<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Module Recap</title>
<link rel="stylesheet" href="../../../../../styles.css">
</head><body><article id="58ac4be7-bcbd-4062-bc20-03a68a358058" class="page sans"><header><h1 class="page-title">Module Recap</h1><p class="page-description"></p></header><div class="page-body"><ul id="07511204-20aa-4f10-b99b-6d3d92e34f7e" class="toggle"><li><details close=""><summary><strong>Recap Flow</strong></summary><ul id="4fb697ad-9474-4155-bb25-8aab12ac1ee8" class="toggle"><li><details close=""><summary><strong>Chapter 1 - Introduction to DSA</strong></summary><ul id="43418756-e76c-4da5-8475-cdf1e0b8e916" class="bulleted-list"><li style="list-style-type:disc">Algorithmic Analysis</li></ul><ul id="54cf8ef5-9e7b-4195-9b0c-646c9ba57176" class="bulleted-list"><li style="list-style-type:disc">Classification of Data structure</li></ul><ul id="9cd48b82-8929-4287-8186-bdd03d6ee5b7" class="bulleted-list"><li style="list-style-type:disc">Array Methods</li></ul><ul id="ab18e65c-9737-4b34-a41d-b6dc12ffcff1" class="bulleted-list"><li style="list-style-type:disc">String Operations</li></ul><ul id="5d30d11e-adf6-43ff-9418-27ae355abe84" class="bulleted-list"><li style="list-style-type:disc">How does pattern matching work?</li></ul><ul id="3c5def30-ea0a-43a1-829a-cdbda555227b" class="bulleted-list"><li style="list-style-type:disc">Regular Expressions</li></ul><ul id="9bec26a4-c7c2-4355-8050-72e30b156880" class="bulleted-list"><li style="list-style-type:disc">Finding the sum of all numbers in an array along with the time and space complexity</li></ul></details></li></ul><ul id="f922d22d-6b28-45f0-8793-1857de863b10" class="toggle"><li><details close=""><summary><strong>Chapter 2 - Sorting Algorithm &amp; Searching Techniques</strong></summary><ul id="92bccd6a-871d-4aa9-bf04-f3cca6aeeb3f" class="bulleted-list"><li style="list-style-type:disc">Introduction to Selection Sort</li></ul><ul id="9c87afd9-a7c0-4d87-bd95-ad6a96efb00a" class="bulleted-list"><li style="list-style-type:disc">Introduction to Merge Sort</li></ul><ul id="711710b0-8cd3-455b-9a99-fce5f82992d8" class="bulleted-list"><li style="list-style-type:disc">Introduction to Bucket Sort</li></ul><ul id="d70e3534-b2cc-4c22-b0e5-bc7ec625a96d" class="bulleted-list"><li style="list-style-type:disc">Introduction to Counting Sort</li></ul><ul id="8d478596-d60c-41b0-b4a7-ab92606ff2e4" class="bulleted-list"><li style="list-style-type:disc">How does Binary Searching help us?</li></ul><ul id="c2bc613b-c250-45dc-987e-4c923e6b0831" class="bulleted-list"><li style="list-style-type:disc">Introduction to Hashmap</li></ul><ul id="d753d521-2d56-4b2b-ab94-5585965e7428" class="bulleted-list"><li style="list-style-type:disc">Introduction to Ternary Search</li></ul><ul id="295f94b4-082d-4d4c-bb92-ad489e63cfa4" class="bulleted-list"><li style="list-style-type:disc">Introduction to Jump Search</li></ul></details></li></ul><ul id="1f9617bd-fee2-462e-8e45-d8bfb9ed19f6" class="toggle"><li><details close=""><summary><strong>Chapter 3 - Recursion &amp; Back Tracking</strong></summary><ul id="137c81a2-8b79-4b65-8c38-8720ebec6189" class="bulleted-list"><li style="list-style-type:disc">Recursion vs Loop</li></ul><ul id="4cbb430a-9a86-4f2e-9757-67da69b421f1" class="bulleted-list"><li style="list-style-type:disc">How does Recursion works?</li></ul><ul id="f79dcb95-dbd6-4387-9431-17dd326f931f" class="bulleted-list"><li style="list-style-type:disc">Introduction to and working of Backtracking</li></ul><ul id="eb8b0628-42e3-4008-a9b9-9de0dac4e005" class="bulleted-list"><li style="list-style-type:disc">Backtracking Complexity Analysis</li></ul><ul id="bdc84d55-b36b-446a-b1e5-435cf42ea200" class="bulleted-list"><li style="list-style-type:disc">Problem Statement </li></ul></details></li></ul></details></li></ul><p id="9f52f16e-11da-4568-98c8-e7533d8ef364" class="">
</p><h2 id="bff95bb0-c795-422a-aab7-5b5e2398cf10" class=""><mark class="highlight-red">Classification of Data structure</mark></h2><p id="78e0c253-5320-48fa-9f09-49d1098ccad9" class="">Data structures can be classified based on their nature, organization, and behavior. The two main categories are primitive data structures and non-primitive data structures.</p><p id="e66c38db-ce26-4c06-980c-f418a3e289ca" class="">Primitive data structures are basic data types provided by the programming language, such as numbers, strings, booleans, null, undefined, and symbols. They are typically atomic and represent single values.</p><p id="3955c471-186c-433e-88b0-96caaa329152" class="">Non-primitive data structures are built using primitive data types and are more complex. They include data structures like arrays, linked lists, stacks, queues, trees, and graphs. These structures allow storing and organizing multiple data elements and offer various operations and behaviors for efficient data manipulation.</p><p id="1fa99a9b-5332-418b-b4f1-c310f273f02a" class="">The classification of data structures helps in understanding their characteristics, usage, and algorithms associated with them, enabling developers to choose the appropriate structure for solving different types of problems efficiently.</p><h2 id="5ac417ee-f948-46c0-87ed-4e8fd6edde05" class=""><mark class="highlight-red">Algorithmic Analysis</mark></h2><p id="9db22314-abe0-48b3-9f4f-dafb1d7682c4" class="">Algorithmic analysis is the process of evaluating the efficiency and performance of an algorithm. It involves measuring properties such as space complexity and time complexity. Space complexity refers to the amount of memory an algorithm requires to solve a problem. It helps determine how much additional space is needed as the input size increases. Time complexity, on the other hand, measures the amount of time an algorithm takes to solve a problem. It helps understand how the runtime of an algorithm grows with increasing input size. By analyzing these properties, we can make informed decisions about choosing the most efficient algorithm for a given problem.</p><h2 id="6ae16e81-fc01-4fe0-9f33-003a6936e795" class=""><mark class="highlight-red">Array Methods</mark></h2><p id="db96529e-28c8-4f8f-b1fa-1451c0ee7102" class="">Array methods in JavaScript are built-in functions that allow you to manipulate and work with arrays efficiently. Some commonly used array methods include:</p><ol type="1" id="447615c7-064b-4a73-a4aa-c1e00c191f64" class="numbered-list" start="1"><li><code>push()</code> adds one or more elements to the end of an array and returns the new length.</li></ol><ol type="1" id="f7a0eba5-fe21-4fcd-af2f-c3f7724af17a" class="numbered-list" start="2"><li><code>pop()</code> removes and returns the last element of an array.</li></ol><ol type="1" id="78e5bbc8-33d2-4c67-a909-98dbd3038c39" class="numbered-list" start="3"><li><code>shift()</code> removes and returns the first element of an array, shifting all other elements down.</li></ol><ol type="1" id="080eddba-e8cb-49a2-9035-1632cbc631d5" class="numbered-list" start="4"><li><code>unshift()</code> adds one or more elements to the beginning of an array and returns the new length.</li></ol><ol type="1" id="51e2fb57-464b-49e0-a2b1-1603a1bc23e5" class="numbered-list" start="5"><li><code>slice()</code> returns a shallow copy of a portion of an array into a new array.</li></ol><ol type="1" id="ef745139-a846-42bc-97af-b211d37a3ec5" class="numbered-list" start="6"><li><code>splice()</code> changes the contents of an array by adding, removing, or replacing elements.</li></ol><ol type="1" id="5a2d4497-a34f-4f84-895f-7d5cbfe49983" class="numbered-list" start="7"><li><code>concat()</code> combines two or more arrays and returns a new array.</li></ol><ol type="1" id="ca8596e9-a69a-427e-9842-03f9613c0f5f" class="numbered-list" start="8"><li><code>indexOf()</code> searches an array for a specific element and returns its index.</li></ol><ol type="1" id="5900f4e3-11c3-4427-b5ba-150e8e47b5bd" class="numbered-list" start="9"><li><code>forEach()</code> executes a provided function once for each array element.</li></ol><ol type="1" id="d44fbf4b-c4a8-4efb-a1e7-67d440c3f4c7" class="numbered-list" start="10"><li><code>map()</code> creates a new array by applying a provided function to each element of an array.</li></ol><h2 id="75592713-6469-4f9a-9707-c22e90a4019f" class=""><mark class="highlight-red">String Operations</mark></h2><p id="37538916-e8bf-438f-b3d7-2264b814e141" class="">JavaScript provides a range of powerful operations and methods for working with strings:</p><ol type="1" id="be2f353d-2700-48c0-8a5d-80960a490994" class="numbered-list" start="1"><li>Concatenation: Strings can be combined using the <code>+</code> operator or the <code>concat()</code> method.</li></ol><ol type="1" id="c1de2f03-922e-4296-aae6-d1c23b06e43a" class="numbered-list" start="2"><li>Length: The <code>length</code> property returns the number of characters in a string.</li></ol><ol type="1" id="66807981-025f-408b-ae62-dcf23f878143" class="numbered-list" start="3"><li>Accessing Characters: Individual characters can be accessed using bracket notation <code>[]</code>.</li></ol><ol type="1" id="aa3389d5-bfa2-4061-85d4-ac766a8cd847" class="numbered-list" start="4"><li>Substring Extraction: The <code>substring()</code> method allows you to extract a portion of a string based on start and end indexes.</li></ol><ol type="1" id="f7879063-86b9-480b-b282-2d722d42e90b" class="numbered-list" start="5"><li>Searching: The <code>indexOf()</code> method helps locate the first occurrence of a substring within a string.</li></ol><ol type="1" id="e742d64c-1433-43d7-b9b2-2fd26dcf0611" class="numbered-list" start="6"><li>Replacing: The <code>replace()</code> method replaces specific substrings with new ones.</li></ol><ol type="1" id="f31b4cc6-0acd-40e0-b413-c1e9fe3338b1" class="numbered-list" start="7"><li>Case Conversion: The <code>toUpperCase()</code> and <code>toLowerCase()</code> methods convert strings to uppercase and lowercase, respectively.</li></ol><ol type="1" id="dc6b126f-8795-4e45-894b-902c8db88f16" class="numbered-list" start="8"><li>Trimming: The <code>trim()</code> method removes whitespace from both ends of a string.</li></ol><ol type="1" id="934333f6-d7bc-4f5a-95c2-2496983a29c2" class="numbered-list" start="9"><li>Splitting and Joining: The <code>split()</code> method splits a string into an array of substrings, while <code>join()</code> combines array elements into a single string.</li></ol><p id="08d6aaef-182c-47fd-8bbb-3f6433ac921d" class="">These string operations/methods enable you to manipulate, search, modify, and extract information from strings effectively in JavaScript.</p><h2 id="845ab556-db94-4e98-9ce7-78e827e3290d" class=""><mark class="highlight-red">How does pattern matching work?</mark></h2><p id="00f8f725-89ad-478b-aa80-12d9f4662403" class="">Pattern matching involves using regular expressions (regex) to identify and extract specific patterns within text or data. A pattern is defined, either as a simple string or a more complex regex, which describes the desired structure or format. The pattern matching algorithm then compares the defined pattern to the input data, determining if there is a match. The algorithm examines the data, checking if it adheres to the pattern&#x27;s structure and constraints. If a match is found, the algorithm can extract relevant information based on placeholders or capturing groups within the pattern. This capability is particularly useful when dealing with complex data structures or when extracting specific data elements from a larger body of text. Pattern matching enables efficient searching, parsing, and manipulation of data based on predefined patterns.</p><h2 id="cf4b2996-209c-4f25-a225-3f5b1a632e83" class=""><mark class="highlight-red">Regular Expressions</mark></h2><p id="fad285f5-d300-40f9-aec2-b6ad5fba82f2" class="">Regular expressions (regex) in JavaScript are powerful tools for pattern matching and manipulating text. They are represented by patterns enclosed within forward slashes (/pattern/). </p><p id="6f216a92-f6e4-401b-8355-f0580116baf3" class=""><strong>Here&#x27;s an example:</strong> <em>(Refresh page 1-2 times if code is not rendered)</em></p><pre id="ed45e29c-46d2-417b-9f9d-bce901b9d23c" class="code code-wrap"><code>const text = &quot;Hello, I have 10 apples and 5 oranges.&quot;;
const pattern = /\\d+/g;
const numbers = text.match(pattern);

console.log(numbers); // Output: [&quot;10&quot;, &quot;5&quot;]</code></pre><p id="2f026cc5-2eb3-4a6f-a9e9-278b2d03d82c" class="">In this example, the pattern <code>\\d+</code> matches one or more digits. The <code>match()</code> method scans the <code>text</code> string and returns an array of all matches found. So, <code>numbers</code> contains <code>[&quot;10&quot;, &quot;5&quot;]</code>. Regex can also be used for more complex operations like replacing text, validating input, or extracting specific parts of a string based on patterns. They offer a flexible and efficient way to work with textual data in JavaScript.</p><h2 id="7f20402d-0e28-4da4-8a87-2c205074d921" class=""><mark class="highlight-red">Finding the sum of all numbers in an array along with the time and space complexity</mark></h2><ul id="01b08e14-e3e5-4a03-b902-0baa25454827" class="toggle"><li><details close=""><summary><strong>Traditional Solution</strong></summary><p id="b6575d9f-0e97-4a7d-8c54-c8721b35df5c" class="">Time Complexity: O(n) - linear time complexity, as we iterate through each element of the array exactly once.</p><p id="21745b15-e26e-4928-bcea-758c071b4446" class="">Space Complexity: O(1) - constant space complexity, as we only use a single variable (<code>sum</code>) to store the running sum.</p><p id="f3978648-605e-43c6-ba14-b7dde4cc1292" class=""><em>(Refresh page 1-2 times if code is not rendered)</em></p><pre id="4ef70124-89c8-4aef-8039-c61eb266510a" class="code"><code>function sumArrayUnoptimized(arr) {
  let sum = 0;

  for (let i = 0; i &lt; arr.length; i++) {
    sum += arr[i]; // Add each element to the sum
  }

  return sum;
}</code></pre></details></li></ul><ul id="402359ad-c4d4-4f7f-b90b-0ed32a7b73da" class="toggle"><li><details close=""><summary><strong>Optimized Solution</strong></summary><p id="7c6bcd93-174e-4fe7-9260-1c7192014816" class="">Time Complexity: O(n) - linear time complexity, as the <code>reduce()</code> method iterates through each element of the array internally.</p><p id="1de9b64d-bd00-4285-9a66-74e2ef5c60af" class="">Space Complexity: O(1) - constant space complexity, as no extra space is used apart from the input array.</p><p id="5ba6f7d6-b840-4ffa-9463-3db46f10af85" class="">Both solutions calculate the sum of all numbers in the array, but the optimized solution utilizes the <code>reduce()</code> method, which performs the summation in a more concise and efficient manner. The <code>reduce()</code> method takes a callback function and an initial value (<code>0</code> in this case) and accumulates the sum by adding each element to the accumulator (<code>acc</code>).</p><p id="45951260-34f9-4d3d-a82d-847ba9123646" class=""><em>(Refresh page 1-2 times if code is not rendered)</em></p><pre id="177bf283-87b1-4d41-962f-7608d36c632c" class="code"><code>function sumArrayOptimized(arr) {
  return arr.reduce((acc, curr) =&gt; acc + curr, 0); // Using the reduce() method
}</code></pre></details></li></ul><h2 id="64ee064d-cb26-495c-bd99-075dee9531df" class=""><mark class="highlight-red">Introduction to Selection Sort</mark></h2><p id="c2a0e7c8-4985-49fe-8f7d-1acff2f1318e" class="">Selection sort is a simple sorting algorithm that works by repeatedly selecting the smallest (or largest) element from the unsorted portion of the array and moving it to the sorted portion. The algorithm starts with an empty sorted region and an unsorted region containing all the elements. It iterates through the unsorted region, finding the smallest element and swapping it with the first element of the unsorted region. This process continues, moving the boundary between the sorted and unsorted regions until the entire array is sorted.</p><p id="edd21a8d-6267-4678-a350-ffe15941cb11" class="">The time complexity of selection sort is <code>O(n^2)</code> in the worst, average, and best cases, as it involves nested loops to iterate through the array. The space complexity is <code>O(1)</code> as it performs in-place sorting, meaning it doesn&#x27;t require additional memory beyond the input array.</p><figure id="4b9fe1e0-2ba7-4d46-a5eb-57214db57376" class="image"><a href="Module%20Recap%2058ac4be7bcbd4062bc2003a68a358058/2023-06-09_12.30.29_www.notion.so_d19e4a11e354.webp"><img style="width:960px" src="Module%20Recap%2058ac4be7bcbd4062bc2003a68a358058/2023-06-09_12.30.29_www.notion.so_d19e4a11e354.webp"/></a></figure><h2 id="87798a08-7db5-4e25-b634-7df64bf41691" class=""><mark class="highlight-red">Introduction to Merge Sort</mark></h2><p id="e2a66dd0-d92c-48e1-98e2-2620a6e0c040" class="">Merge sort is a divide-and-conquer algorithm used for sorting arrays. It recursively divides the array into two equal-sized subarrays until each subarray contains only one element or is empty. Then, it merges the subarrays in a sorted manner by comparing the elements and selecting the smaller one to place in the merged array. This process continues until all elements from both subarrays are merged into a single sorted array.</p><p id="e022bb8c-7a69-47fa-bf0f-240b34eae99a" class="">The algorithm has a time complexity of <code>O(n log n)</code> in the worst, average, and best cases. This efficiency is achieved by consistently dividing the array into halves and merging them back together. The space complexity is <code>O(n)</code> as it requires additional space for temporary arrays during the merging process.</p><figure id="41143c03-b9ae-406f-bf63-7127a076d26f" class="image"><a href="Module%20Recap%2058ac4be7bcbd4062bc2003a68a358058/Screenshot_2023-05-08_at_7.44.17_PM.png"><img style="width:816px" src="Module%20Recap%2058ac4be7bcbd4062bc2003a68a358058/Screenshot_2023-05-08_at_7.44.17_PM.png"/></a></figure><h2 id="d76c5686-c90f-4255-95d5-d44ff8d2042c" class=""><mark class="highlight-red">Introduction to Bucket Sort</mark></h2><p id="8245a26d-deed-4924-8e82-9a9cf65eddd9" class="">Bucket Sort is a sorting algorithm that divides the input array into a fixed number of buckets and then sorts each bucket individually. It works by distributing the elements into buckets based on their values, and then applying a sorting algorithm to sort each bucket. Finally, the sorted elements from each bucket are concatenated to obtain the sorted array.</p><p id="e0c8a581-5722-4de4-be77-0ca42219258d" class="">The algorithm determines the range of values in the input array and calculates the number of buckets needed. Each element is placed into the corresponding bucket based on its value. If a bucket contains multiple elements, they are sorted either using another sorting algorithm or by recursively applying the bucket sort algorithm.</p><p id="e6496f16-c514-4e6b-957e-796c1b233299" class="">The time complexity of Bucket Sort is <code>O(n + k)</code> on average, where n is the number of elements in the input array and k is the number of buckets. However, in the worst case, when all elements fall into a single bucket, the time complexity becomes <code>O(n^2)</code> if another sorting algorithm is used within the bucket.</p><p id="47940d62-5626-4a43-aa4c-387fb54d851e" class="">The space complexity of Bucket Sort is <code>O(n + k)</code> as it requires additional space to store the buckets and their elements. In the worst case, when all elements fall into the same bucket, the space complexity is <code>O(n)</code>. However, on average, it is <code>O(n + k)</code>.</p><figure id="1aa4f375-8fd1-4637-954a-98eba439203a" class="image"><a href="Module%20Recap%2058ac4be7bcbd4062bc2003a68a358058/2023-06-26_12.24.14_www.notion.so_15e485585ca7.png"><img style="width:1345px" src="Module%20Recap%2058ac4be7bcbd4062bc2003a68a358058/2023-06-26_12.24.14_www.notion.so_15e485585ca7.png"/></a></figure><h2 id="b80ce2aa-6229-4ab7-a5c9-7a334787167e" class=""><mark class="highlight-red">Introduction to Counting Sort</mark></h2><p id="7963a69a-dfd6-43c9-b811-c41005fc8758" class="">Counting Sort is a non-comparative sorting algorithm that sorts elements based on their frequencies. It works by determining the number of occurrences of each distinct element in the input array and using this information to determine the correct position of each element in the sorted output array.</p><p id="b30bcd20-9c41-4937-af5c-f2690d42cbf6" class="">The algorithm first finds the range of values by determining the minimum and maximum values in the input array. It then creates a count array of size equal to the range, initializing it with zeros. By iterating through the input array, the algorithm increments the count at the corresponding index for each element.</p><p id="172e4fc4-f509-40c0-bc45-fe8f232c5c8b" class="">Next, the count array is modified to store the cumulative count of each element. This cumulative count represents the number of elements that are less than or equal to the corresponding index. The algorithm then iterates through the input array in reverse order. For each element, it finds its index in the count array, which determines its position in the sorted output array. The element is placed in the correct position, and the count is decremented for that index.</p><p id="c303c608-571c-45d7-adc0-31641ea0c7f4" class="">Finally, the output array is built with the elements placed in their correct order based on their counts.</p><p id="c5a60361-e513-4b32-8ec8-610474cd971e" class="">Counting Sort has a time complexity of <code>O(n + k)</code>, where n is the number of elements in the input array and k is the range of values. It has a linear time complexity because it performs two passes over the input array. The space complexity is also <code>O(n + k)</code> as it requires additional space to store the count array and the output array.</p><figure id="b87e5aa4-dfa6-4dcb-832d-ca878e940ea0" class="image"><a href="Module%20Recap%2058ac4be7bcbd4062bc2003a68a358058/2023-06-26_12.28.03_www.notion.so_5dd0595cb938.png"><img style="width:1362px" src="Module%20Recap%2058ac4be7bcbd4062bc2003a68a358058/2023-06-26_12.28.03_www.notion.so_5dd0595cb938.png"/></a></figure><h2 id="13d72aa9-c8fe-4947-b339-e87c2dbd4b0d" class=""><mark class="highlight-red">How does Binary Searching help us?</mark></h2><p id="e83e439d-d50b-4605-848d-c108cdd097a4" class="">Binary search is a valuable algorithm in JavaScript for efficient searching in sorted arrays. It offers several benefits, including faster search times, a smaller memory footprint, and improved user experiences. With its ability to outperform linear search, binary search is ideal for large datasets and performance-critical applications. Its efficiency also makes it suitable for resource-constrained environments like mobile devices. Furthermore, binary search serves as a foundation for more advanced search algorithms, enabling developers to optimize searches for specific use cases. With the simplicity of implementation using JavaScript&#x27;s array methods, binary search offers a straightforward and effective solution for developers seeking an efficient search algorithm in their JavaScript applications.</p><h2 id="934a2344-6455-4d50-8cf2-f33432174f6b" class=""><mark class="highlight-red">Introduction to Hashmap</mark></h2><p id="28f6a02e-de5e-454f-9e4b-2662d5a2f026" class="">A hashmap in JavaScript is a data structure that allows efficient storage and retrieval of key-value pairs. Although JavaScript does not have a built-in Hashmap data structure, it can be implemented using objects. In a hashmap, keys are hashed using a hash function to generate unique hash codes. These hash codes determine the location or bucket where the key-value pairs are stored. Retrieving a value from the hashmap involves hashing the key again to locate the corresponding bucket and returning the associated value. To handle collisions, which occur when different keys produce the same hash code, techniques like chaining or open addressing are employed. When the number of key-value pairs grows, the hashmap may need to be resized and rehashed to maintain efficiency. Overall, hashmaps in JavaScript provide a convenient and efficient way to store and access data using key-value pairs.</p><p id="5d471d47-a8e8-4479-a654-bff124c8352c" class=""><strong>Here&#x27;s a small example of how you can create and use a hashmap in JavaScript using objects: </strong><em>(Refresh page 1-2 times if code is not rendered)</em></p><pre id="9a610f86-cb78-49b7-9f52-006a1b4e4db0" class="code code-wrap"><code>// Creating an empty hashmap
const hashmap = {};

// Adding key-value pairs to the hashmap
hashmap.name = &quot;John&quot;;
hashmap.age = 30;
hashmap.city = &quot;London&quot;;

// Accessing values from the hashmap
console.log(hashmap.name);    // Output: &quot;John&quot;
console.log(hashmap.age);     // Output: 30
console.log(hashmap.city);    // Output: &quot;London&quot;

// Updating a value in the hashmap
hashmap.age = 31;
console.log(hashmap.age);     // Output: 31

// Removing a value from the hashmap
delete hashmap.city;
console.log(hashmap.city);    // Output: undefined</code></pre><p id="523f0c5a-372c-4625-9a33-58da96f77074" class="">In this example, we create an empty hashmap using an object. We then add key-value pairs to the hashmap using property assignment. We can access the values in the hashmap by using the keys as property names. To update a value, we can simply assign a new value to the corresponding property. To remove a value, we use the <code>delete</code> keyword.</p><h2 id="ac698461-07c4-4e0b-84d0-b36f9dfeccb4" class=""><mark class="highlight-red">Introduction to Ternary Search</mark></h2><p id="8cef4d85-9384-46f1-9be0-22d4e9a80039" class="">Ternary search is an improved version of the binary search algorithm used to find an element in a sorted array. Instead of dividing the array into two parts like binary search, ternary search divides it into three equal parts, reducing the number of comparisons required. </p><figure id="0c9884cd-8ae8-494e-b8a7-5b0fd24dfbc6" class="image"><a href="Module%20Recap%2058ac4be7bcbd4062bc2003a68a358058/Screenshot_2023-06-26_at_3.57.52_PM.png"><img style="width:2374px" src="Module%20Recap%2058ac4be7bcbd4062bc2003a68a358058/Screenshot_2023-06-26_at_3.57.52_PM.png"/></a></figure><p id="bdfbcd14-076f-4bae-a775-114cfc76e0dd" class="">The algorithm starts by defining the search space and setting two mid-point pointers. It then compares the target value with the elements at the mid-points and updates the search space accordingly. The process is repeated until a match is found or the search space becomes empty. Ternary search has a worst-case and average-case time complexity of O(log3(n)), where n is the size of the array. Its best-case time complexity is O(1), and the space complexity is O(1) as it doesn&#x27;t require additional space.</p><h2 id="8bcbc050-a391-45fd-b5ec-d4e5b67bcad0" class=""><mark class="highlight-red">Introduction to Jump Search</mark></h2><p id="4ad897aa-1ffd-4fd8-942d-fb3c172dbb1f" class="">Jump search is an algorithm used to search for a target value in a sorted array. It involves jumping ahead a fixed number of steps and then performing a linear search within the block. The algorithm starts by determining the block size, usually the square root of the array length. It then jumps ahead by the block size until it finds a block where the target value may exist or reaches the end of the array. Within the identified block, a linear search is performed to locate the exact position of the target value. If the target value is found, its index is returned; otherwise, the process is repeated until the target value is found or the end of the array is reached. The time complexity of jump search is O(√n) in the worst and average cases, while the best-case time complexity is O(1). The space complexity is O(1) as it doesn&#x27;t require additional data structures.</p><h2 id="9ecc2834-da29-4b66-a6aa-10decd16d7cc" class=""><mark class="highlight-red">Recursion vs Loop</mark></h2><p id="bb2ff03b-0247-418e-943c-0b2ec1bb9f0c" class="">Recursion and looping are fundamental concepts in programming that involve executing instructions repeatedly. However, they differ in their approach. </p><figure id="8e15cbf2-e1a3-4678-b159-50cb6c288f04" class="image"><a href="Module%20Recap%2058ac4be7bcbd4062bc2003a68a358058/Screenshot_2023-06-26_at_4.14.39_PM.png"><img style="width:2406px" src="Module%20Recap%2058ac4be7bcbd4062bc2003a68a358058/Screenshot_2023-06-26_at_4.14.39_PM.png"/></a></figure><p id="6bf11494-a0ed-48fc-93f2-9c77f8c63a41" class="">Recursion entails a function calling itself until a base case is met, while looping involves executing instructions until a specified condition is fulfilled. Recursion offers cleaner and more concise code, simplifying complex problems and enhancing readability. On the other hand, recursion can be slower due to the creation of new function instances on the call stack, potentially leading to stack overflow errors. Looping, being faster and using less memory, is advantageous when performance is crucial. However, loops can be more challenging to understand and may require more code, especially for intricate problems. It is crucial to consider the problem&#x27;s nature and code performance and readability when choosing between recursion and looping.</p><h2 id="60d3b20e-ab57-4c4d-8d21-30accab22458" class=""><mark class="highlight-red">Implementation: Recursion &amp; Loop</mark></h2><p id="2458f7f4-6c83-4f28-9314-1842450ba5e3" class="">Recursive functions are important in computer science and programming as they solve problems by breaking them into smaller subproblems. However, analyzing the time complexity of recursive functions can be challenging. The time complexity depends on the number of recursive calls and the work done in each call.</p><p id="4c9361a0-772a-493e-ad3c-8c1d76cfb42d" class=""><strong>Example: Factorial Calculation</strong></p><p id="85456009-fa1a-4041-9c09-b2dad80c407f" class="">Let&#x27;s consider the factorial function as an example of a recursive function. The factorial of a non-negative integer n, denoted as n!, is the product of all positive integers from 1 to n.</p><p id="de4c62ac-121e-41b6-b6d5-2f8205eaa100" class=""><strong>Approach 1: Iterative Loop </strong><em>(Refresh page 1-2 times if code is not rendered)</em></p><pre id="7983a040-1ca4-45e8-83af-7e5f14ba34ee" class="code code-wrap"><code>function factorial(n) {
  let result = 1;
  for (let i = 1; i &lt;= n; i++) {
    result *= i;
  }
  return result;
}</code></pre><p id="b1e6cbb1-37f7-4c06-968d-3db9767d7108" class="">This implementation uses a <code>for</code> loop to calculate the factorial iteratively. It initializes the result to 1 and multiplies it with each integer from 1 to n. The time complexity of this approach is O(n), as it performs n multiplications.</p><p id="b7bd5d0e-cbac-4a7b-b759-d1dd88887e11" class=""><strong>Approach 2: Recursive Function </strong><em>(Refresh page 1-2 times if code is not rendered)</em></p><pre id="de85aac1-822c-4e4f-8c63-22ff6180a877" class="code code-wrap"><code>function factorial(n) {
  if (n === 0) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}</code></pre><p id="9f7c4f5a-ce5b-4a06-b7e2-2811eb0441ab" class="">In the recursive approach, the factorial function calls itself with a smaller argument until it reaches the base case of n = 0, where the factorial is defined as 1. The time complexity of this recursive implementation is also O(n), as the function makes n recursive calls to compute the factorial.</p><p id="36b11670-4bf6-4274-bfcd-1f4d2383ec07" class="">Recursive functions provide an elegant solution for solving problems by breaking them down into smaller, similar subproblems. However, analyzing their time complexity is important to understand the efficiency of the solution.</p><h2 id="37569916-2f62-4d7d-8c8a-08efdce68c0c" class=""><mark class="highlight-red">Introduction to and working of Backtracking</mark></h2><p id="dfe7c8ce-7e0b-4e26-ba07-a3add1b3ebc9" class="">Backtracking is a problem-solving technique used to find all possible solutions to a problem. It can be understood through the analogy of solving a maze, where you try different paths and backtrack when you reach a dead end. In JavaScript, backtracking is commonly implemented using recursion.</p><p id="0ec6da76-16c8-447f-943d-ff9fa8918e7a" class="">The backtracking algorithm works by choosing an initial configuration, exploring possible moves, verifying constraints, checking the goal, backtracking when needed, and repeating the process until all possibilities have been explored or a valid solution is found.</p><p id="1116dc24-87cf-4b79-bd98-359ba6de6c4d" class=""><strong><em>Example: </em></strong><em>(Refresh page 1-2 times if code is not rendered)</em></p><pre id="3e2b342d-013b-4f78-8e83-cd20b88499d0" class="code"><code>function findSubsetSum(arr, target, current = [], index = 0, sum = 0) {
  if (sum === target) {
    console.log(current);
    return;
  }
  if (sum &gt; target || index === arr.length) {
    return;
  }
  findSubsetSum(arr, target, current, index + 1, sum);
  findSubsetSum(arr, target, current.concat(arr[index]), index + 1, sum + arr[index]);
}

findSubsetSum([1, 2, 3, 4, 5], 7);</code></pre><p id="90e66a27-988f-40b2-930a-1ce43896fc67" class="">This code recursively explores different subsets of the array, either excluding or including the current element, while keeping track of the current sum. When a subset with the target sum is found, it is printed out.</p><h2 id="76912a37-b695-4f2d-a819-38463883f3b3" class=""><mark class="highlight-red">Backtracking Complexity Analysis</mark></h2><p id="50944ff3-8f9c-4900-ad37-42617d4d0443" class="">Analyzing the time and space complexity of a backtracking algorithm involves understanding the number of operations performed and the amount of memory used as the algorithm explores all possible solutions. To analyze the time and space complexity of a backtracking algorithm, follow these steps:</p><p id="8dbf9863-44a2-4f06-bb92-28c395d19b59" class="">First, determine the size of the problem space and the number of decisions to be made at each step. Next, identify the recursive nature of the algorithm and its recursive calls. Then, count the operations performed at each step, considering comparisons and computations. Calculate the total number of operations as a function of the input size and identify the worst-case scenario for maximum operations. Analyze the memory used, including variables, data structures, and the recursion stack. Express the space complexity as a function of the input size, taking into account the space required for the algorithm&#x27;s output. Simplify the complexity analysis using big O notation. Finally, validate the analysis by comparing the observed and predicted performance of the algorithm.</p><p id="864ff488-1899-4db3-9c34-dc7d9f4a1b93" class=""><strong><em>Example: </em></strong><em>(Refresh page 1-2 times if code is not rendered)</em></p><pre id="62f51c81-1970-465c-a868-d9e389fb9f08" class="code"><code>function subsetSum(nums, target) {
  const result = [];
  
  function backtrack(startIndex, currentSet, sum) {
    if (sum === target) {
      result.push([...currentSet]);
      return;
    }
    
    if (sum &gt; target || startIndex &gt;= nums.length) {
      return;
    }
    
    for (let i = startIndex; i &lt; nums.length; i++) {
      currentSet.push(nums[i]);
      backtrack(i + 1, currentSet, sum + nums[i]);
      currentSet.pop();
    }
  }
  
  backtrack(0, [], 0);
  return result;
}

// Example usage:
const nums = [1, 2, 3, 4, 5];
const target = 7;
console.log(subsetSum(nums, target));</code></pre><p id="f1746321-e0b8-41cb-98ac-df41cf44e4bc" class="">In this example, the <code>subsetSum</code> function takes an array of numbers (<code>nums</code>) and a target sum (<code>target</code>). It finds all the subsets of <code>nums</code> that sum up to the target. The backtracking algorithm recursively explores all possible combinations of elements to determine the subsets.</p><p id="f416a450-a151-4d0b-a09b-a1639838eb2a" class="">The <code>backtrack</code> function performs the backtracking process. It starts from a given <code>startIndex</code> and keeps track of the current subset (<code>currentSet</code>) and the running sum (<code>sum</code>). If the current sum matches the target, the current subset is added to the result. If the sum exceeds the target or the end of the array is reached, the function stops the current branch of exploration. Otherwise, it continues exploring by adding the next element to the current subset.</p><h2 id="063849dc-9871-4708-bc55-f427a0c2d64e" class=""><mark class="highlight-red">Problem Statement</mark></h2><p id="0ab9d4a6-7958-43fb-86a8-2d43f19c02f0" class="">Write a function <code><strong>linearSearch</strong></code> that takes an array <code><strong>arr</strong></code> and a target element <code><strong>target</strong></code> as inputs. Implement the linear search algorithm to find the target element in the array and return its index if found, or -1 if not found.</p><ul id="c5f904e0-db3c-462b-b59c-86ac6bbca5df" class="toggle"><li><details close=""><summary><strong>Traditional Solution</strong></summary><p id="89a9032d-c305-4149-91e9-b4031a338db3" class="">Time Complexity:<strong> </strong>O(n) - Linear time</p><p id="7293bbb0-0a80-4a18-9e52-bc5a58f5273a" class="">Space Complexity:<strong> </strong>O(1) - Constant space</p><pre id="2170ada7-c9e0-4387-a0cb-4ab7244743b5" class="code"><code>function linearSearch(arr, target) {
  for (let i = 0; i &lt; arr.length; i++) {
    if (arr[i] === target) {
      return i;
    }
  }
  return -1;
}</code></pre><p id="941e85ac-981f-4f65-b5d6-189c54e5dfc1" class="">
</p></details></li></ul><ul id="b3ad9ac7-7d76-487b-b01b-9eaa6bd83814" class="toggle"><li><details close=""><summary><strong>Optimized Solution</strong></summary><p id="bb6b56e9-3827-423f-bfe2-ef122a0a3bcf" class="">Time Complexity: O(n) 
Space Complexity: O(1) </p><p id="ce498d1e-76dc-4aa8-84ff-8a93195f4f0d" class="">In the optimized solution, we avoid checking the target element separately in the loop condition. Instead, we append the target element at the end of the array and then loop through the array until we find the target element. If the target element is found, we return its index. After the loop, we remove the target element from the array. If the loop reaches the length of the original array without finding the target element, we return -1 to indicate that the target element was not found.</p><pre id="899441e3-cc83-4289-bddb-65579844ec3c" class="code"><code>function linearSearch(arr, target) {
  const length = arr.length;
  arr.push(target); // Add the target element at the end

  let i = 0;
  while (arr[i] !== target) {
    i++;
  }

  arr.pop(); // Remove the target element

  if (i === length) {
    return -1; // Target element not found
  } else {
    return i; // Target element found at index i
  }
}</code></pre><p id="622475e2-4b6b-4fe4-bcd3-b6db85e531ea" class="">
</p></details></li></ul><p id="1013611e-40c7-4b44-aca8-be33abc0005a" class="">
</p></div></article></body></html>