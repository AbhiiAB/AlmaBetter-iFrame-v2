<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Getting Started with Recursion</title><link rel="stylesheet" href="../../../../../styles.css"></head><body><article id="2e8223f4-289e-4d9d-aecd-0dad334bc03f" class="page sans"><header><h1 class="page-title">Getting Started with Recursion</h1><p class="page-description"></p></header><div class="page-body"><ul id="6d905e38-866f-4a72-b52c-e439f35f0c9e" class="toggle"><li><details close=""><summary><strong>Session Flow (5 minutes read)</strong></summary><ul id="e37cafda-d0fc-4aba-bb90-0b2f93cf8d02" class="bulleted-list"><li style="list-style-type:disc"><strong>Learning Objective (5 minutes read)</strong><ul id="a73e320b-fb8e-466e-a933-e6d8140fee27" class="bulleted-list"><li style="list-style-type:circle">Introduction</li></ul><ul id="e4aec29f-5bcd-41c6-9e51-93ac1f1b7c97" class="bulleted-list"><li style="list-style-type:circle">Theme</li></ul><ul id="94a7a113-152a-47aa-98bb-db5fac1eb35d" class="bulleted-list"><li style="list-style-type:circle">Primary Goals</li></ul></li></ul><ul id="7430407b-78d6-44e5-9f39-72c7a4750cbe" class="bulleted-list"><li style="list-style-type:disc"><strong>Getting Started with Recursion (120 minutes read)</strong><ul id="af339287-05d7-45ed-b306-5ed8bf018a82" class="bulleted-list"><li style="list-style-type:circle">Introduction to Recursion<ul id="602503f7-a1f6-4661-ba68-9d651a7f7776" class="bulleted-list"><li style="list-style-type:square">Recursion in JavaScript</li></ul><ul id="a4543ab7-a9ed-46d6-b7a9-bee11534fad9" class="bulleted-list"><li style="list-style-type:square">How to use recursion?</li></ul></li></ul><ul id="8c2e8933-3c51-49d1-a691-3d35afd21bbe" class="bulleted-list"><li style="list-style-type:circle">Recursion vs Loop<ul id="2763aad0-a89a-422c-8446-21565edcf382" class="bulleted-list"><li style="list-style-type:square">Recursion - Advantages, disadvantages, and an example</li></ul><ul id="dd18cd2d-e15c-4c90-96d3-5ab60db1a893" class="bulleted-list"><li style="list-style-type:square">Loop - Advantages, disadvantages, and an example</li></ul></li></ul><ul id="6251c918-7340-48b8-8763-5fe59867fd92" class="bulleted-list"><li style="list-style-type:circle"><strong>Do it yourself</strong></li></ul><ul id="23d31a5c-c86d-4b3c-b674-c4764f70d735" class="bulleted-list"><li style="list-style-type:circle">How does Recursion work?</li></ul><ul id="7a4f8f26-9144-499d-87f1-99e43509e821" class="bulleted-list"><li style="list-style-type:circle">Use Case of Recursion</li></ul><ul id="9408b7fa-d6d6-4da6-b381-99dd93ab1a9e" class="bulleted-list"><li style="list-style-type:circle"><strong>Explore Further</strong></li></ul><ul id="71a05b79-2014-47a3-b3e1-90bb9ee3bc84" class="bulleted-list"><li style="list-style-type:circle">When not to use Recursion</li></ul><ul id="1bac7046-95eb-4dd2-97e1-1325a0c6db61" class="bulleted-list"><li style="list-style-type:circle">Implementation: Recursion &amp; Loop<ul id="2fea6d8f-f965-4be5-8d65-99747db35043" class="bulleted-list"><li style="list-style-type:square">Analyzing Time-Complexity of Recursive Functions</li></ul><ul id="249f0138-109a-4ce6-92f9-26d31c9c409f" class="bulleted-list"><li style="list-style-type:square">Example: Fibonacci Sequence</li></ul></li></ul><ul id="8a552b6e-02da-4b20-b19a-579bbb179106" class="bulleted-list"><li style="list-style-type:circle"><strong>Activity 1</strong></li></ul></li></ul><ul id="18489bdb-821b-46be-93a0-0e6aca1663e9" class="bulleted-list"><li style="list-style-type:disc"><strong>Summary (10 minutes read)</strong><ul id="e10bb53f-3775-45db-999e-a259e780012e" class="bulleted-list"><li style="list-style-type:circle">What did we learn?</li></ul><ul id="77279d08-a736-4957-9609-191e65e0a702" class="bulleted-list"><li style="list-style-type:circle">Shortcomings &amp; Challenges</li></ul><ul id="b19edfb4-e838-47e4-8ae7-5b7cd081b0f6" class="bulleted-list"><li style="list-style-type:circle">Best Practices</li></ul><ul id="27b316a9-1971-4cb1-8faf-ea2f9430a6cc" class="bulleted-list"><li style="list-style-type:circle">Enhance Your Knowledge</li></ul></li></ul></details></li></ul><p id="580d7b5a-6a0f-416f-a74f-0b884ed62022" class="">
</p><h1 id="f4bff9af-a9de-4ef8-bcdd-45a4c890b232" class=""><mark class="highlight-brown">Learning Objective</mark></h1><h2 id="d3f3fe69-7679-492b-9aae-420de1cd1785" class="block-color-default"><mark class="highlight-red">Introduction</mark></h2><p id="3a408a97-a9a2-4576-ba2c-300081ad74ef" class="">Recursion is a concept that has been around for centuries, but it&#x27;s only in recent years that it&#x27;s become a popular tool in the world of programming. In JavaScript, recursion allows you to write code that is concise and easy to understand while still being powerful enough to solve even the most challenging problems.</p><p id="2fba5eee-e3f0-44c3-9a33-b90cd8531a2b" class=""><em><strong>Duration: </strong></em>2 Hours</p><p id="ba3d0927-eeff-4ce8-9fa9-c5fbf054d6d4" class=""><em><strong>Focus: </strong></em>Recursion, iteration, implementation, and use cases </p><p id="53640e0d-dc8c-469f-bf3a-74be1005b0e5" class=""><em><strong>Pre-requisite: </strong></em>JavaScript</p><h2 id="9e085754-abfd-457c-bdd6-77b1cff44a98" class="block-color-default"><mark class="highlight-red">Theme</mark></h2><p id="c584209a-4016-4541-ac19-4a33066888fc" class="">Recursion is highly relevant in real-world scenarios, as exemplified by <strong>Google</strong> <strong>Maps</strong>&#x27; driving directions calculation. The algorithm recursively breaks down the overall route into smaller segments until it reaches the smallest possible segment, such as a single block. This enables the algorithm to calculate the most efficient route, considering all possible paths and avoiding traffic congestion.</p><h2 id="43250f2e-51e7-4fb0-ba10-ff3166a43000" class="block-color-default"><mark class="highlight-red">Primary Goals</mark></h2><ul id="251ab1f2-4bd3-4fff-adc7-eb98254552bf" class="bulleted-list"><li style="list-style-type:disc">Learn the basics of recursion in JavaScript.</li></ul><ul id="48524680-59b2-428a-881c-b6ec1517bb9b" class="bulleted-list"><li style="list-style-type:disc">Understand the differences between recursion and iteration.</li></ul><ul id="c9264ba5-b06f-4394-969f-c58de44dbbe7" class="bulleted-list"><li style="list-style-type:disc">Implement recursion in various use cases.</li></ul><ul id="faa43637-6354-4b64-a757-0ac611bd44e5" class="bulleted-list"><li style="list-style-type:disc">Gain a solid understanding of the benefits and drawbacks of using recursion.</li></ul><p id="d9d12bf4-47ec-4cd9-a15f-1373d59c8b54" class="">
</p><h1 id="80263362-f0b0-4001-bf29-edbeec6015a5" class=""><mark class="highlight-brown">Getting Started with Recursion</mark></h1><h2 id="4a5a40fc-4659-4283-a00a-3710b1c384fd" class=""><mark class="highlight-red">Introduction to Recursion</mark></h2><p id="79fa80ac-48b8-4043-9e88-f266c26e8f34" class="">The <strong>Unix operating system</strong> uses a recursive directory structure to organize files and folders. Each directory in the file system can contain sub-directories, which can, in turn, contain more sub-directories, and so on. This structure can be navigated using a recursive algorithm, which starts at the root directory and then recursively navigates through each sub-directory until the desired file or folder is found. This approach allows for a flexible and scalable file system that can handle many files and folders.</p><p id="11dcef1b-1e59-4038-8e42-40c63b8e3cc7" class="">Recursion can be used in many other ways in programming. Another example is the creation of <strong>fractals,</strong> which are complex geometric patterns that repeat themselves at different scales. A fractal can be created using a recursive algorithm that repeatedly applies rules to a simple geometric shape, such as a line or a triangle. As the algorithm runs, the shape is repeated and scaled down, creating a complex pattern that exhibits self-similarity. This technique is used in many computer graphics and animation and can produce stunningly beautiful visual effects.</p><h3 id="53cc49b1-9b8d-4f50-9746-18ee27daa9d1" class="block-color-default">Recursion in JavaScript</h3><p id="93a50bcd-dea1-4106-9e8b-8eed504e1930" class="">Recursion is a technique in which a function calls itself until it reaches a base case. The base case is a condition that stops the recursive function from calling itself. Each recursive call creates a new instance of the function on the call stack, meaning it has its own set of variables and parameters</p><figure id="9628f2c3-f45b-446c-b845-42a4ececc5e2" class="image"><img style="width:2412px" src="Getting%20Started%20with%20Recursion%202e8223f4289e4d9daecd0dad334bc03f/Screenshot_2023-05-09_at_8.17.13_PM.png"/></a></figure><h3 id="ae9691ed-ac34-4836-9463-db9f2d3fca0c" class="block-color-default">How to use recursion?</h3><p id="88bf84fa-493d-4465-86e6-1bd122a3087e" class="">To use recursion in JavaScript, you must define a function that calls itself. The function should have a base case that stops the recursion and a recursive case that calls itself with a modified input.</p><figure id="6b7208f0-63eb-4b9b-a76a-247d55a8184a" class="image"><img style="width:2482px" src="Getting%20Started%20with%20Recursion%202e8223f4289e4d9daecd0dad334bc03f/Screenshot_2023-05-09_at_8.17.44_PM.png"/></a></figure><p id="d582e31c-f036-4243-b38b-bef67962b017" class=""><strong>Here is an example of a recursive function in JavaScript that calculates the factorial of a number:</strong></p><pre id="709abae9-97f3-442b-a925-518d4440801e" class="code code-wrap"><code>function factorial(n) {
  if (n === 0) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

console.log(factorial(5)); // Output: 120
</code></pre><p id="c1bb0256-29ce-4dc5-b99c-747aee24b0ab" class="">In this example, the <code>factorial</code> function takes a number <code>n</code> as input and returns the factorial of <code>n</code>. The base case is when <code>n</code> equals 0, in which case the function returns <code>1</code>. The recursive case is when <code>n</code> is greater than <code>0</code>, wherein the function calls itself with the argument <code>n - 1</code> and multiplies the result by <code>n</code>.</p><p id="b4e19ff2-df52-4b9b-ad1d-4837fe291602" class="">When the function is called with an argument of <code>5</code>, for example, the function will first call itself with an argument of <code>4</code>, and then <code>3</code>, and then <code>2</code>, and then <code>1</code>, and finally <code>0</code>. The base case is reached, and the function returns <code>1</code>. The other function calls then return the factorial of the original input, which is <code>5 * 4 * 3 * 2 * 1 = 120</code>.</p><p id="77602f0a-2915-45a5-b00d-bba9aa23ccfe" class="">
</p><p id="67295948-7000-4549-a44a-29b2f80658ab" class="">Recursion can be a powerful tool in JavaScript because it allows complex problems to be broken down into smaller sub-problems. This can result in code that is easier to read and understand, as well as code that is easier to maintain and update. Recursion can also be more efficient than other techniques in certain situations, although it can be less efficient in others. Additionally, recursion can be a valuable tool for solving certain types of problems, such as those that involve tree structures or other recursive data structures.</p><h2 id="b47d1cbd-576a-4c39-bb46-7e8d81e7c409" class=""><mark class="highlight-red">Recursion vs Loop</mark></h2><p id="2d3503ff-9268-4e6a-80ec-411c84b9756f" class="">Recursion and looping are two of the most important concepts in programming. Both of these techniques are used to execute instructions repeatedly, but they achieve this goal differently. This document will discuss the differences between recursion and looping and their advantages and disadvantages.</p><figure id="53a42589-108c-4d23-8212-21a8d50d53f1" class="image"><img style="width:2438px" src="Getting%20Started%20with%20Recursion%202e8223f4289e4d9daecd0dad334bc03f/Screenshot_2023-05-09_at_8.19.06_PM.png"/></a></figure><h3 id="8fc85f1a-deef-41ec-84e3-eb1236464d7e" class="block-color-default">Recursion</h3><p id="3c6c8ef2-9c8c-4bb7-9d0e-5d39bb2e2e3b" class="">Recursion is a technique in which a function calls itself until it reaches a base case. The base case is a condition that stops the recursive function from calling itself. Each recursive call creates a new instance of the function on the call stack, meaning it has its own set of variables and parameters.</p><p id="74350751-9e4c-4a68-a322-6c40baa69fd5" class=""><strong>Advantages of Recursion:</strong></p><ol type="1" id="c95ac1da-f673-4b2e-8592-7dfb84f6fc1b" class="numbered-list" start="1"><li><strong>Cleaner and more concise code:</strong> Recursion can be used to simplify complex problems and reduce the amount of code required to solve them.</li></ol><ol type="1" id="63018971-805d-438e-bc85-766f5c634dab" class="numbered-list" start="2"><li><strong>Easier to understand:</strong> Recursion is a natural way of expressing certain problems, and it can make the code more readable and easier to understand.</li></ol><p id="ff6d4d71-2e4f-4fe2-bdfa-7b7bd3f5fb95" class=""><strong>Disadvantages of Recursion:</strong></p><ol type="1" id="180ca770-0dd5-4b11-a240-cfdc1cd2bd39" class="numbered-list" start="1"><li><strong>Slower than looping:</strong> Recursive functions can be slower than their iterative counterparts because each call creates a new function instance on the call stack.</li></ol><ol type="1" id="d79c8b2e-8c8a-4bc7-832b-6fe9261e3058" class="numbered-list" start="2"><li><strong>Stack overflow:</strong> If the base case is not reached, the recursive function will continue to call itself indefinitely, which can result in a stack overflow error.</li></ol><p id="c97f9a1d-adc3-49fb-a0e2-5bec9ced7adc" class=""><strong>Example of Recursion:</strong></p><p id="161227ed-9cdf-48be-bfa2-980c0297bcfd" class="">Here&#x27;s an example of a recursive function that calculates the factorial of a number:</p><pre id="0a9225ea-8d03-428b-aae6-c4f37a1ea3eb" class="code code-wrap"><code>function factorial(n) {
  if (n === 0) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

console.log(factorial(5)); // Output: 120
</code></pre><h3 id="b27feb02-9a25-4e15-914f-f1adfc61775c" class="block-color-default">Loop</h3><p id="8ccf6085-b005-4458-a4d0-66ab9bcb78d3" class="">Looping is a technique in which instructions are executed repeatedly until a specified condition is met. There are several loops in JavaScript, including the for loop, while loop, and do-while loop.</p><p id="c077464f-905d-4f06-a849-6296aa4b84fd" class=""><strong>Advantages of Loop</strong></p><ol type="1" id="68467ac5-c4d0-465a-82f1-82e484df9418" class="numbered-list" start="1"><li><strong>Faster than recursion:</strong> Looping is generally faster than recursion because there is no overhead associated with creating new instances of the function.</li></ol><ol type="1" id="cf95d177-8820-4026-8441-cf28b7599946" class="numbered-list" start="2"><li><strong>Less memory usage:</strong> Since looping does not create new instances of the function, it uses less than recursion.</li></ol><p id="dcc1ca7e-a621-47cf-ad38-5be9cca025c8" class=""><strong>Disadvantages of Loop</strong></p><ol type="1" id="f1f8082b-996e-4513-8613-2fbcddea8da8" class="numbered-list" start="1"><li><strong>More difficult to read:</strong> Loops can be more challenging to read and understand than recursive functions.</li></ol><ol type="1" id="0e5c35da-436d-426c-8ac4-2f13198a52a5" class="numbered-list" start="2"><li><strong>More code required:</strong> Loops can require more than recursive functions, especially for complex problems.</li></ol><p id="fc9e04e8-9b44-40a1-ab7e-1fa5cf64aca7" class=""><strong>Example of Loop:</strong></p><p id="6fa94d44-e71f-4ced-94de-a9e8368c1b17" class="">Here&#x27;s an example of a for loop that calculates the factorial of a number:</p><pre id="4b9963c6-0e92-4887-9893-96cb6fe6dc2c" class="code code-wrap"><code>function factorial(n) {
  let result = 1;

  for (let i = 1; i &lt;= n; i++) {
    result *= i;
  }

  return result;
}

console.log(factorial(5)); // Output: 120
</code></pre><p id="b5189dcc-5b72-48fe-b063-f548ffcf6ea1" class="">Recursion and looping are both important techniques in programming, and each has its own advantages and disadvantages. When selecting a technique, it&#x27;s important to consider the problem you&#x27;re trying to solve, as well as the performance and readability of your code.</p><p id="540e7f0c-5d2c-483f-9bbf-2ae5055ef910" class="">
</p><h2 id="2730d425-8bb6-45f1-931f-a456f5554b68" class="block-color-default"><mark class="highlight-blue"><strong>Do it yourself</strong></mark></h2><p id="5037de99-e8ea-42e7-93c6-6ceff9954d62" class=""><strong>State True or False:</strong></p><ol type="1" id="7d93b904-c81d-4d7d-8513-efeac438f7df" class="numbered-list" start="1"><li>Recursion and looping are two important concepts in programming. </li></ol><ol type="1" id="84006ce6-5865-4764-ab37-e1202b201dd6" class="numbered-list" start="2"><li>Recursion is a technique in which a function calls another function until it reaches a base case.</li></ol><ol type="1" id="ccb33633-d072-4238-9ab0-b0dbfcfe5012" class="numbered-list" start="3"><li>Recursion can only be used to solve simple problems and cannot be used to simplify complex problems.</li></ol><ol type="1" id="a8a6546a-1246-4c69-94f1-6934281343e8" class="numbered-list" start="4"><li>Each recursive call creates a new instance of the function on the call stack. </li></ol><ol type="1" id="5e51e75c-a0c4-47eb-b7c8-1196f44d3692" class="numbered-list" start="5"><li>Recursion can be used to simplify complex problems and reduce the amount of code required to solve them. </li></ol><ul id="056c7a85-f7cc-48a8-b772-bdff4701d618" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><ol type="1" id="96f1c40f-f6cf-4f8d-a804-d15e131543b1" class="numbered-list" start="1"><li>True</li></ol><ol type="1" id="41197eca-2199-4873-83dc-dc3f85814e61" class="numbered-list" start="2"><li>False</li></ol><ol type="1" id="20e43798-2b92-4c60-a165-2f208b41702f" class="numbered-list" start="3"><li>False</li></ol><ol type="1" id="8d183eef-9145-4238-a71c-906a3fd8e967" class="numbered-list" start="4"><li>True</li></ol><ol type="1" id="ae31d9e1-395a-463d-aa73-4ad4150b0089" class="numbered-list" start="5"><li>True</li></ol></details></li></ul><p id="7b639ef2-22bc-4ec7-b0a4-433afa29bb26" class="">
</p><h2 id="4a28ee96-02e7-40b4-b243-427d74e73b0f" class=""><mark class="highlight-red">How does Recursion work?</mark></h2><p id="ed155716-1913-4ff3-9b6a-b1f2a84881af" class="">In JavaScript, a recursive function is a function that calls itself. It is useful for solving problems that can be broken down into smaller, similar problems.</p><p id="70fe1996-e055-4606-8ec6-0ad58eaafa8a" class=""><strong>To create a recursive function, you need to define the following things:</strong></p><ul id="3d4cab36-60d1-4446-9921-44be9cc1c3a9" class="bulleted-list"><li style="list-style-type:disc">First, <strong>define the function </strong>with a name and a set of parameters. </li></ul><ul id="0f613c3f-4f78-4c94-9dae-288abaea9a62" class="bulleted-list"><li style="list-style-type:disc">Within the function, <strong>define the base case and the recursive case</strong> using conditional statements. </li></ul><ul id="6042f504-596a-43c7-8bdb-7891082517fb" class="bulleted-list"><li style="list-style-type:disc">The <strong>base case</strong> is the condition that stops the recursion, and the recursive case is the condition that continues the recursion. <p id="65b441e7-d580-4fde-bb01-4a8a318536a4" class=""><strong>Note</strong>: It is important to define the base case correctly, or the function will continue to call itself indefinitely, resulting in a stack overflow error. </p></li></ul><ul id="02ce33f6-8b4b-4e9f-b6a0-73177e6173d6" class="bulleted-list"><li style="list-style-type:disc">In the <strong>recursive case</strong>, call the function again with a modified set of parameters. The recursion continues until the base case is reached.<p id="0fc1b058-76c2-40f0-82e1-dc6680d99997" class=""><strong>Note</strong>: Ensure that the recursive case brings you closer to the base case, or the function will continue to call itself indefinitely.</p><figure id="ab560214-96c1-4836-82e4-f2022322accf" class="image"><img style="width:2408px" src="Getting%20Started%20with%20Recursion%202e8223f4289e4d9daecd0dad334bc03f/Screenshot_2023-05-09_at_8.20.09_PM.png"/></a></figure></li></ul><p id="962f94d0-5858-4f57-8565-a87cbed24c92" class="block-color-default"><strong>Here&#x27;s an example of a recursive function that calculates the factorial of a number:</strong></p><pre id="4eeb11f5-169b-4c51-bf3f-7e6b7adb058e" class="code code-wrap"><code>function factorial(num) {
  if(num === 0 || num === 1) {
    return 1;
  } else {
    return num * factorial(num - 1);
  }
}</code></pre><ul id="cdb3e315-0c4c-4987-ba03-57785259d52e" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ul id="eb18f05c-5fd9-4db4-aeac-2fd7046b3ab0" class="bulleted-list"><li style="list-style-type:disc">The base case is when <code>num</code> equals 0 or 1. In this case, the function returns 1. The recursive case is when <code>num</code> is greater than 1. In this case, the function calls itself with <code>num - 1</code> as the argument and multiplies the result by <code>num</code>.</li></ul><ul id="dcbc6097-9e7b-499c-8b55-a807e10120fa" class="bulleted-list"><li style="list-style-type:disc">When you call the <code>factorial</code> function with a number, the function checks if the number is 0 or 1. If it is, the function returns 1. If it is not, the function calls itself with the argument <code>num - 1</code> and multiplies the result by <code>num</code>. This process continues until the base case is reached.</li></ul><ul id="a66393a2-7c0e-4ad0-9186-ae478856be66" class="bulleted-list"><li style="list-style-type:disc">For example, if you call <code>factorial(4)</code>, the function will call itself with <code>factorial(3)</code>, then <code>factorial(2)</code>, then <code>factorial(1)</code>. The base case is reached, and the function returns 1. The result is then multiplied by <code>2</code>, <code>3</code>, and <code>4</code>, giving you the factorial of 4, which is 24.</li></ul></details></li></ul><p id="89b11017-a029-4822-be8c-b4ff1b8f6d41" class="">Overall, recursion in JavaScript involves defining a base case and a recursive case in a function. The function calls itself with a minor argument until the base case is reached, at which point it returns a value.</p><h2 id="54d025b9-9e29-48a2-8aa0-8751d6788595" class=""><mark class="highlight-red">Use Case of Recursion</mark></h2><p id="dbcd1239-04eb-444b-8e3f-78ef1b80e003" class="">Recursion is a powerful technique in programming that involves a function calling itself. In JavaScript, recursion can be used in various scenarios to solve problems. </p><p id="e7d7912e-5862-4035-a76d-132f227ea96e" class=""><strong>Here are some of the common use cases of recursion in JavaScript:</strong></p><ol type="1" id="354ac881-5393-4116-8e66-af1c4674668d" class="block-color-default numbered-list" start="1"><li><strong>Traversing Tree Structures:</strong> <p id="a019aeab-2a9b-4386-acf3-d56d4693af66" class="">Recursion is often used to traverse tree structures like JavaScript&#x27;s Document Object Model (DOM). This makes it easy to navigate through complex nested structures.</p><p id="57638dad-66f3-4849-9a3b-420554695cf6" class=""><strong>Explanation</strong>: A recursive function can be used to traverse a tree by calling itself on each child node of the current node. This process continues recursively until all nodes in the tree have been visited. By using recursion, the code can be written in a more concise and readable manner compared to traditional iterative methods. Additionally, recursion can handle arbitrary levels of nesting within the tree, which can be difficult to handle with iterative methods.</p></li></ol><ol type="1" id="9c7902a1-3651-4b2e-8155-1de1b26b113c" class="block-color-default numbered-list" start="2"><li><strong>Sorting Algorithms:</strong> <p id="c1b76643-60f6-49fb-8f4e-4970c32f5a95" class="">Recursion can be used to implement sorting algorithms like Quick sort and Merge sort. These algorithms involve dividing a list into smaller sub-lists and sorting them recursively.</p><p id="0e787f72-60f8-465c-9232-57d0cec5f3d1" class=""><strong>Explanation</strong>: In quicksort, the algorithm chooses a &quot;pivot&quot; element and divides the list into two sub-lists, one containing elements smaller than the pivot and one containing elements greater than the pivot. This process recursively occurs on the two sub-lists until the list is sorted. </p><p id="86c2ead6-911e-4000-9cf5-2e60e34d19f4" class="">In Merge sort, the algorithm divides the list into two sub-lists of roughly equal size. These sub-lists are recursively sorted and merged to form the final list. </p></li></ol><ol type="1" id="a59338e7-8ede-4e0d-a768-d6912bd4811b" class="block-color-default numbered-list" start="3"><li><strong>Searching and Filtering Arrays:</strong> <p id="3854796b-35cd-49c4-baa9-73c956682ecf" class="">Recursion can be used to search and filter arrays. This involves calling the function with a smaller sub-array until the desired element is found or the array is empty.</p><p id="426e47f6-cd81-4c2c-8a99-5becdec35e74" class=""><strong>Explanation</strong>: A binary search algorithm can be implemented recursively by dividing the array in half and checking if the middle element is the target element. If the middle element is not the target, the algorithm can call itself with either the left or right half of the array, depending on whether the target is greater or less than the middle element. This process recursively until the target element is found or the array is empty. </p><p id="645b1647-9430-4655-9c43-c73602bd82a6" class="">Similarly, a filter function can be implemented recursively by checking if the first element of the array satisfies a given condition. If it does, the element is added to a new array. The function is then called recursively with the rest of the array until the entire array is processed. The final result is the new array containing all the elements that satisfy the given condition. </p></li></ol><ol type="1" id="1d337db0-57b4-41c1-b302-8e50276d48e9" class="block-color-default numbered-list" start="4"><li><strong>Generating Permutations and Combinations:</strong> <p id="f0153c69-6bb9-47b1-b7b8-2963d27056b1" class="">Recursion can be used to generate permutations and combinations of a set of elements. This involves calling the function with smaller elements until all possible permutations or combinations are generated.</p><p id="874f0fff-200f-46d1-b29b-2df5fe4cfb9c" class=""><strong>Explanation: </strong>For permutations, the recursive function can be called with a smaller set of elements by removing one element at a time and generating all possible permutations of the remaining elements. The base case occurs when the set of elements is empty. Once a permutation is generated, it can be added to a list of permutations.</p><p id="265eaf1d-3362-4664-9f8b-cd6d550496b4" class="">For combinations, the recursive function can be called with a smaller set of elements by either including or excluding the first element of the set. If the first element is included, the function is called recursively with the remaining elements and a smaller number of elements to choose from. If the first element is excluded, the function is called recursively with the remaining elements and the same number of elements to choose from. The base case occurs when the number of elements to choose is zero. Once a combination is generated, it can be added to a list of combinations.</p></li></ol><ol type="1" id="7b10f8fd-adc3-415e-ac1a-d4795b1434bf" class="block-color-default numbered-list" start="5"><li><strong>Solving Maze Problems:</strong> <p id="729dbffb-d92a-45dd-95db-654faa762112" class="">Recursion can be used to solve maze problems. This involves calling the function recursively to explore all possible paths until the end of the maze is reached.</p><blockquote id="9cf76738-5080-49ec-83d2-0fee75b7ecd6" class="block-color-default"><strong>A maze Problem? </strong>It is a problem where the objective is to find a path from a starting point to an endpoint in a maze. The maze is typically represented as a grid of cells, where some cells are blocked and cannot be traversed. The path must traverse only unblocked cells and may not cross over itself. Recursion can be used to explore all possible paths in the maze until the endpoint is reached.</blockquote><p id="bd0640e3-b371-41e0-9571-afb5bdb0f488" class=""><strong>Explanation</strong>: The function can be designed to explore all possible paths by checking each adjacent cell to see if it is valid. The function can be called recursively with the new cell if it is a valid path. This process continues recursively until the end of the maze is reached, or all paths have been explored. By using recursion, the code can be written in a more concise and readable manner compared to traditional iterative methods. </p><p id="15f4e920-f217-4500-993a-841e221fd0a6" class="">Additionally, recursion allows backtracking to explore other possible paths, which can be challenging to handle with iterative methods.</p></li></ol><ol type="1" id="f877caa0-ecb2-4620-9ad2-1014e391a286" class="block-color-default numbered-list" start="6"><li><strong>Parsing and Evaluating Expressions:</strong> <p id="4e7f13b7-594e-4dfa-8ab1-8c4a7dac1f90" class="">Recursion can be used to parse and evaluate expressions. This involves breaking down the expression into smaller sub-expressions and evaluating them recursively.</p><p id="f3629460-018d-4046-a398-bcd2bdeb6ab1" class=""><strong>Explanation</strong>: Simple arithmetic expressions like <code>3 + 4 * 5</code> can be evaluated recursively by breaking them down into smaller sub-expressions like <code>4 * 5</code> and <code>3 + 20</code>.</p><p id="cd819f76-b577-4c0a-a229-da0d25fe6b30" class="">The recursive function can then be called with each sub-expression until the entire expression is evaluated. The base case occurs when the expression is a single value or variable, at which point the function returns the value of the expression. Using recursion, the code for parsing and evaluating expressions can be written more concisely and readable than traditional iterative methods. </p><p id="da01272c-e686-4565-828a-3b3c49821a71" class="">Additionally, recursion can handle arbitrarily complex expressions, which can be challenging with iterative methods.</p></li></ol><p id="ba1c9cdd-3c2e-490a-9811-5064a3522431" class=""> </p><h2 id="f6c15ba4-7353-4021-a67e-f5f468b4c91b" class="block-color-default"><mark class="highlight-blue"><strong>Activity 1</strong></mark></h2><p id="a2ddcab4-3e0d-40b4-a76c-3ca11f477332" class=""><strong>Agree/Disagree:</strong></p><ol type="1" id="8a8ead7c-2273-42bb-8c66-b2d36e0a2fe8" class="numbered-list" start="1"><li>Recursion is commonly used in JavaScript for traversing tree structures. </li></ol><ol type="1" id="55a419d5-5b2a-4f33-b701-5133f92c6e3d" class="numbered-list" start="2"><li>The benefit of using recursion to traverse tree structures in JavaScript is not related to handling arbitrary levels of nesting within the tree. </li></ol><ol type="1" id="0bfed926-a395-4019-9994-198e45d33895" class="numbered-list" start="3"><li>QuickSort is a sorting algorithm but can&#x27;t be implemented using recursion. </li></ol><ol type="1" id="9da0b5fe-26ce-4744-b5f8-a9dd542f5a00" class="numbered-list" start="4"><li>Recursive functions call themselves and help solve problems that can be broken down into smaller subproblems. </li></ol><ol type="1" id="e232eff5-dd5c-477a-9bed-7bbbcb0157d4" class="numbered-list" start="5"><li>The Fibonacci sequence is an example of an iterative function.</li></ol><ol type="1" id="3fa911f6-d6ff-40d1-9fdf-bf9567e38fe1" class="numbered-list" start="6"><li>The Fibonacci sequence calculates the n-th term by adding the previous two terms until it reaches the base case of the first two terms, which are both 1. </li></ol><ul id="b011f8fc-670c-4501-934a-bfb95c2b9405" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><ol type="1" id="a7d1c6c8-1e5d-4aa8-863f-a5db7a8cf615" class="numbered-list" start="1"><li>Agree</li></ol><ol type="1" id="e71372b6-4854-4330-a30e-117b9e333f6b" class="numbered-list" start="2"><li>Disagree</li></ol><ol type="1" id="88cefa70-e6e0-469a-a758-26ac4df07766" class="numbered-list" start="3"><li>Disagree</li></ol><ol type="1" id="e0134d12-8b85-4bad-88c5-a44b55a1dd86" class="numbered-list" start="4"><li>Agree</li></ol><ol type="1" id="d0b204bc-36ea-4746-afb9-cce664d35d15" class="numbered-list" start="5"><li>Disagree</li></ol><ol type="1" id="97f99334-9a4e-4876-8448-92bce368a646" class="numbered-list" start="6"><li>Agree</li></ol></details></li></ul><p id="9c1edd73-2bfb-47e9-88a3-2b866bea7925" class="">
</p><h2 id="db45d790-ca35-4cfc-8400-a678173c2afa" class=""><mark class="highlight-red">When not to use Recursion</mark></h2><p id="7690a303-50fb-4ec5-a68c-676376dfb91a" class="">Recursion is a powerful programming technique, but there are better solutions to a problem. </p><p id="3e4249d0-ffad-490d-85c7-dfe4dd0556fc" class=""><strong>Here are five situations where using recursion is not recommended:</strong></p><ol type="1" id="a2c2dea3-0684-434f-a0ba-573388cbdd91" class="numbered-list" start="1"><li><strong>When the input size is large:</strong> Recursion requires a lot of memory overhead due to the call stack. If the input size is large, the call stack could overflow and cause a stack overflow error. For example, calculating the factorial of a large number using recursion could cause a stack overflow error.</li></ol><ol type="1" id="cf53c9cc-872b-4cb2-af20-5387a054dcf3" class="numbered-list" start="2"><li><strong>When the recursion depth is too deep:</strong> Recursion requires a lot of stack space. If the recursion depth is too deep, then it could cause a stack overflow error. For example, calculating the Fibonacci sequence using recursion could cause a stack overflow error if the recursion depth is too deep.</li></ol><ol type="1" id="bbd3fe3f-54cc-447d-84e9-3fd72069e8c8" class="numbered-list" start="3"><li><strong>When the problem can be solved iteratively:</strong> Recursion is not always the most efficient solution to a problem. In some cases, an iterative solution may be more efficient. For example, searching for an element in a sorted array can be done more efficiently using binary search, which is an iterative algorithm.</li></ol><ol type="1" id="8b0d4585-97d0-491d-9829-5e0b2029918c" class="numbered-list" start="4"><li><strong>When the code complexity is high:</strong> Recursion can make the code more complex and harder to understand. If the code is already complex, then using recursion could make it even harder to understand. For example, implementing a merge sort algorithm using recursion can be more complex than implementing it using an iterative algorithm.</li></ol><ol type="1" id="14dec648-3801-4eec-9795-ef6d2d0ea751" class="numbered-list" start="5"><li><strong>When no base cases are defined:</strong> Recursion requires base cases to terminate. The recursion will continue indefinitely if no base cases are defined, causing a stack overflow error. For example, a recursive function that calls itself without any base cases defined will cause a stack overflow error.</li></ol><h2 id="e1f3867b-8c77-45be-876e-11a2959355ad" class=""><mark class="highlight-red">Implementation: Recursion &amp; Loop</mark></h2><h3 id="3790e2a3-3158-43ca-b0e7-88566b6313b3" class="block-color-default">Analyzing Time-Complexity of Recursive Functions</h3><p id="945c805d-d954-4307-8b4e-2cfa7c364ea9" class="">Recursive functions are an essential concept in computer science and programming. They are functions that call themselves and help solve problems that can be broken down into smaller, similar subproblems. However, recursive functions can also present a challenge when it comes to analyzing their time complexity. This document will explore the time complexity of recursive functions in-depth, providing examples.</p><p id="f333f6ac-a9e8-45ff-803a-e47f8dc75dca" class="">A recursive function&#x27;s time complexity depends on how often the function is called and how much work is done each time. This can be expressed in terms of the number of recursive calls and the work done in each call.</p><h3 id="8ac4f977-c823-4aff-ace9-4e1ab7df6657" class="block-color-default">Example: Fibonacci Sequence</h3><p id="15e4e42c-b96d-4a9b-abca-daf6d8648c24" class="">The Fibonacci sequence is an example of a recursive function. It calculates the n-th term of the sequence by adding the previous two terms until it reaches the base case of the first two terms, which are both 1.</p><figure id="25497106-c16c-45c4-a14b-cc8a25400a13" class="image"><img style="width:2476px" src="Getting%20Started%20with%20Recursion%202e8223f4289e4d9daecd0dad334bc03f/Screenshot_2023-05-09_at_8.21.20_PM.png"/></a></figure><p id="b2c25a0e-39b9-43a8-a55d-cba7ff0da07e" class="block-color-default"><strong>Approach 1: While Loop</strong></p><pre id="02ef1c77-dda1-49a1-95cc-be0b25455b56" class="code code-wrap"><code>function fibonacci(n) {
  let a = 1, b = 0, temp;

  while (n &gt; 0) {
    temp = a;
    a = a + b;
    b = temp;
    n--;
  }

  return b;
}</code></pre><p id="a87d7f65-1fbc-4174-bcf3-2d96290802cf" class="">This implementation uses a <code>while</code> loop to calculate the n-th term of the sequence. It initializes the first two terms to 1 and 0, respectively, then iteratively calculates each subsequent term by adding the previous two terms. This implementation has a time complexity of <strong>O(n)</strong>, which is much more efficient than the recursive implementation&#x27;s <strong>O(2^n)</strong>.</p><p id="81104342-1b8b-4997-9717-1cf7af780c0a" class="">
</p><p id="a4a6c89b-6000-43fa-94b4-8acb9ceb93d3" class="block-color-default"><strong>Approach 2: Recursive Function</strong></p><pre id="68bb7cb9-b085-4b73-ac4a-80610d50bf4b" class="code code-wrap"><code>function fibonacci(n) {
  if (n === 1 || n === 2) {
    return 1;
  } else {
    return fibonacci(n - 1) + fibonacci(n - 2);
  }
}</code></pre><p id="7eeef6d8-9e98-4e17-8958-e3a8bceb6c84" class="">In this case, the function is called <strong>2^(n-1)</strong> times, as each call creates two more calls. Each call also performs addition. Therefore, the time complexity of the Fibonacci function is <strong>O(2^n)</strong>.</p><p id="d7c8e812-cf10-45a9-abb3-2e286b80c367" class="">
</p><p id="8e6e3592-1b17-462d-946a-8ea5871747f3" class="">Recursive functions are powerful tools for solving problems that can be broken down into smaller, similar subproblems. However, analyzing their time complexity can be challenging. By understanding how recursive functions work and the amount of work done in each call, we can better understand their time complexity.</p><p id="d4f45d6a-66cf-4fb6-af38-49e72ab4f3b5" class="">
</p><h2 id="ee128b2a-82dd-45f4-8975-20433018ee32" class="block-color-default"><mark class="highlight-blue"><strong>Explore Further</strong></mark></h2><p id="1a5041a2-12e0-4ffb-821e-235088784c99" class=""><mark class="highlight-orange"><strong>Uncover and unlock new insights as you dive into the captivating content found in the provided link.</strong></mark></p><p id="0af81dca-38e8-46ef-979c-8db6f4245e1a" class=""><strong>Tail call optimization: </strong><a href="https://exploringjs.com/es6/ch_tail-calls.html">https://exploringjs.com/es6/ch_tail-calls.html</a></p><p id="c05fe46e-2f81-4389-abe1-fb6b64827f9c" class="">
</p><p id="b196bbac-8451-4c61-8b5a-3d352a36ab27" class=""><mark class="highlight-orange"><strong>Tackle these questions head-on!</strong></mark></p><p id="2752242e-b9b0-401a-89d1-64fd3634bd20" class=""><strong>Read each riddle carefully. </strong><em><strong>Let&#x27;s see if you can unravel the recursive mysteries!</strong></em></p><ol type="1" id="42c11f76-3763-4709-b62c-2cad32a5a637" class="numbered-list" start="1"><li>Riddle: I&#x27;m an optimization technique, Making function calls quite unique.
When the last action is another call, The stack won&#x27;t grow, and no space will fall.
<em>What am I called?</em></li></ol><ol type="1" id="d6762269-4732-4d19-a26c-179bf025c567" class="numbered-list" start="2"><li>Riddle: I determine if a call is in a tail position, Expression, or statement, and I make the decision.
Conditional, logical, comma, or return, I check them all; it&#x27;s something to learn.
<em>Who am I?</em></li></ol><ol type="1" id="e31f6ff6-c4af-42c0-a970-cff03df5a87e" class="numbered-list" start="3"><li>Riddle: I&#x27;m a way to make loops without the stack, Recursion in action, no need to backtrack.
forEach or findIndex, examples of my might, Solving problems efficiently, day or night.
<em>What technique am I?</em></li></ol><ol type="1" id="7c88863c-bead-48d9-9694-ef259fd31f62" class="numbered-list" start="4"><li>Riddle: In strict mode, I&#x27;m the only way, Tail call optimization gets its say.
func. arguments and func.caller won&#x27;t be found, With strict rules, I&#x27;m tightly bound.
<em>What mode am I in?</em></li></ol><ol type="1" id="bfb964a6-9501-4ca9-9d68-6c52b0a5f218" class="numbered-list" start="5"><li>Riddle: Solo function calls, beware the pitfall, Never in tail position, causing a close call.
The last action is returning undefined, Changing behavior; it&#x27;s something we mind.
<em>What should we do to make it right?</em></li></ol><ul id="1b5bef5c-d957-4795-bcef-8140f8bc43c1" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><ol type="1" id="d192fe01-4ae4-45d2-9303-9f016402e620" class="numbered-list" start="1"><li>Tail call optimization</li></ol><ol type="1" id="e839c17a-9c64-426d-b72e-fd6ad0f055e1" class="numbered-list" start="2"><li>Checking tail position</li></ol><ol type="1" id="1aa8c4a2-8304-4f14-801f-9c49a4de7654" class="numbered-list" start="3"><li>Tail-recursive loops</li></ol><ol type="1" id="6d352e48-8296-44dc-95ee-2c611b7f68c3" class="numbered-list" start="4"><li>Strict mode</li></ol><ol type="1" id="7018af63-f3d7-4135-b6d3-8bcdaf92bc0f" class="numbered-list" start="5"><li>Make it a tail call</li></ol></details></li></ul><p id="498748e4-2383-4092-87a1-24f2becf93d3" class="">
</p><h1 id="fa3cd102-d042-4327-b275-4d574fd0a3f9" class=""><mark class="highlight-brown">Summary</mark></h1><h2 id="16546031-b3d4-43c5-8334-2e36a8143953" class="block-color-default"><mark class="highlight-red">What did we learn?</mark></h2><ul id="06f10a46-84f2-42cc-9d40-eb38c50dffe3" class="bulleted-list"><li style="list-style-type:disc">A recursive function is a function that calls itself until it reaches a base case.</li></ul><ul id="c6c36a40-578d-4d84-bb54-16cd74ea0d61" class="bulleted-list"><li style="list-style-type:disc">Recursive functions in JavaScript can be used to solve problems that require repetitive operations.</li></ul><ul id="08bf4a0a-e463-49e7-a8e5-a42f50ffa6e4" class="bulleted-list"><li style="list-style-type:disc">A base case is a condition where the function stops calling itself and returns a value.</li></ul><ul id="eace0ee6-b75e-4965-a1ba-e56b38f2fccc" class="bulleted-list"><li style="list-style-type:disc">Recursive functions can be tricky to debug, and it&#x27;s essential to make sure that the base case is well-defined.</li></ul><h2 id="bc9962d0-765a-4968-bed6-ec03c38f3d3f" class=""><mark class="highlight-red">Shortcomings &amp; Challenges</mark></h2><ul id="2af0a45f-8ed8-4fdf-b3c4-dcc794133c67" class="bulleted-list"><li style="list-style-type:disc">Recursive functions can be slower and less memory-efficient than iterative solutions.</li></ul><ul id="24584026-858c-43c0-ba79-3f8128f760c0" class="bulleted-list"><li style="list-style-type:disc">They can also be harder to read and understand than iterative solutions.</li></ul><h2 id="79c85167-2961-4eb2-b4c4-89822a18ced6" class="block-color-default"><mark class="highlight-red">Best Practices</mark></h2><ul id="4460ff96-986c-4963-89c3-079cf195dc7a" class="bulleted-list"><li style="list-style-type:disc">Use recursion only when it is the most elegant solution to a problem.</li></ul><ul id="ee37f5e3-2344-4665-b312-bccd18edae76" class="bulleted-list"><li style="list-style-type:disc">Make sure to define the base case properly to avoid infinite loops.</li></ul><ul id="45447180-18b2-44ef-b682-28abcd05259f" class="bulleted-list"><li style="list-style-type:disc">Use helper functions where necessary to simplify the implementation of the recursive function.</li></ul><h2 id="56be03c9-8d4e-41ce-bbc6-c2ce43edf152" class="block-color-default"><mark class="highlight-red">Enhance Your Knowledge</mark></h2><ul id="2e5d7977-7c87-4873-9fae-f7b8adc30143" class="bulleted-list"><li style="list-style-type:disc"><a href="https://developer.mozilla.org/en-US/docs/Glossary/Recursion">MDN web docs: Recursion</a></li></ul><ul id="4749158d-0958-4d12-8a0f-61044efa9224" class="bulleted-list"><li style="list-style-type:disc"><a href="https://dev.to/kalashin1/recursive-functions-in-javascript-b6a">https://dev.to/kalashin1/recursive-functions-in-javascript-b6a</a></li></ul><p id="6366a4ce-493e-40ec-a2db-daa8f3a6cee9" class="">
</p></div></article></body></html>
