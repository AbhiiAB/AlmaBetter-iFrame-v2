<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Getting Started with Backtracking &amp; its Analysis</title><link rel="stylesheet" href="../../../../../styles.css"></head><body><article id="3aa41a2a-d5d6-4adc-8daf-d4777ce27ae9" class="page sans"><header><h1 class="page-title">Getting Started with Backtracking &amp; its Analysis</h1><p class="page-description"></p></header><div class="page-body"><ul id="174fbf34-4ffa-4488-9eb0-3c389d33ca49" class="toggle"><li><details close=""><summary><strong>Session Flow (5 minutes read)</strong></summary><ul id="98776a28-0f7a-431c-9468-d96819d89087" class="bulleted-list"><li style="list-style-type:disc"><strong>Learning Objective (5 minutes read)</strong><ul id="a067ae1c-8971-4f8a-b914-1521699bb9f7" class="bulleted-list"><li style="list-style-type:circle">Introduction</li></ul><ul id="097a97c5-5219-4a85-85c6-4accfde8a3b8" class="bulleted-list"><li style="list-style-type:circle">Theme</li></ul><ul id="42755482-d1c1-4a6d-8071-49f4f6da76a6" class="bulleted-list"><li style="list-style-type:circle">Primary Goals</li></ul></li></ul><ul id="14f1be52-12e2-422f-84b1-16be726d529a" class="bulleted-list"><li style="list-style-type:disc"><strong>Getting Started with Back Tracking (120 minutes read)</strong><ul id="1d614329-c6a8-4b81-8fce-41cfe143d663" class="bulleted-list"><li style="list-style-type:circle">Introduction to Backtracking</li></ul><ul id="fbae1af6-9c69-41b6-9595-843a10c7239c" class="bulleted-list"><li style="list-style-type:circle">Working of Backtracking Algorithm?</li></ul><ul id="a2306de7-25af-4032-9bfa-26f730b43caa" class="bulleted-list"><li style="list-style-type:circle"><strong>Do it yourself</strong></li></ul><ul id="8da07c54-fd81-4c25-9f77-e99a1cc35d2d" class="bulleted-list"><li style="list-style-type:circle">Types of Backtracking</li></ul><ul id="01b0959d-c382-4723-82c2-4249aceab4bf" class="bulleted-list"><li style="list-style-type:circle">Implementation of Backtracking</li></ul><ul id="e24fb86f-1633-47b3-a41e-5f8da2f18658" class="bulleted-list"><li style="list-style-type:circle">Applications of Backtracking</li></ul><ul id="b40d0fe7-4996-42c8-9478-1c4248d7db8b" class="bulleted-list"><li style="list-style-type:circle"><strong>Activity 1</strong></li></ul><ul id="7ea402d3-a641-432d-86c3-bdb73474dbb4" class="bulleted-list"><li style="list-style-type:circle">Backtracking Complexity Analysis</li></ul><ul id="a914c002-ed90-426b-802d-82c51c7c07e2" class="bulleted-list"><li style="list-style-type:circle"><strong>Explore Further</strong></li></ul></li></ul><ul id="4294a695-4db4-48e3-94aa-a876c00b92ad" class="bulleted-list"><li style="list-style-type:disc"><strong>Summary (10 minutes read)</strong><ul id="11dcdb15-33fc-4a97-ad07-9807789b58e8" class="bulleted-list"><li style="list-style-type:circle">What did we learn?</li></ul><ul id="b4dc09de-1925-432c-a22f-1d72a7e6165f" class="bulleted-list"><li style="list-style-type:circle">Shortcomings &amp; Challenges</li></ul><ul id="54472755-462a-4296-8317-d9870c37574c" class="bulleted-list"><li style="list-style-type:circle">Best Practices</li></ul><ul id="735d15a9-d31a-447c-97ef-936499278ff9" class="bulleted-list"><li style="list-style-type:circle">Enhance Your Knowledge</li></ul></li></ul></details></li></ul><h1 id="a5440655-2b64-4108-a7a2-17f5e03f4b16" class=""><mark class="highlight-brown">Learning Objective</mark></h1><h2 id="4e9a41be-9094-4d9b-a046-7d7ef1cdfc9b" class="block-color-default"><mark class="highlight-red">Introduction</mark></h2><p id="09f2cb60-fb24-47b7-8314-86ab37a6f8b8" class="">Backtracking is a technique that has been around for decades, but it&#x27;s only in recent years that it&#x27;s become a popular tool in the world of programming. In JavaScript, backtracking allows you to write code that is efficient, easy to understand, and capable of solving even the toughest problems.</p><p id="6e521454-0208-4453-a031-87af13cfa938" class=""><strong>Focus: </strong>Backtracking Algorithm, Working, Implementation, Application, and Complexity Analysis</p><p id="54d194a8-922f-4839-ba6f-b1b62e120287" class=""><strong>Pre-requisite: </strong>JavaScript Basics</p><h2 id="f1209eb5-f8f9-43af-8c8a-bc06c6c9807d" class="block-color-default"><mark class="highlight-red">Theme</mark></h2><p id="202f5648-16d5-4e93-ac55-a955ca858d9f" class="">Imagine you&#x27;re planning a road trip to visit multiple cities. You want to create an itinerary that covers all the cities while minimizing the total distance traveled. This is where the <strong>backtracking algorithm</strong> comes to the rescue!</p><p id="59b90611-c22d-44d5-b7e2-62389665063a" class="">Think of backtracking as your smart travel planner. It starts by considering all possible combinations of cities to visit and carefully exploring different routes. At each step, it checks if the current route satisfies your criteria, like not revisiting the same city or staying within a certain distance limit. If a constraint is violated, it backtracks and tries a different route.</p><p id="72d4c2a6-c74b-429d-bc20-9415727a2bf5" class="">Backtracking keeps trying different combinations until it finds the optimal itinerary that covers all the cities without breaking any rules. It&#x27;s like having a travel genie that magically figures out the best route for your adventure. So, whether planning trips, solving puzzles, or optimizing resources, the backtracking algorithm is your go-to guide for finding the best solutions in complex scenarios. Bon voyage!</p><h2 id="9709441e-3e52-47ad-b819-9f73a13cc519" class="block-color-default"><mark class="highlight-red">Primary Goals</mark></h2><ul id="afa439b9-6dbd-4630-8d3a-b133b720832d" class="bulleted-list"><li style="list-style-type:disc">Understand the concept of the backtracking algorithm.</li></ul><ul id="37d21efb-174f-4256-9791-7912c0c55723" class="bulleted-list"><li style="list-style-type:disc">Learn how backtracking works and its implementation in code.</li></ul><ul id="6f3df805-88fe-4c9c-b118-2c43e37caf19" class="bulleted-list"><li style="list-style-type:disc">Explore various use cases of backtracking, such as creating game AI, solving puzzles, and optimization problems.</li></ul><ul id="39af3884-b82d-4b60-903e-308ba9338705" class="bulleted-list"><li style="list-style-type:disc">Develop skills in designing and analyzing Backtracking algorithms for specific domains.</li></ul><p id="8a0093da-ee25-4b24-85c9-c90d1851ec5b" class="">
</p><h1 id="ac568503-187e-498c-808a-f21448ad14a1" class=""><mark class="highlight-brown">Getting Started with Back Tracking &amp; its Analysis</mark></h1><h2 id="c86fe81c-7a7a-428c-9db1-7a4dbd70557b" class="block-color-default"><mark class="highlight-red">Introduction to Backtracking</mark></h2><p id="552946ef-18d2-481e-92f7-be2ca6fc9e32" class="">One way to understand backtracking is to think about it using a real-life analogy. Imagine that you are trying to solve a <strong>Maze</strong>. </p><p id="24ad21de-4bec-4e2f-aa69-da4dd0ec24c0" class="">You might start at the entrance and try to find the exit, but you don&#x27;t know the correct path. So you start trying different paths, going left or right at each intersection, and recording what you have tried. Eventually, you might reach a dead end without a clear path forward. At this point, you have to backtrack to the last intersection and try a different path. Trying different paths and backtracking when you reach a dead end is similar to how backtracking works in computer algorithms.</p><figure id="b306a745-34ed-4e6c-83cc-e0a8c9edd487" class="image"><img style="width:2422px" src="Getting%20Started%20with%20Backtracking%20&amp;%20its%20Analysis%203aa41a2ad5d64adc8dafd4777ce27ae9/Screenshot_2023-05-10_at_8.30.56_PM.png"/></a></figure><p id="cc570b55-b1f4-46da-996b-41784de4d79f" class="">Backtracking is a problem-solving algorithmic technique that is often used to solve problems that involve finding all possible solutions to a problem. This technique is commonly used in programming languages such as JavaScript.</p><p id="0f442777-a2ad-4afa-89aa-a40540177973" class="">In JavaScript, backtracking can be implemented using recursion. The algorithm is defined as a function that inputs the problem&#x27;s current state and returns the solution if one is found. If a solution is not found, the function continues to recursively call itself, trying different options at each step until a solution is found or all options have been exhausted.</p><figure id="2d314b3e-32e9-4c29-958d-75508ad5f503" class="image"><img style="width:2484px" src="Getting%20Started%20with%20Backtracking%20&amp;%20its%20Analysis%203aa41a2ad5d64adc8dafd4777ce27ae9/Screenshot_2023-05-10_at_8.31.19_PM.png"/></a></figure><p id="9913c684-12f9-4a37-9490-7c114c5039f8" class=""><strong>Here is an example of how backtracking can be used to find all possible combinations of a set of elements in JavaScript:</strong></p><pre id="3c187c43-a201-4285-995d-15e1f0b9442a" class="code code-wrap"><code>function findAllCombinations(set, index, current) {
  if (index === set.length) {
    console.log(current);
    return;
  }
  findAllCombinations(set, index + 1, current);
  findAllCombinations(set, index + 1, current.concat(set[index]));
}

const set = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];
findAllCombinations(set, 0, []);

// Output
// []
// [&quot;c&quot;]
// [&quot;b&quot;]
// [&quot;b&quot;, &quot;c&quot;]
// [&quot;a&quot;]
// [&quot;a&quot;, &quot;c&quot;]
// [&quot;a&quot;, &quot;b&quot;]
// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></pre><ul id="7371823d-8172-4c37-a93f-3f498da802eb" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="b2dc250f-bf3a-49f1-98a1-f1419aab7761" class="numbered-list" start="1"><li>The function starts by checking if the <code>index</code> parameter is equal to the length of the <code>set</code> array. If they are equal, it means we have reached the end of the set, and we have a complete combination stored in the <code>current</code> array. In this case, the <code>current</code> array is printed using <code>console.log</code>, and the function returns.</li></ol><ol type="1" id="77447d2f-70e8-46b0-8e45-fb0c1142cd77" class="numbered-list" start="2"><li>If the <code>index</code> is not equal to the length of the <code>set</code> array, we have two recursive calls to <code>findAllCombinations</code>.</li></ol><ol type="1" id="4be387df-79c2-4f68-8d24-c875b518fee1" class="numbered-list" start="3"><li>The first recursive call (<code>findAllCombinations(set, index + 1, current)</code>) represents the scenario where the current element is not included in the combination. It moves to the next index (<code>index + 1</code>) and keeps the <code>current</code> array unchanged.</li></ol><ol type="1" id="249d716a-b5d7-403c-9161-8cb13878dd35" class="numbered-list" start="4"><li>The second recursive call (<code>findAllCombinations(set, index + 1, current.concat(set[index]))</code>) represents the scenario where the current element is included in the combination. It moves to the next index (<code>index + 1</code>) and creates a new <code>current</code> array by concatenating the existing <code>current</code> array with the element at the current index (<code>set[index]</code>).</li></ol><ol type="1" id="a5b41be5-1861-4830-a689-ffea8e92a604" class="numbered-list" start="5"><li>By recursively calling the function with different combinations of elements, it explores all possible combinations and eventually prints them out.</li></ol></details></li></ul><h2 id="bb45d348-919b-4c7b-8178-1a9e97b83691" class="block-color-default"><mark class="highlight-red">Working of Backtracking Algorithm</mark></h2><p id="18e1e6d4-ed67-4974-8f64-9b9d51bb5281" class="">In JavaScript, backtracking is often used in search algorithms, puzzles, and games. Backtracking is a recursive algorithm that tries various paths until it finds a solution.</p><p id="e190a1cd-cc00-40b6-82fa-600cb8e20b29" class="">In backtracking, a program starts with a solution and then tries to find better solutions by incrementally changing it. If a better solution is not found, the program backtracks and tries a different path. The algorithm continues to backtrack until all possible solutions have been tried.</p><p id="d5f6588e-ed39-461c-b57c-9c40af2cc62c" class="">Here&#x27;s a step-by-step explanation of how the backtracking algorithm works:</p><ol type="1" id="122dd139-267f-4e7d-998c-a7cf274808e6" class="numbered-list" start="1"><li><strong>Choose</strong>: Start by choosing the initial configuration or a partial solution.</li></ol><ol type="1" id="ff483101-e490-4a69-91ba-18849434f22b" class="numbered-list" start="2"><li><strong>Explore</strong>: Proceed to explore the next possible move or extension of the current partial solution. Generate all valid options that can be appended to the current configuration.</li></ol><ol type="1" id="0e658486-a6d5-4bcd-9590-6da29dbcc055" class="numbered-list" start="3"><li><strong>Constraints</strong>: Verify if the current partial solution satisfies all the problem constraints. If the constraints are violated, backtrack to the previous step and try a different option.</li></ol><ol type="1" id="3a09ebd0-ec90-4d68-9c52-f0921124cf37" class="numbered-list" start="4"><li><strong>Goal</strong>: Check if the current partial solution satisfies the goal or objective of the problem. If the goal is met, a valid solution is found.</li></ol><ol type="1" id="35a695be-0c17-4405-b765-5313fe25eb8d" class="numbered-list" start="5"><li><strong>Backtrack</strong>: If the constraints are met, but the goal is not yet reached, recursively backtrack to the previous step and undo the last move or extension. This allows the algorithm to explore alternative paths and try different combinations.</li></ol><ol type="1" id="71107fdf-b9c6-4253-9836-cf96a5e3970f" class="numbered-list" start="6"><li><strong>Repeat or Conclude</strong>: Repeat steps 2-5 until all possibilities have been explored or a valid solution is found. If no solution is found, it concludes that there is no valid solution for the problem.</li></ol><p id="723aab7f-efef-4d32-84ec-201eae579371" class="block-color-default">
</p><p id="1cba4e2d-6455-4cce-bbda-af69cd8cf004" class=""><strong>Consider an example of using backtracking to solve the subset sum problem. The goal is to find a subset of numbers from an array that adds up to a given target sum.</strong></p><pre id="7260caff-14ea-40d4-906c-7b444d35392b" class="code code-wrap"><code>// Function to find a subset of numbers that add up to a target sum
function findSubsetSum(arr, target) {
  let solution = [];

  // Recursive function to find a solution
  function backtrack(start, sum) {
    // Check if the solution is valid
    if (sum === target) {
      console.log(solution);
      return;
    }

    // Try all possible paths
    for (let i = start; i &lt; arr.length; i++) {
      solution.push(arr[i]);
      backtrack(i + 1, sum + arr[i]);
      solution.pop();
    }
  }

  // Call the recursive function
  backtrack(0, 0);
}

// Test the function
findSubsetSum([1, 2, 3, 4, 5], 7);

// Output
// [1, 2, 4]
// [2, 5]
// [3, 4]</code></pre><ul id="5b20d1a7-93fd-48a1-a5a7-b11e6b4bf956" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="3850ec22-69a3-4c02-8a6a-2ab5f53cfb38" class="numbered-list" start="1"><li>The <code>findSubsetSum</code> function takes an array <code>arr</code> and a target sum <code>target</code> as parameters.</li></ol><ol type="1" id="0d8ef85b-795a-490d-83a6-62ddf484dadd" class="numbered-list" start="2"><li>It initializes an empty <code>solution</code> array to store the current subset that adds up to the target sum.</li></ol><ol type="1" id="c4f60407-ac06-49fe-9d74-0d75d0768b29" class="numbered-list" start="3"><li>Inside the function, there is a recursive function named <code>backtrack</code> that takes two parameters: <code>start</code> and <code>sum</code>.</li></ol><ol type="1" id="f6b69e99-2e48-4251-81d0-df28ce007baf" class="numbered-list" start="4"><li>If the current <code>sum</code> is equal to the <code>target</code> sum, a valid subset is found. The <code>solution</code> array is logged to the console.</li></ol><ol type="1" id="71355cd9-775a-4ffc-a682-04b7af0ac66c" class="numbered-list" start="5"><li>The function iterates over the remaining elements in the array, starting from the <code>start</code> index.</li></ol><ol type="1" id="0fd6de28-3dbb-440e-bd10-536ef82b71f8" class="numbered-list" start="6"><li>For each element, it adds it to the <code>solution</code> array, updates the <code>sum</code> by adding the element&#x27;s value, and recursively calls the <code>backtrack</code> function with the updated parameters.</li></ol><ol type="1" id="ea481b62-88e7-457d-91b3-e192bc1c171d" class="numbered-list" start="7"><li>After the recursive call returns, the last element is removed from the <code>solution</code> array using <code>solution.pop()</code> to allow backtracking and explore other possibilities.</li></ol><ol type="1" id="19f2cc8a-916e-447d-b8ba-ee3df67ee1d3" class="numbered-list" start="8"><li>The process continues until all possible subsets have been explored.</li></ol><ol type="1" id="9c10f996-9435-4224-b40c-081b01d21fdd" class="numbered-list" start="9"><li>Finally, the <code>findSubsetSum</code> function is called with the initial parameters, <code>backtrack(0, 0)</code>, to start the backtracking algorithm.</li></ol><p id="a5d4fd39-a016-445b-b152-f68bae6533ba" class="">In the given example, the <code>findSubsetSum</code> function is called with an array <code>[1, 2, 3, 4, 5]</code> and a target sum of <code>7</code>. The code will find all possible subsets from the array that add up to the target sum and log them to the console.</p></details></li></ul><p id="85292bd7-7adc-4b14-8e8a-704f9c61fc10" class="">
</p><h2 id="cfa29ce9-4298-456f-9f15-8eaff853078e" class="block-color-default"><mark class="highlight-blue"><strong>Do it yourself</strong></mark></h2><p id="7ebc3aee-c6bf-4e30-8335-3db09be575b5" class=""><strong>Problem Statement:</strong> Write a JavaScript function that generates all possible subsets of numbers from 1 to a given positive integer <code>n</code> using backtracking. Implement the function <code>generateSubsets(n)</code> using a recursive approach, where <code>n</code> is the desired upper limit of the numbers in the subsets. The function should return an array containing all the generated subsets.</p><pre id="c4c99bc2-d5e5-42b5-855e-6e64eb35fae6" class="code"><code>Input: n = 2
Output: [ [], [ 1 ], [ 1, 2 ], [ 2 ] ]

Input: n = 0
Output: [[]] (Empty subset)

Input: n = 1
Output: [ [], [ 1 ] ]

Input: n = 4
Output: [
				  [],             [ 1 ],
				  [ 1, 2 ],       [ 1, 2, 3 ],
				  [ 1, 2, 3, 4 ], [ 1, 2, 4 ],
				  [ 1, 3 ],       [ 1, 3, 4 ],
				  [ 1, 4 ],       [ 2 ],
				  [ 2, 3 ],       [ 2, 3, 4 ],
				  [ 2, 4 ],       [ 3 ],
				  [ 3, 4 ],       [ 4 ]
				]</code></pre><ul id="7fe6dcae-de3f-4102-a872-437104764799" class="toggle"><li><details close=""><summary><strong>Hints</strong></summary><ol type="1" id="a0e1f8e1-28bb-46e1-97f0-d64d4bdbea48" class="numbered-list" start="1"><li><strong>Identify the base case:</strong> Determine the condition that will terminate the recursion. In this case, it occurs when <code>start</code> exceeds <code>end</code>. This condition signifies that we have explored all the numbers and reached the end of a subset.</li></ol><ol type="1" id="2b12be90-72b4-4193-8801-0635ab91db96" class="numbered-list" start="2"><li><strong>Choose, explore, and unchoose:</strong> Analyze the three steps within the <code>for</code> loop. Understand how the current number is chosen, how the exploration occurs with a recursive call to <code>backtrack</code>, and how the choice is undone (unchoose) before moving to the next iteration.</li></ol><ol type="1" id="9bcafbdd-9f73-40d3-8c8e-629cc1ff7caf" class="numbered-list" start="3"><li><strong>Understand the role of the </strong><code>results</code><strong> array:</strong> Notice how the <code>currentSubset</code> is added to the <code>results</code> array using <code>results.push(currentSubset.slice())</code>. This step ensures that a copy of the current subset is stored in the results, as arrays are reference types in JavaScript.</li></ol><ol type="1" id="4d21f54f-3828-49d2-80b1-1eb8223aa12b" class="numbered-list" start="4"><li><strong>Define the </strong><code>generateSubsets</code><strong> function:</strong> Implement the <code>generateSubsets</code> function that serves as an entry point to the backtracking process. It initializes an empty <code>results</code> array, calls the <code>backtrack</code> function with the appropriate initial values, and returns the final <code>results</code> array.</li></ol></details></li></ul><ul id="5e5909e9-95e5-4168-b2d2-f61525c88e1b" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><pre id="de5ad595-1b8d-45d8-b9be-fc5089df788c" class="code"><code>function backtrack(start, end, currentSubset, results) {
  results.push(currentSubset.slice()); // Add a copy of the current subset to the results

  for (let i = start; i &lt;= end; i++) {
    // Choose
    currentSubset.push(i);

    // Explore
    backtrack(i + 1, end, currentSubset, results);

    // Unchoose
    currentSubset.pop();
  }
}

function generateSubsets(n) {
  const results = [];
  backtrack(1, n, [], results);
  return results;
}

// Example usage:
const n = 3;
const subsets = generateSubsets(n);
console.log(subsets);</code></pre><p id="f398ea0a-e672-48db-aab8-7a73ad2d0c69" class=""><strong>Explanation:</strong></p><p id="15ac4774-787b-4540-8869-e56a65bcc203" class="">The <code>backtrack</code> function is a recursive helper function that takes in four parameters: <code>start</code> (the starting number for the subset), <code>end</code> (the ending number for the subset), <code>currentSubset</code> (the subset being built), and <code>results</code> (the array to store the generated subsets).</p><p id="6695d6f7-0fd3-4b61-a8b6-0061b72f081e" class="">Inside the <code>backtrack</code> function, we first add a copy of the <code>currentSubset</code> to the <code>results</code> array using <code>slice()</code>.</p><p id="44256865-0a57-4cfa-a70a-ed8f4e49cd2a" class="">Next, we iterate from <code>start</code> to <code>end</code>, inclusive. For each number, we perform the following steps:</p><ol type="1" id="67b3c6cf-7a47-4ccb-9328-a71b9322ef7b" class="numbered-list" start="1"><li><strong>Choose:</strong> Add the current number <code>i</code> to the <code>currentSubset</code>.</li></ol><ol type="1" id="278f7962-dee5-4759-a360-da91d7eddeb0" class="numbered-list" start="2"><li><strong>Explore:</strong> Recursively call <code>backtrack</code> with the updated <code>start</code> as <code>i + 1</code>, the same <code>end</code>, the updated <code>currentSubset</code>, and the <code>results</code> array.</li></ol><ol type="1" id="92fc3670-331b-438f-8892-51e9f5d308c6" class="numbered-list" start="3"><li><strong>Unchoose: </strong>Remove the last element from the <code>currentSubset</code> to backtrack and try other possibilities.</li></ol><p id="e5459e83-c462-4fb3-ad4a-9d9971bac72b" class="">Finally, outside the <code>backtrack</code> function, we define the <code>generateSubsets</code> function. It initializes an empty <code>results</code> array and calls the <code>backtrack</code> function with the starting number <code>1</code>, the given number <code>n</code> as the ending number, an empty <code>currentSubset</code>, and the <code>results</code> array.</p><p id="147a1014-3f75-4f1b-bc28-e29f4abe74f8" class="">The <code>generateSubsets</code> function returns the <code>results</code> array containing all the generated subsets.</p><p id="4fda1db5-9a73-466d-8752-04559e57df21" class="">In the example usage, we test the function with <code>n = 3</code>. The expected output is an array of all possible subsets of numbers from 1 to 3: <code>[[1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]</code>.</p></details></li></ul><h2 id="e13fcf74-3c25-4841-a287-b2d9ebaf9c7d" class="block-color-default"><mark class="highlight-red">Types of Backtracking</mark></h2><p id="7f6e74d5-039c-40a5-bd79-b8ac2fe79e4e" class="">Here are three types of problems that are commonly solved using backtracking:</p><ol type="1" id="0bfb486e-54e0-4153-a070-9d63451787b4" class="numbered-list" start="1"><li><strong>Decision Problem</strong>: Backtracking is used to determine the existence of a feasible solution by exploring different paths and making decisions at each step. The algorithm returns &quot;true&quot; if a valid solution is found and &quot;false&quot; otherwise. Examples include solving Sudoku puzzles or finding Hamiltonian cycles in graphs.</li></ol><ol type="1" id="c975e41b-93ce-4e5b-9e72-5566543a0cd9" class="numbered-list" start="2"><li><strong>Optimization Problem</strong>: Backtracking is applied to find the best solution among a set of feasible solutions. The algorithm explores different paths, evaluating and updating the current best solution. It terminates when all solutions have been explored, or a termination condition is met. Examples include finding the shortest path in a graph or maximizing the sum of a subset of numbers.</li></ol><ol type="1" id="9e718121-b557-49c3-bbf6-f21f4eb85559" class="numbered-list" start="3"><li><strong>Enumeration Problem</strong>: Backtracking is used to enumerate all feasible solutions to a given problem. The algorithm systematically generates and evaluates all possible solutions, avoiding duplicates. It continues until all feasible solutions have been enumerated. Examples include generating all permutations of a set or finding valid puzzle configurations.</li></ol><p id="39b8b8ef-4a51-49ec-b483-875a52c4b72e" class="">Each type of backtracking problem has specific goals and requirements, influencing the approach and techniques used to solve them.</p><h2 id="94a4e367-5a4e-41ea-b72d-32e7d1c3802e" class=""><mark class="highlight-red">Implementation of Backtracking</mark></h2><p id="dca1a3d7-c382-4d58-a00d-b170084449fc" class="">The basic syntax to use backtracking in JavaScript involves defining a recursive function that explores different paths and makes decisions at each step.</p><p id="ec129027-adf9-4aaf-96bd-8cebf5741156" class=""><strong>Here&#x27;s a general template for implementing backtracking in JavaScript:</strong></p><pre id="fffcb4d4-1fb3-493a-837c-6d7d5d351788" class="code code-wrap"><code>function backtrack(parameters) {
  // Base case(s) - Check for termination conditions
  if (/* base case condition */) {
    // Solution found or termination condition met
    // Perform necessary operations or return the solution
    return;
  }

  // Iterate over possible choices or options
  for (let option of /* possible choices */) {
    // Make a choice
    // Modify parameters or update the state

    // Recursive call
    backtrack(/* updated parameters */);

    // Undo the choice (backtrack)
    // Restore parameters or revert the state
  }
}

// Call the backtracking function with initial parameters
backtrack(/* initial parameters */);</code></pre><ul id="41642399-6705-4a12-8011-1bf39258a01d" class="toggle"><li><details close=""><summary><strong>Explanation</strong></summary><ol type="1" id="36c8e6c2-9436-4d50-b245-6545676209c9" class="numbered-list" start="1"><li>Define a recursive function called <code>backtrack</code> that takes parameters representing the current state or configuration.</li></ol><ol type="1" id="dae13ca6-e1d4-4a04-b745-6f547b5d1820" class="numbered-list" start="2"><li>Specify the base cases within the <code>backtrack</code> function to check for termination conditions or when a solution is found.</li></ol><ol type="1" id="c142ae58-3d64-43f8-9f2a-70637811cc2f" class="numbered-list" start="3"><li>If a base case is met, perform necessary operations or return the solution.</li></ol><ol type="1" id="1557e5b3-79ea-4ffe-bdab-d1f1663d2322" class="numbered-list" start="4"><li>Iterate over the possible choices or options available at the current step using a loop (e.g., <code>for</code> loop).</li></ol><ol type="1" id="4614f2f0-5a6c-420f-9597-33b066100b71" class="numbered-list" start="5"><li>For each option, make a choice by modifying the parameters or updating the state accordingly.</li></ol><ol type="1" id="2bc1fcc4-88e0-4fca-9c22-1c24c6af5a2f" class="numbered-list" start="6"><li>Make a recursive call to the <code>backtrack</code> function with the updated parameters.</li></ol><ol type="1" id="6465f09b-7c89-4c30-85ae-52f2d6f5b126" class="numbered-list" start="7"><li>After the recursive call, undo the choice (backtrack) by restoring the parameters or reverting the state to its previous value.</li></ol><ol type="1" id="d14478fb-5bc7-4c0f-8d94-1e48e0508fe7" class="numbered-list" start="8"><li>This allows the algorithm to explore other paths and possibilities.</li></ol><ol type="1" id="06236341-1e52-4c75-b20b-4ed3f22f4c40" class="numbered-list" start="9"><li>Repeat steps 4 to 8 until all possible choices have been explored.</li></ol><ol type="1" id="d563e0da-d8ea-4e04-98b6-9c5e9ec11082" class="numbered-list" start="10"><li>Finally, call the <code>backtrack</code> function with the initial parameters to start the backtracking process.</li></ol></details></li></ul><h2 id="756af924-85a8-42cd-85a7-136665c399eb" class=""><mark class="highlight-red">Applications of Backtracking</mark></h2><p id="3288d280-9b73-42d2-b09c-fdabada0fb0b" class="">Backtracking is a versatile algorithmic technique with widespread applications across various problem domains. Here are some commonly encountered areas where backtracking is employed:</p><ol type="1" id="aa232173-c3fe-48db-b3db-885092e9d0da" class="numbered-list" start="1"><li><strong>Hamiltonian Paths:</strong> A Hamiltonian path is a path in an undirected or directed graph that visits each vertex exactly once. Backtracking can be used to find all possible Hamiltonian paths in a graph.<figure id="dec20239-2a86-486d-92bf-8356ba13626e" class="image"><img style="width:2426px" src="Getting%20Started%20with%20Backtracking%20&amp;%20its%20Analysis%203aa41a2ad5d64adc8dafd4777ce27ae9/Screenshot_2023-05-10_at_8.32.57_PM.png"/></a></figure><p id="3f427148-a56f-4ac0-8645-ab59aaeeef5f" class="">To find all Hamiltonian paths in a graph using backtracking, we can use the following algorithm:</p><pre id="fa0f0747-647f-46d5-ba43-943503b9709f" class="code code-wrap"><code>1. Create an empty path array and add the source vertex to it.
2. Initialize an array called visited, set the value of visited[source] to true, and set the count of visited vertices to 1.
3. For each adjacent vertex to the source vertex:
  -If it is not visited, add it to the path array and mark it as visited.
	-Recursively check if this vertex leads to a solution.If it does, add the path to a list of Hamiltonian paths.
	-Remove the vertex from the path and mark it as unvisited.
4. If there are no unvisited adjacent vertices, check if the last vertex in the path array is adjacent to the source vertex.
	-If it is, add the path to a list of Hamiltonian paths.
5. Remove the source vertex from the path array and mark it as unvisited.

Repeat steps 1 - 5 for all other vertices as the source vertex. The final list of Hamiltonian paths will contain all possible Hamiltonian paths in the graph.</code></pre><p id="4b060488-4dce-4922-8734-fbf158384bd0" class="">Note that this algorithm assumes the graph is represented as an adjacency matrix or adjacency list.</p></li></ol><ol type="1" id="c1648f00-6063-401c-8be7-3b0077404dad" class="numbered-list" start="2"><li><strong>N Queen Problem:</strong> The N Queen problem is a classic problem of placing N chess queens on an N×N chessboard so that no two queens threaten each other. Backtracking can be used to find all possible solutions to the N Queen problem.<figure id="9490d077-07ce-4d8c-9233-4c550d276acf" class="image"><img style="width:2404px" src="Getting%20Started%20with%20Backtracking%20&amp;%20its%20Analysis%203aa41a2ad5d64adc8dafd4777ce27ae9/Screenshot_2023-05-10_at_8.34.30_PM.png"/></a></figure><p id="a4a053df-b264-45a6-ae37-0ec209c4ae3f" class="">To solve the N Queen problem using backtracking, you can use the following algorithm:</p><pre id="ed22484e-b6b4-45ef-b3d8-7b6644a95b8f" class="code code-wrap"><code>1. Create an empty chessboard with all squares initialized to 0.
2. Try to place a queen in the first row of the chessboard.
3. If a queen can be placed in a square in the first row without being threatened by any other queens, mark that square as 1 and move to the next row.
4. If a queen cannot be placed in any square in the first row without being threatened, backtrack to the previous row and try to place the queen in a different square.
5. Repeat steps 3 - 4 for each row of the chessboard until all N queens have been placed without being threatened.
6. If a solution is found, add it to a list of solutions.
7. Backtrack to the previous row and try placing the queen in a different square until all possible solutions have been found.
8. Return the list of solutions.</code></pre><p id="b206b03a-c7f6-48cf-9789-f0a679e7a5cb" class="">Note that this algorithm can be optimized by only checking squares threatened by previously placed queens or that threaten previously placed queens.</p></li></ol><ol type="1" id="d7b07841-305c-417e-9cb3-e2458a7f6165" class="numbered-list" start="3"><li><strong>Maze-Solving Problem:</strong> The maze-solving problem involves finding a path through a maze from start to finish. Backtracking can be used to solve this problem.<figure id="11010c20-b39f-4825-af2e-10ba5ae52c2c" class="image"><img style="width:2464px" src="Getting%20Started%20with%20Backtracking%20&amp;%20its%20Analysis%203aa41a2ad5d64adc8dafd4777ce27ae9/Screenshot_2023-05-10_at_8.35.35_PM.png"/></a></figure><p id="b1337984-ee02-44cb-ace6-003050032b5d" class="">To solve a maze using backtracking, you can use the following algorithm:</p><pre id="9efb55e6-fa41-44b6-8de9-173c331da6e5" class="code code-wrap"><code>1. Create a 2 D array to represent the maze, where each element in the array represents a cell in the maze.Each cell should have a boolean value indicating whether it is a wall or a path.
2. Define a function that takes the current position in the maze as input and recursively attempts to find a path to the end of the maze.
3. In the function, mark the current cell as visited.
4. Check if the current cell is the end of the maze.If it is,
  return true.
5. For each adjacent cell to the current cell:
  -If the adjacent cell is a path and has not been visited, call the function recursively with the adjacent cell as the current position.
	-If the recursive call returns true, add the current cell to the path and return true.
6. If no adjacent cells can be visited, mark the current cell as unvisited and return false.

After calling the function with the starting position as input, the final path will be the sequence of cells that were marked as visited during the recursive calls.</code></pre></li></ol><ol type="1" id="8ebeee38-12bc-4acf-bc9c-8e662601df20" class="numbered-list" start="4"><li><strong>Soduko Problem:</strong> The backtracking algorithm can be used to fill in the empty squares of a Sudoku puzzle by trying different numbers until a solution is found. This technique is also used in solving other types of puzzles, such as crossword puzzles and word searches.<figure id="b00b5cd3-9f61-4156-b487-1ed2949c5c28" class="image"><img style="width:2428px" src="Getting%20Started%20with%20Backtracking%20&amp;%20its%20Analysis%203aa41a2ad5d64adc8dafd4777ce27ae9/Screenshot_2023-05-10_at_8.37.23_PM.png"/></a></figure><p id="bba8a5c5-ab31-4f59-bb94-91d63b1df072" class="">To solve a Sudoku puzzle using backtracking, you can use the following algorithm:</p><pre id="3b23e805-52e8-4fd5-a506-af168f08cafa" class="code code-wrap"><code>1. Create a 2 D array to represent the Sudoku grid, where each element in the array represents a cell in the grid.Each cell should have a value between 1 and 9, or 0 if it is empty.
2. Define a function that takes the current position in the grid as input and recursively attempts to fill in the empty cells of the grid.
3. In the function, check if the current cell is empty.If it is not, move to the next cell in the grid.
4. If the current cell is empty, try each possible value between 1 and 9 in the cell until a valid value is found:
  -For each value, check if it is valid by checking if it appears in the same row, column, or 3 x3 subgrid as the current cell.
	-If the value is valid, set the current cell to the value and recursively call the function with the next cell in the grid as input.
	-If the recursive call returns true, the Sudoku puzzle has been solved, so return true.
5. If no valid value can be found for the current cell, backtrack to the previous cell and try a different value.
6. If all values have been tried for the first cell and none of them result in a valid solution, the Sudoku puzzle is unsolvable, so
return false.

After calling the function with the top - left cell as input, the final grid will be the solution to the Sudoku puzzle.</code></pre></li></ol><p id="5f6bf3b3-b187-4929-9665-0bf4fb140956" class="">
</p><h2 id="cbd0c052-93f1-41cb-9f67-dcd34d3ec166" class=""><mark class="highlight-blue"><strong>Activity 1</strong></mark></h2><p id="8068336c-2849-417e-a963-60ce9d426fc7" class=""><strong>Fill in the blanks:</strong></p><ol type="1" id="c8f37210-de00-4608-96d9-9a62339dc5c6" class="numbered-list" start="1"><li>Backtracking is a __________ <strong>(dynamic/greedy/powerful)</strong> algorithmic technique used to solve problems by incrementally exploring all possible solutions.</li></ol><ol type="1" id="56929651-dc9c-4ae0-ac43-08a554116feb" class="numbered-list" start="2"><li>In the N Queen problem, the objective is to place N chess queens on an N×N chessboard so that __________ <strong>(no two queens are in the same row/no two queens are in the same column/no two queens threaten each other).</strong></li></ol><ol type="1" id="dde8be68-f86c-456e-a408-41dc71587afe" class="numbered-list" start="3"><li>A Hamiltonian path is a path in a(n) __________ <strong>(directed/weighted/undirected)</strong> graph that visits each vertex exactly once.</li></ol><ol type="1" id="b0da81f3-71eb-477c-a72a-73874c5ab23c" class="numbered-list" start="4"><li>The backtracking algorithm can be employed to fill in the empty squares of a __________<strong>(Sudoku/Hamiltonian/N-Queen)</strong> puzzle by trying different numbers until a solution is found.</li></ol><ul id="c80fad22-b75f-4702-9cc6-07527cd1cc16" class="toggle"><li><details close=""><summary><strong>Answers</strong></summary><ol type="1" id="597c93f3-c97c-4dbc-84ad-8872c58be5a3" class="numbered-list" start="1"><li>powerful</li></ol><ol type="1" id="17657e11-9083-42d8-a717-3f2d4c6c376b" class="numbered-list" start="2"><li>no two queens threaten each other</li></ol><ol type="1" id="985aa89c-b094-4268-ab77-2e21c26ee011" class="numbered-list" start="3"><li>undirected</li></ol><ol type="1" id="3910f972-fa4f-4fc4-8f18-c98d8db40dba" class="numbered-list" start="4"><li>Sudoku</li></ol></details></li></ul><p id="402ac7b9-cc98-4990-a7ab-ac219db136e1" class="">
</p><h2 id="51da2f2e-5682-4b40-bd9e-c1a3116e35b4" class=""><mark class="highlight-red">Backtracking Complexity Analysis</mark></h2><p id="f7c47c49-ebf1-4d6a-9d3d-57157f82f05b" class="">Analyzing the time and space complexity of a backtracking algorithm involves understanding the number of operations performed and the amount of memory used as the algorithm explores all possible solutions.</p><p id="a9a2736e-832b-4d59-8518-dd2680f70b69" class="">Here&#x27;s a step-by-step guide on how to analyze the time and space complexity of a backtracking algorithm:</p><ol type="1" id="a7e76ccb-8cbc-409e-8062-a7d5496a39a6" class="numbered-list" start="1"><li><strong>Identify the Decision Space:</strong> Determine the size of the problem space and the number of decisions to be made at each step. This will help in understanding the dimensions of the analysis.</li></ol><ol type="1" id="eb1f6ea1-dea9-4ef1-9142-9c7c197edb12" class="numbered-list" start="2"><li><strong>Determine the Recurrence Relation: </strong>Identify the recursive nature of the backtracking algorithm. Look for recursive calls and understand how they contribute to the exploration of the decision space.</li></ol><ol type="1" id="5b6b637c-b4bb-4970-90a9-534f301a3aa9" class="numbered-list" start="3"><li><strong>Count the Operations:</strong> Analyze the number of operations performed at each step of the algorithm, including comparisons, computations, and any other significant actions. This helps in understanding the time complexity of the algorithm.</li></ol><ol type="1" id="81ca44f5-b7e7-41be-96c8-0a0eb524cf87" class="numbered-list" start="4"><li><strong>Calculate the Total Number of Operations:</strong> Determine the total operations performed by summing up the operations at each step. Express this count as a function of the input size to establish the time complexity.</li></ol><ol type="1" id="b9252db2-523e-4ea9-8dc9-ef72bfca7b61" class="numbered-list" start="5"><li><strong>Consider the Worst Case:</strong> Identify the scenario that would result in the maximum number of operations. This helps in determining the worst-case time complexity, which provides an upper bound on the algorithm&#x27;s performance.</li></ol><ol type="1" id="136b08f0-c559-4e54-a694-d4a793a39a5c" class="numbered-list" start="6"><li><strong>Analyze Space Usage:</strong> Consider the memory used by the algorithm, including variables, data structures, and the recursion stack. Identify the maximum space required during the algorithm&#x27;s execution.</li></ol><ol type="1" id="ef4bcd5e-1595-43a1-bad4-ee56d7ef098a" class="numbered-list" start="7"><li><strong>Express Space Complexity</strong>: Express the space used as a function of the input size, and analyze the space complexity of the algorithm.</li></ol><ol type="1" id="2f0f360a-1f11-4cb6-8ba7-a2463eabc9df" class="numbered-list" start="8"><li><strong>Consider Output Space:</strong> If the algorithm produces an output, consider the space required to store the output and factor it into the space complexity analysis.</li></ol><ol type="1" id="f3355231-aeda-4900-9b32-e511973108d6" class="numbered-list" start="9"><li><strong>Simplify and Express Complexity:</strong> Simplify the expressions for time and space complexity to their dominant terms, discarding lower-order terms and constants. Express the complexity using big O notation.</li></ol><ol type="1" id="52ca6a76-d2b8-41f5-a123-38d578aa85c5" class="numbered-list" start="10"><li><strong>Validate the Analysis:</strong> Test the algorithm with different input sizes and compare the observed running time and memory usage with the predicted time and space complexity to validate the analysis.</li></ol><p id="9356ce7f-d912-488e-8795-2646117ab754" class="">
</p><p id="2bead062-437a-4039-9426-bd976f83007c" class="">Consider a simple example of backtracking in JavaScript, specifically solving the N-Queens problem. The N-Queens problem involves placing N queens on an N×N chessboard such that no two queens threaten each other. </p><pre id="b2fb9f48-c0c7-41cb-8610-d0c810553529" class="code"><code>function solveNQueens(n) {
  const result = [];
  const board = Array.from(Array(n), () =&gt; Array(n).fill(&#x27;.&#x27;));

  function isSafe(row, col) {
    // Check if there&#x27;s a queen in the same column
    for (let i = 0; i &lt; row; i++) {
      if (board[i][col] === &#x27;Q&#x27;) {
        return false;
      }
    }

    // Check upper left diagonal
    for (let i = row, j = col; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {
      if (board[i][j] === &#x27;Q&#x27;) {
        return false;
      }
    }

    // Check upper right diagonal
    for (let i = row, j = col; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) {
      if (board[i][j] === &#x27;Q&#x27;) {
        return false;
      }
    }

    return true;
  }

  function backtrack(row) {
    if (row === n) {
      result.push([...board.map(row =&gt; row.join(&#x27;&#x27;))]);
      return;
    }

    for (let col = 0; col &lt; n; col++) {
      if (isSafe(row, col)) {
        board[row][col] = &#x27;Q&#x27;;
        backtrack(row + 1);
        board[row][col] = &#x27;.&#x27;;
      }
    }
  }

  backtrack(0);
  return result;
}

// Example usage:
console.log(solveNQueens(4));</code></pre><p id="b22981bb-457d-4c89-9e90-288b54c26d10" class=""><strong>Time Complexity:</strong></p><ul id="7267b98b-8141-4c9c-83fd-0e2c64d314df" class="bulleted-list"><li style="list-style-type:disc">The backtracking algorithm explores all possible combinations of queen placements on the chessboard.</li></ul><ul id="9aa48696-7f53-4137-880e-59854579eb8d" class="bulleted-list"><li style="list-style-type:disc">For each row, we try all possible column positions, resulting in N choices for the first row, N-1 choices for the second row, and so on.</li></ul><ul id="0e58958d-20aa-413b-8950-b8c449c140b1" class="bulleted-list"><li style="list-style-type:disc">As a result, the total number of recursive calls made by the algorithm is approximately <code>N * (N-1) * (N-2) * ... * 1</code>, which simplifies to N! (factorial).</li></ul><ul id="b02682dd-a1f7-4c55-a302-3fc6ab57b6f5" class="bulleted-list"><li style="list-style-type:disc">Therefore, the time complexity of the algorithm is <code>O(N!)</code>.</li></ul><p id="0efe931e-0452-4453-9cd2-12967417fb6f" class=""><strong>Space Complexity:</strong></p><ul id="46c492dd-2ff5-4bca-a2cb-72bbcff4fb44" class="bulleted-list"><li style="list-style-type:disc">The space complexity is determined by the auxiliary data structures used and the recursion stack.</li></ul><ul id="f2a0361c-b487-41fd-b6c4-56ae2f02c773" class="bulleted-list"><li style="list-style-type:disc">The <code>result</code> array stores all valid solutions, which can have a maximum size of N!, contributing to the space complexity.</li></ul><ul id="ca10cdee-da99-4e1b-83e2-e5a6041680f6" class="bulleted-list"><li style="list-style-type:disc">The <code>board</code> array is a 2D grid representing the state of the chessboard, which requires <code>O(N^2)</code> space.</li></ul><ul id="7e9b4bab-3b83-4857-ace9-67bd6233c15e" class="bulleted-list"><li style="list-style-type:disc">The recursion stack depth corresponds to the number of rows, which can be at most N.</li></ul><ul id="a4fcbf22-bf3d-4432-a507-539103d84017" class="bulleted-list"><li style="list-style-type:disc">Therefore, the space complexity of the algorithm is <code>O(N^2 + N)</code>, which simplifies to <code>O(N^2)</code>.</li></ul><p id="4e411ca1-3352-46b4-af6e-e5ff3b36f85e" class="">
</p><p id="9bcaad60-65ca-4244-8a2b-5b8a8797dcab" class="">In the case of the N-Queens problem, the backtracking algorithm explores all possible solutions, resulting in a factorial time complexity. However, through various optimizations, such as early pruning, the actual execution time can be significantly reduced.</p><p id="d00a9e73-abdd-4913-8d02-99a16637e719" class="">
</p><h2 id="4d04aeb3-019f-4a70-bcd6-95dfd4a838ab" class=""><mark class="highlight-blue">Explore Further</mark></h2><p id="cee5eb33-788d-42d7-a8e1-4ed0a1517285" class=""><mark class="highlight-orange"><strong>Uncover and unlock new insights as you dive into the captivating content found in the provided link.</strong></mark></p><p id="c7a3629f-df4b-42fa-b7b7-c9dc8df63202" class=""><strong>The Knight&#x27;s Tour Problem: </strong><a href="https://www.javascriptbro.com/2020/03/knights-tour.html">https://www.javascriptbro.com/2020/03/knights-tour.html</a></p><p id="e1ccd64d-b00f-44d1-97fc-ee774d40d888" class="">
</p><p id="fcf3941e-dec9-4160-a409-07bf9b6573f6" class=""><mark class="highlight-orange"><strong>Let&#x27;s play a game to understand it further!</strong></mark></p><ol type="1" id="a93c64b1-4e55-4146-91f1-e34bf59abdf0" class="numbered-list" start="1"><li><strong>Game setup:</strong><ul id="9315f9d2-8472-45af-a749-6b732d9cb767" class="bulleted-list"><li style="list-style-type:disc">Place the chessboard in front of the player.</li></ul><ul id="54dfde51-08cb-4c58-a0ac-816578009738" class="bulleted-list"><li style="list-style-type:disc">Choose any square on the chessboard to represent the starting position of the knight.</li></ul><ul id="ad50ca8a-f3ca-4787-a8af-f50b1b453161" class="bulleted-list"><li style="list-style-type:disc">Place the marker or token on the chosen square to represent the knight.</li></ul></li></ol><ol type="1" id="83091c13-6c7c-4579-a2ca-2f379e55c207" class="numbered-list" start="2"><li><strong>Game rules:</strong><ul id="137f5c02-21b3-47d2-b0a3-3ad7e47c3d93" class="bulleted-list"><li style="list-style-type:disc">Explain the movement rules for the knight:<ul id="3c775cc1-3fc6-4565-ae0e-f822dc219eb8" class="bulleted-list"><li style="list-style-type:circle">The knight moves in an &quot;L&quot; shape, two squares in one direction (horizontally or vertically) and one square in the perpendicular direction.</li></ul><ul id="c5653f0b-06fc-4a74-acd8-a867564eafa2" class="bulleted-list"><li style="list-style-type:circle">The knight cannot move off the chessboard or visit a square more than once.</li></ul></li></ul></li></ol><ol type="1" id="22ab9d21-6b6b-48ae-816d-bb7018b29451" class="numbered-list" start="3"><li><strong>Player&#x27;s turn:</strong><ul id="a362033f-c682-4148-86ec-b1c779c3987a" class="bulleted-list"><li style="list-style-type:disc">The player takes turns moving the knight on the chessboard.</li></ul><ul id="04d0a5c8-fbef-43c5-b44a-735c89c20b20" class="bulleted-list"><li style="list-style-type:disc">Start by selecting a valid move for the knight based on the movement rules.</li></ul><ul id="d847fa1e-7648-4da5-a594-dd39ff48ae0d" class="bulleted-list"><li style="list-style-type:disc">Move the marker or token to the selected square, representing the knight&#x27;s new position.</li></ul><ul id="cbaad7a1-e4cc-48fc-a620-48e2a5ccae5d" class="bulleted-list"><li style="list-style-type:disc">Repeat this process, selecting valid moves and moving the knight until every square on the chessboard has been visited exactly once.</li></ul></li></ol><ol type="1" id="d56d43dc-8a5e-4516-a7bb-630f970007a8" class="numbered-list" start="4"><li><strong>Game completion:</strong><ul id="0161554e-1dcf-4219-8800-25bc8a2994ea" class="bulleted-list"><li style="list-style-type:disc">The game is considered complete when the knight has visited every square on the chessboard exactly once.</li></ul><ul id="31176cad-1d0a-49f5-a1b4-9d416adbc289" class="bulleted-list"><li style="list-style-type:disc">Celebrate the player&#x27;s achievement upon completing the Knight&#x27;s Tour!</li></ul></li></ol><p id="c882a7e7-7ba3-47af-ad70-edbfd472c702" class="">
</p><h1 id="cc69cc7e-65ff-4176-9db2-9a46cdb04745" class=""><mark class="highlight-brown">Summary</mark></h1><h2 id="9fea354f-2f91-4577-9c0f-fe6abaf5a731" class="block-color-default"><mark class="highlight-red">What did we learn?</mark></h2><ul id="840cad83-99b6-47f1-9b72-18fa9a79c650" class="bulleted-list"><li style="list-style-type:disc">Backtracking is a method used in programming that involves trying out all possible solutions to a problem and selecting the best one.</li></ul><ul id="5f7fad90-7e9f-433c-8698-b98b8eff2184" class="bulleted-list"><li style="list-style-type:disc">This method is useful for solving problems that have a large number of potential solutions or when the optimal solution is difficult to find.</li></ul><ul id="49337377-04a5-40f7-a60c-79339aa9f91b" class="bulleted-list"><li style="list-style-type:disc">In JavaScript, backtracking can be implemented using recursion.</li></ul><ul id="1c31d854-07ef-4bd7-bd73-c7c84a78a5d9" class="bulleted-list"><li style="list-style-type:disc">Some common examples of problems that can be solved using backtracking in JavaScript include the N-Queens problem and the Sudoku puzzle.</li></ul><ul id="d814d0de-4759-460e-8029-5ab3b533917f" class="bulleted-list"><li style="list-style-type:disc">For <strong>backtracking algorithms</strong>, the time complexity is typically mentioned as <strong>O(2^n)</strong>, which means that the time taken by the algorithm increases exponentially with the size of the input problem.</li></ul><ul id="6c7b120c-e0cd-441a-ae97-ff23bfc15d55" class="bulleted-list"><li style="list-style-type:disc">The space complexity is usually mentioned as <strong>O(n)</strong>, which means that the amount of memory or storage space required by the algorithm grows linearly with the size of the input problem.</li></ul><ul id="1705ff6b-815b-497b-992d-9a0a110276d0" class="bulleted-list"><li style="list-style-type:disc">It is important to note that while time complexity and space complexity are crucial factors in analyzing the efficiency of an algorithm, there is often a trade-off between time and space. In some cases, reducing the time complexity may increase the space complexity and vice versa.</li></ul><h2 id="f9e48a7d-6cce-4f51-9a57-1ba0874adafc" class="block-color-default"><mark class="highlight-red">Shortcomings &amp; Challenges</mark></h2><ul id="bed70c67-0585-45a4-b7c8-932fe19a4c60" class="bulleted-list"><li style="list-style-type:disc">Backtracking can be a computationally expensive technique, especially for problems with a large search space. As a result, it may not be practical to use backtracking for certain problems that require faster solutions.</li></ul><ul id="3a2ecfeb-9d52-4a45-80b3-accecbc827e0" class="bulleted-list"><li style="list-style-type:disc">Backtracking algorithms can require a lot of memory, especially if the search space is large. This can be a challenge for applications that have limited memory available.</li></ul><ul id="96689f6f-b846-4586-a98f-9932111615fc" class="bulleted-list"><li style="list-style-type:disc">The worst-case time and space complexity may only sometimes be encountered in practice.</li></ul><ul id="64ef28c1-7c83-43de-a165-f94a07cdf117" class="bulleted-list"><li style="list-style-type:disc">Variations in the algorithm&#x27;s performance may occur depending on the characteristics of the input data.</li></ul><ul id="a536625f-7ff5-4bf3-b2a2-63ea7cef9872" class="bulleted-list"><li style="list-style-type:disc">The analysis may need to consider the overhead associated with implementing the algorithm.</li></ul><ul id="1cbad532-702c-4b8e-aa2d-f8b680900747" class="bulleted-list"><li style="list-style-type:disc">The analysis may need to reflect the algorithm&#x27;s actual performance in practice accurately.</li></ul><h2 id="9d3daffa-ee02-4dee-acb1-57c29683e50e" class="block-color-default"><mark class="highlight-red">Best Practices</mark></h2><ul id="36d6e114-1de1-4581-8e25-fc8637fc3e97" class="bulleted-list"><li style="list-style-type:disc">It&#x27;s important to define clear constraints and limitations for the problem you&#x27;re trying to solve before implementing backtracking. This can help you avoid wasting time exploring invalid solutions.</li></ul><ul id="216042ad-0843-449f-be9a-08df927bf71e" class="bulleted-list"><li style="list-style-type:disc">Backtracking algorithms can be difficult to debug, so it&#x27;s important to thoroughly test your implementation before deploying it in production.</li></ul><ul id="abc9b9e9-99dd-40f0-b16e-7181eaf11c2c" class="bulleted-list"><li style="list-style-type:disc">Use empirical testing and benchmarking to validate the theoretical analysis and gain insight into the algorithm&#x27;s performance.</li></ul><ul id="f52efdff-db10-4d43-9166-67d6abf3cab4" class="bulleted-list"><li style="list-style-type:disc">Optimize the algorithm&#x27;s performance using effective pruning techniques and heuristics to reduce the search space and guide the search.</li></ul><ul id="ad0b29e6-7560-4d53-a604-2ab1149569d5" class="bulleted-list"><li style="list-style-type:disc">Be aware of the trade-offs between time and space complexity and strive to find a balance that meets the requirements of the problem being solved.</li></ul><h2 id="7b6cb041-d3d3-403d-b6b5-f7d1b8669751" class="block-color-default"><mark class="highlight-red">Enhance your knowledge</mark></h2><ul id="2227dbe1-a88b-4065-b13d-8c83cfbcf12e" class="bulleted-list"><li style="list-style-type:disc"><a href="https://medium.com/coders-mojo/day-5-of-30-days-of-data-structures-and-algorithms-and-system-design-simplified-backtracking-f7de93dbe72d">https://medium.com/coders-mojo/day-5-of-30-days-of-data-structures-and-algorithms-and-system-design-simplified-backtracking-f7de93dbe72d</a></li></ul><ul id="239a75a2-e8c6-4eea-8e9f-c7ecddd2ffcf" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.cs.upc.edu/~mjserna/docencia/grauA/T22/7-A-GEI-backtrack.pdf">https://www.cs.upc.edu/~mjserna/docencia/grauA/T22/7-A-GEI-backtrack.pdf</a></li></ul><p id="d5e1024c-dfa1-4964-898c-1fb48a4747bb" class="">
</p><p id="bb37715c-8201-46a9-82fc-88fa4672b7ab" class="">
</p></div></article></body></html>
