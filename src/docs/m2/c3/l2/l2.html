<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Advanced Recursion Coding &amp; Analysis</title><link rel="stylesheet" href="../../../../../styles.css"></head><body><article id="aae23acb-3422-475c-8623-68bb9bb9dc6f" class="page sans"><header><h1 class="page-title">Advanced Recursion Coding &amp; Analysis</h1><p class="page-description"></p></header><div class="page-body"><ul id="7f874c08-2aec-4733-80aa-5bd4aeda3c42" class="toggle"><li><details close=""><summary><strong>Session Flow </strong></summary><ul id="1dc3ab06-6fc4-488c-91ca-e02411e2353c" class="bulleted-list"><li style="list-style-type:disc"><strong>Learning Objective</strong><ul id="ae585621-18fd-404a-8771-3770dfd4e556" class="bulleted-list"><li style="list-style-type:circle">Introduction</li></ul><ul id="50312720-2d50-4840-aacb-ea1d1d5efbd4" class="bulleted-list"><li style="list-style-type:circle">Theme</li></ul><ul id="0696e259-9850-4731-aacb-31bd8e778e1f" class="bulleted-list"><li style="list-style-type:circle">Primary Goals</li></ul></li></ul><ul id="08672106-1a86-4ae6-83da-c5ffa537bfc0" class="bulleted-list"><li style="list-style-type:disc"><strong>Advanced Recursion Coding &amp; Analysis </strong><ul id="ad3d252f-239c-4f4a-8e82-ab5a36b3f282" class="bulleted-list"><li style="list-style-type:circle">Find the First Occurrence of an Element in an Array </li></ul><ul id="873fe80a-7760-4a5c-8cda-63ce2471c767" class="bulleted-list"><li style="list-style-type:circle">Check if Two Strings are Anagrams </li></ul><ul id="ae73667b-784d-49ad-87fd-c07fbf4f7ecd" class="bulleted-list"><li style="list-style-type:circle">Remove Duplicates from an Array</li></ul><ul id="fc9a3002-2e0c-41f4-b690-08521fab1b75" class="bulleted-list"><li style="list-style-type:circle">Reverse a String </li></ul><ul id="bee02741-85b0-4bcd-95ae-5fef8f52bb1e" class="bulleted-list"><li style="list-style-type:circle">Power Function </li></ul><ul id="56d13288-6558-4d9d-9c97-f70f16fe18fa" class="bulleted-list"><li style="list-style-type:circle">The sum of Array Elements</li></ul><ul id="462c8d92-5d7a-49b1-9163-8d3a7b1a63e3" class="bulleted-list"><li style="list-style-type:circle">Factorial </li></ul><ul id="660a26ed-dff7-43c2-99f3-87353ec6d8ad" class="bulleted-list"><li style="list-style-type:circle">Fibonacci Sequence </li></ul><ul id="850448e5-cba2-4015-9268-113e49ef18ec" class="bulleted-list"><li style="list-style-type:circle">Given an array of integers sorted in non-decreasing order, return an array of the squares of each number in non-decreasing order. </li></ul><ul id="9a3560bd-9e9a-4233-816c-d6942dbfb3cb" class="bulleted-list"><li style="list-style-type:circle">Given an unsorted array of integers and an integer k, find the kth largest element in the array. </li></ul><ul id="83bd6ccb-406a-4b41-b828-aa2732dbb769" class="bulleted-list"><li style="list-style-type:circle">Given two integer arrays nums1 and nums2, return an array of their intersection. The intersection is the set of elements that appear in both arrays, in any order. </li></ul><ul id="24dd4b64-c926-4ae3-a854-f0fd96f1d888" class="bulleted-list"><li style="list-style-type:circle">Given an array of intervals where intervals[i] = [starti, endi], merge overlapping intervals and return the merged intervals in sorted order. </li></ul><ul id="acb01f42-716d-41c5-8502-6c8c64583481" class="bulleted-list"><li style="list-style-type:circle"><strong>Take Home Assignment</strong></li></ul></li></ul></details></li></ul><h1 id="962baa19-ba6a-4bc4-a720-a4eba86433bb" class=""><mark class="highlight-brown">Learning Objective</mark></h1><h2 id="f9a14305-9dc0-4482-b3ed-0b1dd97ebf50" class="block-color-default"><mark class="highlight-red">Introduction</mark></h2><p id="0c03d92a-e74c-4a36-abed-4e9505d61dd0" class="">Time and Space Complexity Analysis of codes is like a puzzle game for algorithms. By understanding time and space complexity analysis, we can create faster and more efficient algorithms, saving precious time and resources in the process.</p><p id="8ebeaf5d-d531-402e-8cf4-067710608230" class=""><strong>Focus:</strong> Traditional and Optimized Solutions along with the Time and Space complexity for the given code</p><p id="deee74ce-bad2-44c3-94a0-7177544b00da" class=""><strong>Prerequisites</strong>: JavaScript with Basic DSA</p><h2 id="f3d238e1-ecae-44fe-9a9f-17af86a19e03" class="block-color-default"><mark class="highlight-red">Theme</mark></h2><p id="17b3b135-dd2e-4cab-b212-eee6a1ce9fe4" class=""><strong>Pixar Animation Studios</strong> is a company in<strong> </strong>the<strong> </strong>field of computer graphics and animation. Pixar is known for its visually stunning animated films, often featuring complex 3D graphics and animations. To create these graphics, animators use sophisticated algorithms and techniques, including advanced recursion.</p><p id="e38a7e01-b4f4-4f29-bd9a-bffe9079c505" class="">For example, a Pixar animator may need to create a complex 3D model of a character or object, which requires breaking the model into smaller, more manageable parts. Advanced recursion in JavaScript can be used to generate these smaller parts and then recursively assemble them into a larger, more complex model.</p><p id="bbb70aab-0b6f-4605-b99c-0222aa8c0f78" class="">Additionally, advanced recursion can be used to optimize the rendering of these 3D models, ensuring that they are rendered quickly and efficiently on screen. This process involves recursively traversing the model and rendering each component, then recursively assembling them into the final image.</p><p id="c75b8965-7376-4f51-8d04-3e82716a73b5" class="">Using advanced recursion in JavaScript, Pixar can create visually stunning and complex animations with greater ease and efficiency, leading to higher-quality productions and more engaged audiences.</p><h2 id="4b8b40cd-b7da-49c8-aea1-c3a109c7099f" class="block-color-default"><mark class="highlight-red">Primary Goals</mark></h2><ul id="2ec5934e-56f9-438b-afaa-c7d90ed5cff8" class="bulleted-list"><li style="list-style-type:disc">Understand the basics of time and space complexity analysis and how it applies to pattern algorithms.</li></ul><ul id="ce788f96-2fb7-4e77-a0d0-da0c0a932eb8" class="bulleted-list"><li style="list-style-type:disc">Learn how to analyze the time and space complexity.</li></ul><ul id="ce6a3cb5-6394-4a3c-88c3-24a2ada007bf" class="bulleted-list"><li style="list-style-type:disc">Understand how the choice of algorithm and data structure can impact the performance of a program.</li></ul><p id="33e32701-41f9-4fef-88b3-dfbef1160d3f" class="">
</p><h1 id="83117c37-d01a-40b5-9065-959b2d5aaaa0" class=""><mark class="highlight-brown"><strong>Advanced Coding &amp; Analysis</strong></mark></h1><p id="a91d4335-7856-493b-b32a-2d41d48d66ef" class="">The optimized solution typically reduces unnecessary operations, resulting in improved time and space efficiency. By understanding the optimized approach, you can develop more efficient algorithms and solutions for pattern-matching tasks, leading to faster execution and better resource utilization.</p><p id="a6ec7508-2b1b-420f-ad57-67d03c2091b2" class="">Analyzing and comprehending optimized solutions helps improve your problem-solving skills. You gain insights into algorithmic optimizations, such as loop optimizations, early termination, or skipping unnecessary comparisons.</p><p id="e5c93643-e904-4e50-ac16-7b6a94b444f7" class="">
</p><ol type="1" id="b415b52c-9123-4f8b-8ff6-16e1720e595d" class="numbered-list" start="1"><li><strong>Find the First Occurrence of an Element in an Array</strong><ul id="ef5dc538-8c6e-47bf-88ee-9cab491207b3" class="toggle"><li><details close=""><summary><strong>Traditional Solution</strong></summary><p id="d415a97e-de53-4fb3-8cd2-89465de39d53" class="">Time Complexity: O(n)</p><p id="bd43dfee-6948-4cc8-8c76-77d86aab3fa2" class="">Space Complexity: O(1)</p><pre id="1366a98a-62f0-4c5d-a9a8-b844881abde8" class="code"><code>function findFirstOccurrence(arr, target) {
  for (let i = 0; i &lt; arr.length; i++) {
    if (arr[i] === target) {
      return i;
    }
  }
  return -1;
}

const arr = [2, 4, 6, 6, 6, 8, 10];
const target = 6;

console.log(findFirstOccurrence(arr, target));  // Output: 2</code></pre><p id="9790fab8-2f91-42f9-9ae4-0d7cb2f85f28" class="">
</p></details></li></ul><ul id="ef4b54fa-2050-4285-9caf-0ec8c6cbae96" class="toggle"><li><details close=""><summary><strong>Optimized Solution</strong></summary><p id="685c07ab-76e0-411d-9891-2c7cd6b802a8" class="">Time Complexity: O(log n) </p><p id="a8127c8e-d259-43ce-a534-f4d0e32b18eb" class="">Space Complexity: O(1)</p><p id="c4ab2e55-5674-474b-a831-bf624e75bda2" class="">The optimized solution uses binary search to find the first occurrence of the target element in a sorted array. It compares the middle element of the array with the target and adjusts the search range accordingly. The condition <code>(mid === 0 || arr[mid - 1] !== target)</code> checks if the current mid index is the first occurrence of the target element.</p><pre id="b50bccea-6c22-43d5-8546-1d4995fd8f2e" class="code"><code>function findFirstOccurrence(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left &lt;= right) {
    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === target &amp;&amp; (mid === 0 || arr[mid - 1] !== target)) {
      return mid;
    } else if (arr[mid] &lt; target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

const arr = [2, 4, 6, 6, 6, 8, 10];
const target = 6;

console.log(findFirstOccurrence(arr, target));  // Output: 2</code></pre><p id="a2b7bacf-2119-4214-ae1a-ff449d54c60e" class="">
</p></details></li></ul><p id="db381e8e-af61-43a8-a73a-7e427a4dd894" class="">
</p></li></ol><ol type="1" id="36c1a25a-8e5e-4de3-997a-2a5a73ce9eaa" class="numbered-list" start="2"><li><strong>Check if Two Strings are Anagrams</strong><ul id="dc5ece30-704f-4977-a93f-af074932d22a" class="toggle"><li><details close=""><summary><strong>Traditional Solution</strong></summary><p id="fb5564bf-7297-4949-9051-0b8f870a0f33" class="">Time Complexity: O(n log n) </p><p id="6f8cd218-73d0-46ca-828b-191d7370ff9d" class="">Space Complexity: O(n)</p><pre id="74dda7c9-df3b-4969-a102-55a4c183f683" class="code"><code>function areAnagrams(str1, str2) {
  if (str1.length !== str2.length) {
    return false;
  }

  const sortedStr1 = str1.split(&#x27;&#x27;).sort().join(&#x27;&#x27;);
  const sortedStr2 = str2.split(&#x27;&#x27;).sort().join(&#x27;&#x27;);

  return sortedStr1 === sortedStr2;
}
const str1 = &quot;listen&quot;;
const str2 = &quot;silent&quot;;

console.log(areAnagrams(str1, str2));  // Output: true</code></pre></details></li></ul><ul id="eaab2612-07ef-4517-b592-daaeb7dd9a98" class="toggle"><li><details close=""><summary><strong>Optimized Solution</strong></summary><p id="5e254c24-1173-4317-93de-b7dabc49564e" class=""> Time Complexity: O(n) - Linear time complexity</p><p id="48279ee0-b6c8-4e6f-ab6f-539af75c5bb3" class="">Space Complexity: O(n) - Linear space complexity</p><p id="250cb3a9-d55e-4adc-902c-acfaefe4ec4c" class="">The optimized solution uses a character count object to keep track of the frequency of characters in <code>str1</code>. It then iterates through <code>str2</code> and checks if each character exists in the count object. If a character is found, its count is decremented. If a character is not found or its count becomes negative, the strings are not anagrams.</p><pre id="014daa21-dacd-45bb-9d0a-41ab83c2ebc6" class="code"><code>function areAnagrams(str1, str2) {
  if (str1.length !== str2.length) {
    return false;
  }

  const charCount = {};

  for (let char of str1) {
    charCount[char] = (charCount[char] || 0) + 1;
  }

  for (let char of str2) {
    if (!charCount[char]) {
      return false;
    }
    charCount[char]--;
  }

  return true;
}
const str1 = &quot;listen&quot;;
const str2 = &quot;silent&quot;;

console.log(areAnagrams(str1, str2));  // Output: true</code></pre></details></li></ul><p id="086ee71e-93f1-4cc0-94f9-17da4f182d64" class="">
</p></li></ol><ol type="1" id="ff321e00-96ba-40ea-8a7e-9e098fbd3dca" class="numbered-list" start="3"><li><strong>Remove Duplicates from an Array</strong><ul id="71d857fa-54df-47a7-a9c4-5b9db9374346" class="toggle"><li><details close=""><summary><strong>Traditional Solution</strong></summary><p id="4c35a8a0-ecc7-4e8a-84d5-927c41ee16f2" class="">Time Complexity: O(n^2) </p><p id="2714544f-5e06-4389-a8fd-55ddc74b7f5f" class="">Space Complexity: O(n) </p><pre id="0a425957-0e9d-4e2a-9bfb-d88695a9f41d" class="code"><code>function removeDuplicates(arr) {
  const uniqueArr = [];
  for (let i = 0; i &lt; arr.length; i++) {
    if (!uniqueArr.includes(arr[i])) {
      uniqueArr.push(arr[i]);
    }
  }
  return uniqueArr;
}
const arr = [1, 2, 3, 2, 4, 1, 5];
console.log(removeDuplicates(arr));  // Output: [1, 2, 3, 4, 5]</code></pre></details></li></ul><ul id="3ea81729-b34d-4917-81e1-5b651b15ce42" class="toggle"><li><details close=""><summary><strong>Optimized Solution</strong></summary><p id="1a8bce07-d7f3-4fa7-a284-d54027a49d5c" class="">Time Complexity: O(n) </p><p id="0342db2b-92c7-4be7-9490-e44c80f8694b" class="">Space Complexity: O(n) </p><p id="3d09bdcc-865f-4e81-9a61-ca2b5907a223" class="">The optimized solution utilizes a <code>Set</code> data structure to remove duplicate elements from the array. The spread operator (<code>...</code>) converts the Set back into an array.</p><pre id="4da29140-2ef4-478f-a1aa-2c2ecfd1b6a9" class="code"><code>function removeDuplicates(arr) {
  const uniqueArr = [...new Set(arr)];
  return uniqueArr;
}
const arr = [1, 2, 3, 2, 4, 1, 5];
console.log(removeDuplicates(arr));  // Output: [1, 2, 3, 4, 5]</code></pre></details></li></ul><p id="ce062861-1367-4ed3-bf34-71db1273bd6b" class="">
</p></li></ol><ol type="1" id="21feff05-c8df-40f2-bba0-5cceeb444440" class="numbered-list" start="4"><li><strong>Reverse a String</strong><ul id="801b26a7-8d2c-456d-8a09-9f70d69f8de1" class="toggle"><li><details close=""><summary><strong>Traditional Solution</strong></summary><p id="ee9cd36e-0fa0-4195-bf94-0ab0aed179da" class="">Time Complexity: O(n) </p><p id="a7ca24e7-bd99-4b26-8f57-bbc051fd3eb9" class="">Space Complexity: O(n)</p><pre id="a2666efc-aa16-4f45-9a4d-80bbd70f275c" class="code"><code>function reverseString(str) {
  let reversed = &#x27;&#x27;;
  for (let i = str.length - 1; i &gt;= 0; i--) {
    reversed += str[i];
  }
  return reversed;
}
function reverseString(str) {
  return str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);
}</code></pre></details></li></ul><ul id="493c6eb5-3c30-4719-966e-93225623fc07" class="toggle"><li><details close=""><summary><strong>Optimized Solution</strong></summary><p id="1cf06dfe-a5e8-4d30-ae62-38064582b257" class="">Time Complexity: O(n) </p><p id="6bfd1d30-92c7-4ee8-ab68-847ef4fe992e" class="">Space Complexity: O(n)</p><p id="9b894c91-f6da-4c26-9500-da6f6a604b24" class="">The optimized solution splits the string into an array of characters, reverses the array using the <code><strong>reverse()</strong></code> method, and joins the characters back into a string. This approach provides a more concise and efficient way to reverse the given string.</p><pre id="50deeb1c-6409-422e-84ad-a05000a15b49" class="code"><code>function reverseString(str) {
  return str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);
}
function reverseString(str) {
  return str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);
}</code></pre></details></li></ul><p id="ee61f1bf-45de-48de-89c5-a01daa026127" class="">
</p></li></ol><ol type="1" id="58d388b9-2848-48bf-8908-5f408bf795f9" class="numbered-list" start="5"><li><strong>Fibonacci Sequence</strong><ul id="b46c0c4c-d433-4606-be7e-80d30f3b2f13" class="toggle"><li><details close=""><summary><strong>Traditional Solution</strong></summary><p id="0c2c745c-0a83-491a-aa02-e1f14dfddb87" class="">Time complexity: O(2^n) </p><p id="1a8d3acd-8e1e-420e-87b7-82c548e05c70" class="">Space complexity: O(n)</p><pre id="3494b487-3bbb-4fe6-a96a-dc9756746634" class="code"><code>function fibonacci(n) {
  if (n &lt;= 1) {
    return n;
  }
  
  return fibonacci(n - 1) + fibonacci(n - 2);
}
console.log(fibonacci(6));
// Output: 8</code></pre></details></li></ul><ul id="9eb90045-e078-4f2a-9ddb-eb21c9cff852" class="toggle"><li><details close=""><summary><strong>Optimized Solution</strong></summary><p id="88544d6a-d6d3-49ef-87e9-c1edb29c38d8" class="">Time complexity: O(n) - The optimized solution has a linear time complexity since it avoids redundant recursive calls by storing intermediate results in a memoization table.</p><p id="7a2557be-2134-440c-bbb1-20ce46b0eb2d" class="">Space complexity: O(n) - The space complexity is linear as it depends on the maximum recursion depth, which is equal to <code><strong>n</strong></code>. Additionally, the memoization table uses extra space.</p><pre id="76f51e14-1184-4969-8f87-12e0630c16d6" class="code"><code>function fibonacci(n, memo = {}) {
  if (n &lt;= 1) {
    return n;
  }
  
  if (memo[n]) {
    return memo[n];
  }
  
  memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);
  return memo[n];
}
console.log(fibonacci(6));
// Output: 8</code></pre></details></li></ul><p id="7660ec18-d6d0-4749-aae2-61577b69863c" class="">
</p></li></ol><ol type="1" id="4bccb1b7-9281-4fc0-9d36-e6ade509a7a6" class="numbered-list" start="6"><li><strong>Factorial</strong><ul id="0d0460c9-b242-4d9c-b003-8b0828329355" class="toggle"><li><details close=""><summary><strong>Traditional Solution</strong></summary><p id="c6f52689-4c64-4460-a712-f22f3862edb7" class="">Time complexity: O(n) </p><p id="a88ee656-7cbe-48ff-a78f-ff1fe80fe2ba" class="">Space complexity: O(n) </p><pre id="33de247f-5275-47c0-86dd-e91ae46c4b2b" class="code"><code>function factorial(n) {
  if (n === 0) {
    return 1;
  }
  
  return n * factorial(n - 1);
}
console.log(factorial(5));
// Output: 120</code></pre></details></li></ul><ul id="d964edad-8dd1-44f3-beaa-137a9b3b865d" class="toggle"><li><details close=""><summary><strong>Optimized Solution</strong></summary><p id="4b8d7917-0cf9-4cf6-b428-4db0d439cba5" class="">Time complexity: O(n) - The optimized solution has a linear time complexity since it avoids redundant recursive calls and accumulates the factorial result in each recursive step.</p><p id="f0893360-04f5-450f-ae32-74e5da3b233d" class="">Space complexity: O(n) - The space complexity is linear as it depends on the maximum recursion depth, which is equal to <code><strong>n</strong></code>.</p><pre id="c1d43e70-5eed-463e-860f-c81432b956de" class="code"><code>function factorial(n, result = 1) {
  if (n === 0) {
    return result;
  }
  
  return factorial(n - 1, result * n);
}
console.log(factorial(5));
// Output: 120</code></pre></details></li></ul><p id="b9a3ce0c-b7d7-439e-aca2-d7c0aca628c6" class="">
</p></li></ol><ol type="1" id="98d7189d-563e-490e-a2aa-7091c1d9af62" class="numbered-list" start="7"><li><strong>The sum of Array Elements</strong><ul id="d8b758ad-78cd-42a5-b45e-5025ca010c3b" class="toggle"><li><details close=""><summary><strong>Traditional Solution</strong></summary><p id="411ac07f-d8cd-488f-a13b-22ff6504a081" class="">Time complexity: O(n) </p><p id="af7ad377-8453-4185-bd6e-a0b2cdbcb70b" class="">Space complexity: O(n) </p><pre id="90ffae60-892d-4bbc-ba94-d6c9b60806a2" class="code"><code>function sumArray(arr) {
  if (arr.length === 0) {
    return 0;
  }
  
  return arr[0] + sumArray(arr.slice(1));
}
console.log(sumArray([1, 2, 3, 4, 5]));
// Output: 15</code></pre></details></li></ul><ul id="14c47e9e-3464-4aa6-80ae-53fc92a3cd68" class="toggle"><li><details close=""><summary><strong>Optimized Solution</strong></summary><p id="228dc565-160a-4dfd-8cbd-352d1869d62e" class="">Time complexity: O(n) - The optimized solution has a linear time complexity since it avoids slicing the array and keeps track of the current index.</p><p id="0783d9a6-e824-4582-8b52-a89ed622c594" class="">Space complexity: O(n) - The space complexity is linear as it depends on the maximum recursion depth, which is equal to the length of the array.</p><pre id="2dce0426-2cfb-4ccc-b484-62abd4162571" class="code"><code>function sumArray(arr, index = 0) {
  if (index === arr.length) {
    return 0;
  }
  
  return arr[index] + sumArray(arr, index + 1);
}
console.log(sumArray([1, 2, 3, 4, 5]));
// Output: 15</code></pre></details></li></ul><p id="e2af8fc7-b2e5-4a3f-8d35-85b507fd6adb" class="">
</p></li></ol><ol type="1" id="b0c93f4e-cb80-4d9b-ad73-7853501c784c" class="numbered-list" start="8"><li><strong>Power Function</strong><ul id="8ee5510c-bb13-4fe3-8000-ce8bdb1cfa87" class="toggle"><li><details close=""><summary><strong>Traditional Solution</strong></summary><p id="9bd6ec35-9529-4b63-a930-fb6703854480" class="">Time complexity: O(n) </p><p id="c92724cf-4a4b-4596-a98a-3bf4a9bf3d34" class="">Space complexity: O(n)</p><pre id="d21f8bf9-4940-4c36-91a1-481b0e95b50b" class="code"><code>function power(x, n) {
  if (n === 0) {
    return 1;
  }
  
  return x * power(x, n - 1);
}
console.log(power(2, 4));
// Output: 16</code></pre></details></li></ul><ul id="4e1c0954-def3-4a1d-97ba-aa9859b1d9c3" class="toggle"><li><details close=""><summary><strong>Optimized Solution</strong></summary><p id="1e77b789-8c9a-48c7-bbca-897f552d1bf1" class="">Time complexity: O(log n) - The optimized solution has a logarithmic time complexity since it reduces the number of recursive calls by dividing <code><strong>n</strong></code> by 2 in each step.</p><p id="863cdb43-a572-4807-a9e5-2654cc042c5c" class="">Space complexity: O(log n) - The space complexity is logarithmic as it depends on the maximum recursion depth, which is equal to the logarithm of <code><strong>n</strong></code> (base 2).</p><pre id="87031785-2d1a-49c5-b801-9a074deb1310" class="code"><code>function power(x, n) {
  if (n === 0) {
    return 1;
  }
  
  if (n % 2 === 0) {
    const temp = power(x, n / 2);
    return temp * temp;
  }
  
  return x * power(x, n - 1);
}
console.log(power(2, 4));
// Output: 16</code></pre></details></li></ul></li></ol><p id="b24cfec1-2536-4e26-8fe1-3f6531226751" class="">
</p><ol type="1" id="a343e716-7083-477d-aed5-0fa9be440183" class="numbered-list" start="9"><li><strong>Given an array of integers sorted in non-decreasing order, return an array of the squares of each number in non-decreasing order.</strong><p id="57c57e8f-5ad0-490f-adcc-747f590d8306" class="">Example:</p><pre id="2648e9e2-b496-4453-ae13-e788d34c8a20" class="code"><code>Input: [-4, -2, 0, 2, 4]
Output: [0, 4, 4, 16, 16]</code></pre><ul id="893b3fa4-bd56-4cdc-b5f2-a614a2023564" class="toggle"><li><details close=""><summary><strong>Traditional Solution</strong></summary><p id="0e1c2a9b-7caa-4352-8b0d-209f56c25d08" class="">Time complexity: O(nlogn) 
Space complexity: O(n) </p><pre id="890abe9c-6801-4be0-9bd6-1fec58e4ae0e" class="code"><code>function sortedSquares(nums) {
  const result = [];
  for (let i = 0; i &lt; nums.length; i++) {
    result.push(nums[i] * nums[i]);
  }
  result.sort((a, b) =&gt; a - b);
  return result;
}

console.log(sortedSquares([-4, -2, 0, 2, 4]));
// Output: [0, 4, 4, 16, 16]

console.log(sortedSquares([-5, -3, -1, 0, 2, 4, 6]));
// Output: [0, 1, 4, 9, 16, 25, 36]
</code></pre></details></li></ul><ul id="6037eeb7-6850-4b24-b6e6-56c422e590ff" class="toggle"><li><details close=""><summary><strong>Optimized Solution</strong></summary><p id="2d5f2cc2-a997-4d37-9b2d-e7b1adf00643" class="">Time complexity: O(n) 
Space complexity: O(n)</p><p id="21e5757e-c1e1-4e14-b6eb-0c8de5ec095e" class="">We use a two-pointer approach to traverse the input array from both ends, comparing the absolute values and filling the result array in reverse order. This process takes linear time. We create a new array <code>squares</code> of the same length as the input array to store the squared values.</p><pre id="6f23daab-0f7c-4e7f-b44f-f4c04fc67a5b" class="code"><code>function sortedSquares(nums) {
  const result = new Array(nums.length);
  let left = 0;
  let right = nums.length - 1;
  let index = right;
  
  while (left &lt;= right) {
    const leftSquare = nums[left] * nums[left];
    const rightSquare = nums[right] * nums[right];
    
    if (leftSquare &gt; rightSquare) {
      result[index] = leftSquare;
      left++;
    } else {
      result[index] = rightSquare;
      right--;
    }
    
    index--;
  }
  
  return result;
}

console.log(sortedSquares([-4, -2, 0, 2, 4]));
// Output: [0, 4, 4, 16, 16]

console.log(sortedSquares([-5, -3, -1, 0, 2, 4, 6]));
// Output: [0, 1, 4, 9, 16, 25, 36]</code></pre><p id="642597c6-dda8-449e-aa2a-dff8ff380d99" class="">
</p></details></li></ul><p id="952fcdb9-e3d2-49a1-899d-f7532fff0e2e" class="">
</p></li></ol><ol type="1" id="fdd0f1fa-2d7f-4dc6-b5ff-4786955679e5" class="numbered-list" start="10"><li><strong>Given an unsorted array of integers and an integer k, find the kth largest element in the array.</strong><p id="be481938-71df-47b3-9231-d5a0c9d63564" class="">Example:</p><pre id="af6943df-6b93-4fd6-bbc3-886cd04ddbe5" class="code"><code>Input: [3, 2, 1, 5, 6, 4], k = 2
Output: 5</code></pre><ul id="9645b1ff-1ab0-4be7-9ce8-fd442b1c690d" class="toggle"><li><details close=""><summary><strong>Traditional Solution</strong></summary><p id="d8b6b1f7-10a6-485b-8037-f3a0df12dacd" class="">Time Complexity: O(n log n) 
Space Complexity: O(1) </p><pre id="43d8a6d5-f041-4465-993e-ff86bdf18944" class="code"><code>function findKthLargest(nums, k) {
  nums.sort((a, b) =&gt; b - a);
  return nums[k - 1];
}
console.log(findKthLargest([3, 2, 1, 5, 6, 4], 2)); // Output: 5
console.log(findKthLargest([9, 8, 7, 6, 5, 4], 4)); // Output: 6</code></pre></details></li></ul><ul id="f968d318-a81a-4cc8-9c88-a03c4677d136" class="toggle"><li><details close=""><summary><strong>Optimized Solution</strong></summary><p id="eb89761b-954e-44ec-a1ba-a7d85cc13cec" class="">Time Complexity: O(n log n) 
Space Complexity: O(n) </p><p id="f3426660-54e7-49ca-8532-30da3a4a2cbf" class="">The optimized solution simply sorts the array in descending order and returns the kth element from the sorted array. Sorting the array in descending order allows us to easily find the kth largest element by accessing it directly using the index (k - 1).</p><pre id="a8b0e556-6caa-4545-9921-1f0fdb47cd18" class="code"><code>function findKthLargest(nums, k) {
  const sortedNums = nums.sort((a, b) =&gt; b - a);
  return sortedNums[k - 1];
}
console.log(findKthLargest([3, 2, 1, 5, 6, 4], 2)); // Output: 5
console.log(findKthLargest([9, 8, 7, 6, 5, 4], 4)); // Output: 6</code></pre></details></li></ul><p id="c04744d3-16d0-48c9-8f58-898d0cf059b4" class="">
</p></li></ol><ol type="1" id="08a5aae8-70b0-4353-8dd8-ee729eea7a65" class="numbered-list" start="11"><li><strong>Given two integer arrays nums1 and nums2, return an array of their intersection. The intersection is the set of elements that appear in both arrays, in any order.</strong><p id="06352aaf-d5f3-495c-853c-da940dbfe865" class="">Example:</p><pre id="61e437b7-e954-4b45-966b-a98ab6de1dc4" class="code"><code>Input: nums1 = [1, 2, 2, 1], nums2 = [2, 2]
Output: [2]</code></pre><ul id="6252ee4a-27e2-4cc0-9cc4-f6e2557ec743" class="toggle"><li><details close=""><summary><strong>Traditional Solution</strong></summary><p id="a465ee2a-61c8-44ef-9fb4-9287a6fd3d36" class="">Time complexity: O(n * m)</p><p id="a85a2672-4754-4f86-978d-a36daa9f0583" class="">Space complexity: O(k)</p><pre id="97d3d0e9-fd04-4fd6-8352-465dfe792d18" class="code"><code>function intersection(nums1, nums2) {
  const result = [];
  
  for (let num1 of nums1) {
    for (let num2 of nums2) {
      if (num1 === num2 &amp;&amp; !result.includes(num1)) {
        result.push(num1);
      }
    }
  }
  
  return result;
}
console.log(intersection([1, 2, 2, 1], [2, 2]));
// Output: [2]

console.log(intersection([4, 9, 5], [9, 4, 9, 8, 4]));
// Output: [4, 9]</code></pre></details></li></ul><ul id="a1f506b4-ac29-49c2-8087-86b730780092" class="toggle"><li><details close=""><summary><strong>Optimized Solution</strong></summary><p id="9effdc17-fb9e-4321-b3ec-32cac5bfb703" class="">Time complexity: O(n + m)</p><p id="5ab5bb50-71aa-4071-9b93-64d1dabd679c" class="">Space complexity: O(k)</p><p id="cf754bcd-31d6-4538-a0d7-fb6b04417e2a" class="">The optimized solution utilizes a hash set to efficiently find the intersection of the two arrays. It iterates through one array and stores each element in the hash set. Then, it iterates through the other array and checks if each element exists in the hash set. If it does, the element is added to the result array.</p><pre id="c2754dc4-b4fa-42e3-85af-ab1480924c92" class="code"><code>function intersection(nums1, nums2) {
  const set = new Set(nums1);
  const result = [];
  
  for (let num of nums2) {
    if (set.has(num) &amp;&amp; !result.includes(num)) {
      result.push(num);
    }
  }
  
  return result;
}

console.log(intersection([1, 2, 2, 1], [2, 2]));
// Output: [2]

console.log(intersection([4, 9, 5], [9, 4, 9, 8, 4]));
// Output: [4, 9]</code></pre><p id="7884cf23-c1c6-4554-a760-8348ace2dc71" class="">
</p><p id="effc705a-5b5a-47c2-ae89-20d62391f968" class="">
</p><p id="6b16f56f-e2b1-4e71-a637-232287be20a2" class="">
</p></details></li></ul><p id="2fd4e063-9bba-422b-92f5-7b763b12620a" class="">
</p></li></ol><ol type="1" id="8727391a-20b0-4eed-aabc-f4da0850cc57" class="numbered-list" start="12"><li><strong>Given an array of intervals where intervals[i] = [starti, endi], merge overlapping intervals and return the merged intervals in sorted order.</strong><p id="044719fb-08cb-4b26-aa9e-2c7e9b41a915" class="">Example:</p><pre id="4129b208-1533-4e45-858b-8b3b660cf752" class="code"><code>Input: intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
Output: [[1, 6], [8, 10], [15, 18]]</code></pre><ul id="65a10555-997e-492f-9657-3502325a8c3b" class="toggle"><li><details close=""><summary><strong>Traditional Solution</strong></summary><p id="c6c41522-52cc-4752-9418-b5522d947308" class="">Time complexity: O(n log n) 
Space complexity: O(n)</p><pre id="87910f42-17c7-4e53-9703-3442034d6ccb" class="code"><code>function mergeIntervals(intervals) {
  intervals.sort((a, b) =&gt; a[0] - b[0]);
  
  let mergedIntervals = [];
  let currentInterval = intervals[0];
  
  for (let i = 1; i &lt; intervals.length; i++) {
    if (intervals[i][0] &lt;= currentInterval[1]) {
      currentInterval[1] = Math.max(currentInterval[1], intervals[i][1]);
    } else {
      mergedIntervals.push(currentInterval);
      currentInterval = intervals[i];
    }
  }
  
  mergedIntervals.push(currentInterval);
  return mergedIntervals;
}

console.log(mergeIntervals([[1, 3], [2, 6], [8, 10], [15, 18]]));
// Output: [[1, 6], [8, 10], [15, 18]]

console.log(mergeIntervals([[1, 4], [4, 5]]));
// Output: [[1, 5]]

</code></pre></details></li></ul><ul id="2a3f0702-e880-4041-9bbe-c6a81c243dba" class="toggle"><li><details close=""><summary><strong>Optimized Solution</strong></summary><p id="01b33909-8465-4bb0-a175-2e94e7dec207" class="">Time complexity: O(n log n) 
Space complexity: O(n) </p><p id="48c32d89-dd01-4b05-86d1-87606ac33908" class="">The optimized solution also involves sorting the intervals initially. However, instead of iterating over the intervals multiple times, we can merge the intervals in a single pass.</p><pre id="8040bd02-14bc-4652-8bb1-3b5f88ed098e" class="code"><code>function mergeIntervals(intervals) {
  intervals.sort((a, b) =&gt; a[0] - b[0]);
  
  let mergedIntervals = [];
  let currentInterval = intervals[0];
  
  for (let i = 1; i &lt; intervals.length; i++) {
    if (intervals[i][0] &lt;= currentInterval[1]) {
      currentInterval[1] = Math.max(currentInterval[1], intervals[i][1]);
    } else {
      mergedIntervals.push(currentInterval);
      currentInterval = intervals[i];
    }
  }
  
  mergedIntervals.push(currentInterval);
  return mergedIntervals;
}

console.log(mergeIntervals([[1, 3], [2, 6], [8, 10], [15, 18]]));
// Output: [[1, 6], [8, 10], [15, 18]]

console.log(mergeIntervals([[1, 4], [4, 5]]));
// Output: [[1, 5]]

</code></pre></details></li></ul><p id="5f0e7e74-fb14-4f22-b3e5-ba58ce9bbe17" class="">
</p></li></ol><p id="dcf76b9f-3b49-48d0-8a6c-9b6b0d91435f" class="">
</p><h2 id="d43ff538-0fe0-4779-b5c9-5c8f73967c95" class=""><mark class="highlight-blue">Take Home Assignment</mark></h2><ul id="33a3de97-cec8-4647-95d1-c250bc4bdda7" class="toggle"><li><details close=""><summary><strong>Problem 1: Generate Parentheses</strong></summary><p id="bda089cf-8d5d-4438-9250-8d05a3041905" class="">In a small town, a young girl named Lily loved to play with words and symbols. One day, her teacher gave her a challenge. She was given n pairs of parentheses and was asked to generate all combinations of well-formed parentheses.</p><p id="f5f09d0a-29de-4610-b7bc-7259c3945a5d" class="">Lily knew that well-formed parentheses meant that each opening parenthesis had a corresponding closing parenthesis and that they were correctly nested. She set out to solve the problem and generate all the possible combinations of well-formed parentheses.</p><p id="f5df228c-8207-4a67-9d5a-e976176b577f" class="">Can you help Lily solve this problem? Given <code>n</code> pairs of parentheses, can you write a function to generate all combinations of well-formed parentheses?</p><p id="72e3e10b-8e81-42ef-b5a6-79ba954103d1" class=""><strong>Example 1:</strong></p><pre id="166d14a2-3a30-46ae-9de0-88498a6f4617" class="code"><code>Input:  n = 3

Output: [&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre><p id="f75a9973-0885-453d-bffe-d82eb829302b" class=""><strong>Example 2:</strong></p><pre id="46e19568-8d04-4ced-92fa-6b534bb4c87e" class="code"><code>Input:  n = 1

Output: [&quot;()&quot;]</code></pre><p id="a740c045-4d0c-4442-a16b-0ccb7a3ab86c" class=""><strong>Constraints:</strong></p><ul id="dca5becf-c47e-4418-b95a-806a8a93e9cf" class="bulleted-list"><li style="list-style-type:disc">1 &lt;= n &lt;= 8</li></ul></details></li></ul><ul id="762d36eb-fc6b-4861-b82d-148b545adf3b" class="toggle"><li><details close=""><summary><strong>Problem 2: Permutations</strong></summary><p id="1898d73d-411a-495b-9e61-9b3bbf3312f2" class="">In a land of magic and wonder, there was a young wizard named Merlin. Merlin loved experimenting with spells and potions, always seeking new ways to combine ingredients to create powerful magic. One day, he was given an array of distinct integers, <code>nums</code>, and was challenged to find all the possible permutations of the numbers.</p><p id="53c05b76-8385-4f9e-82bf-cffa2f9dda8e" class="">Merlin knew that a permutation is an arrangement of an array&#x27;s elements in a particular order. He set out to solve the problem and find all the possible permutations of the given array.</p><p id="bdddd8cd-0337-42b2-b6ee-00d1d09d0da0" class="">Can you help Merlin solve this problem? Given an array <code>nums</code> of distinct integers, can you return all the possible permutations? You can return the answer in any order.</p><p id="c724d19b-2641-4971-a7f8-52c0f3a134b9" class=""><strong>Example 1:</strong></p><pre id="c9649a75-a79a-4203-a857-e629025f89cd" class="code"><code>Input:  nums = [1,2,3]

Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><p id="e2b84669-461a-4852-abbc-e599175caca0" class=""><strong>Example 2:</strong></p><pre id="f9a5e6c8-7d01-4329-acd5-c0dabc8bc30d" class="code"><code>Input:  nums = [0,1]

Output: [[0,1],[1,0]]</code></pre><p id="a6d1d13d-f3a1-47f6-8a5a-0962f376136a" class=""><strong>Constraints:</strong></p><ul id="165ffaf2-1440-4932-bcc5-b1ded8fbb7f3" class="bulleted-list"><li style="list-style-type:disc">1 &lt;= nums.length &lt;= 6</li></ul><ul id="54905fe7-7151-4731-9771-f5db9df1595f" class="bulleted-list"><li style="list-style-type:disc">10 &lt;= nums[i] &lt;= 10</li></ul><ul id="8f40b468-c873-4cbd-b8ef-d4879e40fcce" class="bulleted-list"><li style="list-style-type:disc">All the integers of nums are unique.</li></ul></details></li></ul><ul id="969f8991-1ae5-4995-a39f-7f79448a5111" class="toggle"><li><details close=""><summary><strong>Problem 3: Power of 2</strong></summary><p id="aa64bdd6-d859-4111-a0e4-8cfa52e7bdd5" class="">In a small village, there lived a wise old man who was known for his ability to solve complex problems. One day, a young girl came to him with a question. She had been given an integer n and wanted to know if it was a power of two.</p><p id="98530c67-5225-4a6b-b8e1-13f6cc4a8604" class="">The wise old man explained to the girl that an integer n is a power of two if there exists an integer x such that n == 2x. He then asked her if she could solve this problem and determine whether the given number was indeed a power of two.</p><p id="98d4ae00-4968-4cce-800e-66833eaae72d" class="">Can you help the girl solve this problem? Given an integer <code>n</code>, can you determine if it is a power of two? Return true if it is; otherwise, return false.</p><p id="cd5624e1-6948-4a6d-98e5-0d8609ebb227" class=""><strong>Example 1:</strong></p><pre id="c1190ef8-8a3d-4bcd-802d-801b673b8298" class="code"><code>Input:  n = 1

Output: true</code></pre><p id="b415dba8-af04-4196-8014-9c02c4d754ba" class=""><strong>Example 2:</strong></p><pre id="f36496a3-01cb-4213-b171-ad9c75dcd24c" class="code"><code>Input:  n = 3

Output: false</code></pre><p id="607e0dd9-880d-4cc1-a9df-a79c42539f6d" class="">
</p><p id="b8ac7a1c-a785-46b8-83ab-15b54a1d378b" class=""><strong>Constraints:</strong></p><ul id="f81017e5-dd28-417d-94e5-c278f3f63986" class="bulleted-list"><li style="list-style-type:disc">231 &lt;= n &lt;= 231 - 1</li></ul></details></li></ul><p id="7e6a3543-a4be-416c-84d8-f6cfed498bab" class="">
</p></div></article></body></html>
