<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Skill Mastery Challenge</title><link rel="stylesheet" href="../../../../../styles.css"></head><body><article id="bdae1e26-3af6-4f11-8fa4-cf43eb173f9a" class="page sans"><header><h1 class="page-title">Skill Mastery Challenge</h1><p class="page-description"></p></header><div class="page-body"><h2 id="ff245010-9289-42b1-800b-c2de9ff95e09" class="block-color-default"><mark class="highlight-red">What did we learn?</mark></h2><ul id="81fd186b-4577-41be-8ba0-8916a075b74e" class="bulleted-list"><li style="list-style-type:disc">Recursion is a powerful technique used to solve problems by breaking them down into smaller subproblems and then solving those subproblems recursively.</li></ul><ul id="d0dd8bea-1f4b-4387-a219-d2eef3e791c6" class="bulleted-list"><li style="list-style-type:disc">Recursive functions have a base case and a recursive case. The base case defines the simplest form of the problem that can be solved without recursion, while the recursive case is the set of instructions that recursively solves the problem by reducing it to a smaller subproblem.</li></ul><ul id="b5086df0-b0b6-4b7e-8e12-26862004d83e" class="bulleted-list"><li style="list-style-type:disc">Recursion can be used to solve problems in various domains, such as mathematical calculations, searching and sorting, and computer graphics.</li></ul><ul id="83588754-eddc-4e9f-96f7-1c176c06393b" class="bulleted-list"><li style="list-style-type:disc">The time and space complexity analysis of a recursive algorithm is crucial in determining its efficiency. Inefficient recursive algorithms may result in a stack overflow, which can crash the program or the system.</li></ul><ul id="b522e91b-fa0e-456c-82f6-0a1d789d6fb0" class="bulleted-list"><li style="list-style-type:disc">Backtracking is an algorithmic technique used to solve problems by exploring all possible solutions and removing those solutions that do not satisfy the problem constraints.</li></ul><ul id="cf973b7a-412f-4ce6-b5df-b1bbfa652934" class="bulleted-list"><li style="list-style-type:disc">Backtracking can be used to solve problems, such as finding all possible solutions to a puzzle or finding the shortest path in a graph.</li></ul><ul id="7330bb20-4549-4251-8601-10e71fbd88d6" class="bulleted-list"><li style="list-style-type:disc">The time and space complexity analysis of a backtracking algorithm is essential in determining its efficiency. Inefficient backtracking algorithms may result in high memory usage and long execution times.</li></ul><h2 id="8d310972-7c8d-46bf-8ea3-6e068081819b" class="block-color-default"><mark class="highlight-red">Best Practices to follow</mark></h2><ul id="dab7571e-8bb8-4b01-9b86-a268c58495a0" class="bulleted-list"><li style="list-style-type:disc">Before writing the recursive function or backtracking algorithm, it is important to understand the problem statement thoroughly. </li></ul><ul id="c8b619a6-58f5-4a6c-b963-dcc39da0b778" class="bulleted-list"><li style="list-style-type:disc">Identifying the base cases correctly is crucial for the proper functioning of the algorithm.</li></ul><ul id="a50d5f87-c24a-4b8f-84f6-a453ee2a3ab1" class="bulleted-list"><li style="list-style-type:disc">It is essential to print the intermediate values of variables and parameters to understand the flow of the code better.</li></ul><ul id="3aceedb9-33f4-49a3-aadc-a216d12441bc" class="bulleted-list"><li style="list-style-type:disc">It is important to analyze the time and space complexity of the algorithm before implementing it.</li></ul><ul id="25d82627-0636-4489-b5d9-d3e75ba8b016" class="bulleted-list"><li style="list-style-type:disc">In tail recursion, the recursive call is the last statement in the function. This reduces the overhead of the call stack, leading to better performance.</li></ul><ul id="2ea420ea-fe90-429c-b037-22e5d30989d9" class="bulleted-list"><li style="list-style-type:disc">Memoization can be used to optimize recursive functions and backtracking algorithms.</li></ul><h2 id="3dccf69f-15d8-4378-9333-e130a3068bea" class=""><mark class="highlight-red">Interview Prep</mark></h2><h3 id="e7eb95cb-1963-4ee6-b80e-d77cc4db00c9" class="">Advantages of binary search over linear search</h3><p id="d2313c55-a634-413f-bcb8-4415e5eeacb6" class="">The main advantage of binary search over linear search is that it has a faster average case and worst-case time complexity, especially for large arrays. This is because, with each iteration, binary search eliminates half of the remaining search space, whereas linear search has to check every element in the array sequentially.</p><h3 id="1cc4a93e-abc6-4669-ad27-2238a86a0a96" class="">Variation in the performance of linear search and binary search with the size of the input array in JavaScript</h3><p id="b140deb9-3019-4a96-881c-2b7248398b52" class="">The performance of linear search grows linearly with the size of the input array, meaning that as the array size increases, the time it takes to search for an element will also increase linearly. On the other hand, the performance of binary search grows logarithmically with the size of the input array, meaning that as the array size increases, the time it takes to search for an element will increase much more slowly.</p><h3 id="7ca4d321-526f-4a3b-bc59-8e6e772dff5a" class="">Implementation of an iterative version of the binary search algorithm without using recursion</h3><p id="c445d80f-20df-484f-b338-1e6ab6dc06e4" class="">Here&#x27;s an iterative implementation of the binary search algorithm in JavaScript without using recursion:</p><pre id="e7e9962e-a3f5-4838-ae78-cdb5cf609f88" class="code"><code>function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left &lt;= right) {
    let mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      return mid;
    }

    if (arr[mid] &lt; target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}</code></pre><p id="77029f8c-8f52-4ed7-832c-99671e1f45d0" class="">This implementation follows the same logic as the previous example. We initialize the <code>left</code> pointer to the start of the array (<code>0</code>) and the <code>right</code> pointer to the end of the array (<code>arr.length - 1</code>). The loop continues until the <code>left</code> pointer is less than or equal to the <code>right</code> pointer. Inside the loop, we calculate the <code>mid</code> index as the floor division of the sum of <code>left</code> and <code>right</code> by <code>2</code>. We compare the element at <code>arr[mid]</code> with the target value, update the <code>left</code> or <code>right</code> pointer accordingly, and continue the search.</p><p id="f617b05d-c139-44a7-bfe8-0b1732dddd18" class="">The function returns the index of the target element if found, or <code>-1</code> if it is not present in the array.</p><h3 id="9dd679f2-aec6-446f-ad77-81621b036926" class="">Hashmap and Collision Handling</h3><p id="981136c0-1f78-4f22-b5c8-13c5d51d5c10" class="">When a hashmap encounters a collision, which occurs when two different keys map to the same hash value, it needs a mechanism to handle it. Here are some collision resolution strategies commonly used in hashmaps:</p><ul id="893fbd5b-d96d-4b12-a30c-96a292b63321" class="bulleted-list"><li style="list-style-type:disc"><strong>Separate Chaining: </strong>Each bucket in the hashmap contains a linked list or another data structure to store multiple elements with the same hash value. Colliding elements are appended to the corresponding bucket&#x27;s chain.</li></ul><ul id="78ca74dd-6287-46bb-98a8-4ca04b038d8e" class="bulleted-list"><li style="list-style-type:disc"><strong>Open Addressing:</strong> Instead of separate data structures for collisions, the hashmap stores colliding elements directly in the buckets. When a collision occurs, the algorithm probes the next available slot in the hashmap until an empty slot is found.<ul id="cb7e902a-c2fd-423d-89c2-0937f7409a1b" class="bulleted-list"><li style="list-style-type:circle"><strong>Linear Probing:</strong> The algorithm checks the next consecutive slot until an empty slot is found.</li></ul><ul id="5ff97218-2ae1-47b9-ba79-a477c6956e23" class="bulleted-list"><li style="list-style-type:circle"><strong>Quadratic Probing: </strong>The algorithm checks slots using quadratic increments (e.g., 1, 4, 9, ...) until an empty slot is found.</li></ul><ul id="07e38df9-ce5a-420c-8c7b-16f70a2a8ec1" class="bulleted-list"><li style="list-style-type:circle"><strong>Double Hashing:</strong> The algorithm uses a second hash function to determine the step size for probing. It checks slots with an increment specified by the second hash function until an empty slot is found.</li></ul></li></ul><p id="bc4b6bee-c337-4097-86a4-64e64f93f2c4" class="">Each strategy has its advantages and trade-offs in terms of memory usage, lookup efficiency, and ease of implementation. The choice of collision resolution strategy depends on factors such as the expected number of collisions, the distribution of keys, and the desired performance characteristics of the hashmap.</p><h3 id="a80be558-7ad4-4339-b43d-79106aa0e2af" class="">Load factor in a Hashmap &amp; performance</h3><p id="f91aee21-cd4c-4926-8185-4d6473473ecc" class="">The load factor in a hashmap is a measure of how full the hashmap is. It is defined as the ratio of the number of elements stored in the hashmap to the total number of slots or buckets available.</p><p id="8912e5ad-355f-4b56-9012-ffca37381738" class=""><code>Load factor = Number of elements / Total number of slots</code></p><p id="c1cc6b53-fab9-4d73-8826-5c5c8f77360f" class="">A higher load factor means the hashmap is more full, while a lower load factor indicates it is less full. The load factor determines the average number of elements stored in each bucket of the hashmap.</p><p id="04c6a3be-e361-4fc8-ae3a-2add25ceff99" class="">The load factor directly impacts the performance of the hashmap. When the load factor increases, the hashmap becomes more crowded, resulting in more collisions. This can lead to longer lookup times as elements need to be searched within the same bucket using collision resolution techniques.</p><p id="3d7e9839-9bea-4014-bf9c-be56e18b5a0a" class="">To maintain efficient performance, it is recommended to keep the load factor within a certain range (usually around 0.7 or 0.8). When the load factor exceeds a threshold, the hashmap is resized, increasing the number of buckets to accommodate more elements. This process is called rehashing.</p><p id="552a7807-cb60-4f3d-a9b4-ef9dc7d462ba" class="">By carefully managing the load factor, hashmaps can achieve a balance between memory usage and efficient lookup times, ensuring optimal performance for various operations like insertion, deletion, and retrieval.</p><h3 id="71e8a36b-cc34-4813-a6ba-c7e90c4d1e73" class="">Determining the optimal searching algorithm for a specific problem</h3><p id="c3932d17-983a-467c-b9c0-12dbadb24a2d" class="">The optimal searching algorithm for a specific problem depends on the characteristics of the problem and the data being searched. We can determine the optimal searching algorithm by considering factors such as the size of the data, the frequency of searches, the structure of the data, and any additional constraints or requirements. We can also use time and space complexity analysis to compare the performance of different searching algorithms and select the one that provides the best tradeoff between time and space complexity.</p><h2 id="8f220f3c-2afc-4757-a5fc-9c1c250181eb" class="block-color-default"><mark class="highlight-red">Challenges &amp; Shortcomings</mark></h2><ul id="53ac7d5c-7b67-465d-8cad-20c3173b55a6" class="bulleted-list"><li style="list-style-type:disc">Recursive algorithms may cause stack overflow if the depth of the recursion is too large.</li></ul><ul id="7763eacb-78d0-4e2e-8963-a8926421a93b" class="bulleted-list"><li style="list-style-type:disc">Recursion and backtracking can be slower than their iterative counterparts, especially for large inputs or complex problems.</li></ul><ul id="95c20aba-1252-4753-b2f5-56c782f8b846" class="bulleted-list"><li style="list-style-type:disc">Recursion may require extra memory for the function call stack. In the case of backtracking, additional memory may be required to store the solution and the search space.</li></ul><ul id="681a2d38-a44d-428a-8892-cb71eea623ea" class="bulleted-list"><li style="list-style-type:disc">Recursive code can be difficult to debug, as the execution order may not be immediately clear. </li></ul><h2 id="68cb459f-bfb6-4262-9003-1fad24ff13b4" class="block-color-default"><mark class="highlight-red">Enhance your knowledge</mark></h2><ul id="001ce915-c91a-4ca9-a7d2-db9094452464" class="bulleted-list"><li style="list-style-type:disc"><a href="https://developer.mozilla.org/en-US/docs/Glossary/Recursion">https://developer.mozilla.org/en-US/docs/Glossary/Recursion</a></li></ul><ul id="8022fc91-e646-4a4b-8d9a-9ee381bb3850" class="bulleted-list"><li style="list-style-type:disc"><a href="https://stackoverflow.com/questions/26670757/difference-between-backtracking-and-recursion">Difference between backtracking and recursion?</a></li></ul></div></article></body></html>